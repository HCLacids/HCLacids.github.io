{"meta":{"title":"HCL's Blog","subtitle":"Recording the study progress","description":"Fighting!","author":"HCLacids","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"React Reudx","slug":"React Reudx","date":"2020-10-30T06:38:13.095Z","updated":"2020-10-31T06:21:22.788Z","comments":true,"path":"2020/10/30/React Reudx/","link":"","permalink":"http://yoursite.com/2020/10/30/React%20Reudx/","excerpt":"","text":"Connect()Connect()是连接React和Redux store的函数。 它可以从Store当中拿出一些碎片的数据，传递给和它相连的组件。函数还可以发送一些action给Store。 它不会修改传递给它的组件类。而是返回一个新的，已连接的组件类，该类包含传入的组件。 1function connect(mapStateToProps?, mapDispatchToProps?, mergeProps?, options?) mapStateToProps和mapDispatchToProps分别处理的是Redux Store的state数据和dispatch方法。 函数返回的mapStateToProps和mapDispatchToProps分别指向组件内部的stateProps和dispatchProps。 connect() 参数connect 可以接受四个不同的参数, 全部都是可选的： mapStateToProps?: Function mapDispatchToProps?: Function | Object mergeProps?: Function options?: Object Connect: Extracting Data with mapStateToProps作为第一个传入connect的参数，mapStateToProps从Store选择一部分数据，传给需要的组件。 当store的state数据变化的时候会调用改函数。 它接受一整个store state，返回一个对象包含组件需要的数据。 定义 mapStateToPropsmapStateToProps应该被定义为一个函数： 1function mapStateToProps(state, ownProps?) 它应该接受一个名为state的第一个参数，可以选择一个称为ownProps的第二个参数，并返回一个包含连接组件所需数据的普通对象。 此函数应作为connect的第一个参数传递，并将在每次Redux存储状态更改时调用。如果您不想订阅存储，请传递null或undefined来代替mapStateToProps进行连接。 不管mapstatetops函数是使用function关键字（function mapState（state）{}）还是作为箭头函数（constmapstate=（state）=&gt;{}编写的，它的工作方式都是一样的。 Arguments state ownProps (可选的) statemapStateToProps函数的第一个参数是整个Redux存储状态（调用存储.getState()). 因此，第一个论点传统上被称为state。（虽然您可以给参数指定任何名称，但将其称为store是不正确的-它是“state value”，而不是“store instance”。） 至少state作为参数是应该被传入到mapStateToProps函数。 12345function mapStateToProps(state) &#123; const &#123; todos &#125; = state return &#123; todoList: todos.allIds &#125;&#125;export default connect(mapStateToProps)(TodoList) ownProps (optional)如果组件需要从自己的属性中获取数据来从存储中检索数据，则可以使用第二个参数ownProps定义函数。此参数将包含给connect生成的包装器组件的所有属性。 123456789101112function mapStateToProps(state, ownProps) &#123; const &#123; visibilityFilter &#125; = state const &#123; id &#125; = ownProps const todo = getTodoById(state, id) // component receives additionally: return &#123; todo, visibilityFilter &#125;&#125;// Later, in your application, a parent component renders:;&lt;ConnectedTodo id=&#123;123&#125; /&gt;// and your component receives props.id, props.todo, and props.visibilityFilter ReturnmapToProps函数应返回一个包含组件所需数据的纯对象： Each field in the object will become a prop for your actual component The values in the fields will be used to determine if your component needs to re-render 123456789function mapStateToProps(state) &#123; return &#123; a: 42, todos: state.todos, filter: state.visibilityFilter &#125;&#125;// component will receive: props.a, props.todos, and props.filter Usage Guidelines Let mapStateToProps Reshape the Data from the Store Use Selector Functions to Extract and Transform Data mapStateToProps Functions Should Be Fast mapStateToProps Functions Should Be Pure and Synchronous Connect: Dispatching Actions with mapDispatchToProps作为传递给connect的第二个参数，mapDispatchToProps用于将操作分派到存储区。 dispatch是Redux Store之中唯一的函数。我们只有调用store.dispatch去发送一个action。 使用React Redux，您的组件永远不会直接访问存储区—connect会为您执行此操作。React Redux为您提供了两种让组件分派操作的方法： By default, a connected component receives props.dispatch and can dispatch actions itself. connect can accept an argument called mapDispatchToProps, which lets you create functions that dispatch when called, and pass those functions as props to your component. Approaches for DispatchingDefault: dispatch as a Prop如果不指定connect（）的第二个参数，则默认情况下，组件将接收dispatch。例如： 123456789connect()(MyComponent)// which is equivalent withconnect( null, null)(MyComponent)// orconnect(mapStateToProps /** no second argument */)(MyComponent) 以这种方式连接组件后，组件将接收道具调度. 您可以使用它将操作分派到存储。 12345678910function Counter(&#123; count, dispatch &#125;) &#123; return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: 'DECREMENT' &#125;)&#125;&gt;-&lt;/button&gt; &lt;span&gt;&#123;count&#125;&lt;/span&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: 'INCREMENT' &#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: 'RESET' &#125;)&#125;&gt;reset&lt;/button&gt; &lt;/div&gt; )&#125; Providing A mapDispatchToProps Parameter提供mapDispatchToProps允许您指定哪一种的action需要被分派。它允许您提供action dispatch作为传参。因此，与其调用函数props.dispatch(()=&gt;increment())，可以调用直接调用prop.increment()。你可能想这么做有几个原因。 More Declarative首先，将dispatch逻辑封装到函数中使实现更具声明性。dispatch一个动作并让Redux存储处理数据流是如何实现行为的，而不是它做什么。 一个很好的例子是在单击按钮时dispatch操作。直接连接按钮在概念上可能没有意义，按钮引用dispatch也没有意义。 12345// button needs to be aware of \"dispatch\"&lt;button onClick=&#123;() =&gt; dispatch(&#123; type: \"SOMETHING\" &#125;)&#125; /&gt;// button unaware of \"dispatch\",&lt;button onClick=&#123;doSomething&#125; /&gt; 一旦您用dispatch动作的函数包装了所有action创建者，组件就不需要分派了。因此，如果您定义自己的mapDispatchToProps，则连接的组件将不再接收dispatch。 Pass Down Action Dispatching Logic to ( Unconnected ) Child Components此外，您还可以将操作分派函数传递给子（可能是未连接的）组件。这允许更多的组件分派动作，同时让它们“不知道”Redux。 123456789// pass down toggleTodo to child component// making Todo able to dispatch the toggleTodo actionconst TodoList = (&#123; todos, toggleTodo &#125;) =&gt; ( &lt;div&gt; &#123;todos.map(todo =&gt; ( &lt;Todo todo=&#123;todo&#125; onClick=&#123;toggleTodo&#125; /&gt; ))&#125; &lt;/div&gt;) 这就是React Redux的connect所做的——它封装了与Redux store对话的逻辑，让您不用担心它。这是你应该在你的实现中充分利用的。 Two Forms of mapDispatchToPropsmapDispatchToProps参数可以有两种形式。虽然函数形式允许更多的定制，但对象形式易于使用。 Function form: Allows more customization, gains access to dispatch and optionally ownProps Object shorthand form: More declarative and easier to use Defining mapDispatchToProps As A Function将mapDispatchToProps定义为一个函数，可以在自定义组件接收的函数以及它们如何分派操作方面提供最大的灵活性。你可以获得调度和拥有权。您可以利用这个机会编写自定义函数，以供连接的组件调用。 Arguments dispatch ownProps (optional) dispatch 将调用mapDispatchToProps函数，并将dispatch作为第一个参数。通常，通过返回在其内部调用dispatch()的新函数，并直接传入纯操作对象或传入操作创建者的结果来使用此方法。 12345678const mapDispatchToProps = dispatch =&gt; &#123; return &#123; // dispatching plain actions increment: () =&gt; dispatch(&#123; type: 'INCREMENT' &#125;), decrement: () =&gt; dispatch(&#123; type: 'DECREMENT' &#125;), reset: () =&gt; dispatch(&#123; type: 'RESET' &#125;) &#125;&#125; 您还可能希望将参数转发给action creator： 12345678910const mapDispatchToProps = dispatch =&gt; &#123; return &#123; // explicitly forwarding arguments onClick: event =&gt; dispatch(trackClick(event)), //trackClick() is an anction creator // implicitly forwarding arguments onReceiveImpressions: (...impressions) =&gt; dispatch(trackImpressions(impressions)) //trackImpressions() is also an anction creator &#125;&#125; ownProps ( optional ) 如果您的mapDispatchToProps函数被声明为接受两个参数，那么它将被调用，第一个参数是dispatch，传递给连接组件的属性作为第二个参数，并且在连接的组件接收到新的属性时将重新调用它。 这意味着，在组件重新呈现时，您可以在组件的属性发生更改时进行重新绑定，而不是在组件重新呈现时将新的属性重新绑定到action dispatchers。 Binds on component mount 123456789render() &#123; return &lt;button onClick=&#123;() =&gt; this.props.toggleTodo(this.props.todoId)&#125; /&gt;&#125;const mapDispatchToProps = dispatch =&gt; &#123; return &#123; toggleTodo: todoId =&gt; dispatch(toggleTodo(todoId)) &#125;&#125; Binds on props change 123456789render() &#123; return &lt;button onClick=&#123;() =&gt; this.props.toggleTodo()&#125; /&gt;&#125;const mapDispatchToProps = (dispatch, ownProps) =&gt; &#123; return &#123; toggleTodo: () =&gt; dispatch(toggleTodo(ownProps.todoId)) &#125;&#125; ReturnmapDispatchToProps函数应返回一个纯对象： Each field in the object will become a separate prop for your own component, and the value should normally be a function that dispatches an action when called. If you use action creators ( as oppose to plain object actions ) inside dispatch, it is a convention to simply name the field key the same name as the action creator: 123456789101112const increment = () =&gt; (&#123; type: 'INCREMENT' &#125;)const decrement = () =&gt; (&#123; type: 'DECREMENT' &#125;)const reset = () =&gt; (&#123; type: 'RESET' &#125;)const mapDispatchToProps = dispatch =&gt; &#123; return &#123; // dispatching actions returned by action creators increment: () =&gt; dispatch(increment()), decrement: () =&gt; dispatch(decrement()), reset: () =&gt; dispatch(reset()) &#125;&#125; mapDispatchToProps函数的返回将作为道具合并到连接的组件中。你可以直接调用他们，让他们dispatch action。 12345678910function Counter(&#123; count, increment, decrement, reset &#125;) &#123; return ( &lt;div&gt; &lt;button onClick=&#123;decrement&#125;&gt;-&lt;/button&gt; &lt;span&gt;&#123;count&#125;&lt;/span&gt; &lt;button onClick=&#123;increment&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;reset&#125;&gt;reset&lt;/button&gt; &lt;/div&gt; )&#125; Defining the mapDispatchToProps Function with bindActionCreators手动的将这些函数包装起来是可笑的，所以Redux提供了一个函数去简化。 bindActionCreators accepts two parameters: A function (an action creator) or an object (each field an action creator) dispatch bindActionCreators生成的包装器函数将自动转发它们的所有参数，因此您不需要手动执行此操作。 123456789101112131415161718192021import &#123; bindActionCreators &#125; from 'redux'const increment = () =&gt; (&#123; type: 'INCREMENT' &#125;)const decrement = () =&gt; (&#123; type: 'DECREMENT' &#125;)const reset = () =&gt; (&#123; type: 'RESET' &#125;)// binding an action creator// returns (...args) =&gt; dispatch(increment(...args))const boundIncrement = bindActionCreators(increment, dispatch)// binding an object full of action creatorsconst boundActionCreators = bindActionCreators( &#123; increment, decrement, reset &#125;, dispatch)// returns// &#123;// increment: (...args) =&gt; dispatch(increment(...args)),// decrement: (...args) =&gt; dispatch(decrement(...args)),// reset: (...args) =&gt; dispatch(reset(...args)),// &#125; To use bindActionCreators in our mapDispatchToProps function: 123456789101112import &#123; bindActionCreators &#125; from 'redux'// ...function mapDispatchToProps(dispatch) &#123; return bindActionCreators(&#123; increment, decrement, reset &#125;, dispatch)&#125;// component receives props.increment, props.decrement, props.resetconnect( null, mapDispatchToProps)(Counter) Manually Injecting dispatch如果提供了mapDispatchToProps参数，组件将不再接收默认分派。您可以通过手动将其添加到mapDispatchToProps的返回中来恢复它，尽管大多数情况下您不需要这样做： 123456789import &#123; bindActionCreators &#125; from 'redux'// ...function mapDispatchToProps(dispatch) &#123; return &#123; dispatch, ...bindActionCreators(&#123; increment, decrement, reset &#125;, dispatch) &#125;&#125; Defining mapDispatchToProps As An Object您已经看到，在React组件中调度Redux动作的设置过程非常相似：定义一个动作创建者，将其包装在另一个类似于的函数中(…args) =&gt; dispatch(actionCreator(…args))，并将该包装函数作为prop传递给您的组件。 因为这很普遍，所以connect支持参数的“对象简写”形式mapDispatchToProps：如果传递的对象中包含操作创建者而不是函数，connect则将bindActionCreators在内部自动调用您。 我们建议始终使用的“对象简写”形式mapDispatchToProps，除非您有特定的原因自定义调度行为。 注意： mapDispatchToProps假定对象的每个字段都是动作创建者 您的组件将不再dispatch作为道具接收 12// React Redux does this for you automatically:dispatch =&gt; bindActionCreators(mapDispatchToProps, dispatch) Therefore, our mapDispatchToProps can simply be: 12345const mapDispatchToProps = &#123; increment, decrement, reset&#125; Since the actual name of the variable is up to you, you might want to give it a name like actionCreators, or even define the object inline in the call to connect: 12345678910111213import &#123;increment, decrement, reset&#125; from \"./counterActions\";const actionCreators = &#123; increment, decrement, reset&#125;export default connect(mapState, actionCreators)(Counter);// orexport default connect( mapState, &#123; increment, decrement, reset &#125;)(Counter);","categories":[],"tags":[]},{"title":"Redux","slug":"Redux","date":"2020-09-16T11:46:19.096Z","updated":"2020-10-26T08:07:08.696Z","comments":true,"path":"2020/09/16/Redux/","link":"","permalink":"http://yoursite.com/2020/09/16/Redux/","excerpt":"","text":"Redux什么时候需要 Redux首先明确一点，Redux 是一个有用的架构，但不是非用不可。事实上，大多数情况，你可以不用它，只用 React 就够了。 简单说，如果你的UI层非常简单，没有很多互动，Redux 就是不必要的，用了反而增加复杂性。Redux 的适用场景：多交互、多数据源。 从组件角度看，如果你的应用有以下场景，可以考虑使用 Redux。 某个组件的状态，需要共享 某个状态需要在任何地方都可以拿到 一个组件需要改变全局状态 一个组件需要改变另一个组件的状态 基本概念和 APIStoreStore 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。 Redux 提供createStore这个函数，用来生成 Store。 12import &#123; createStore &#125; from 'redux';const store = createStore(fn); 上面代码中，createStore函数接受另一个函数作为参数，返回新生成的 Store 对象。 StateStore对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。 当前时刻的 State，可以通过store.getState()拿到。 1234import &#123; createStore &#125; from 'redux';const store = createStore(fn);const state = store.getState(); Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。 ActionState 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。 Action 是一个对象。其中的type属性是必须的，表示 Action 的名称。 1234const action = &#123; type: 'ADD_TODO', payload: 'Learn Redux'&#125;; 上面代码中，Action 的名称是ADD_TODO，它携带的信息是字符串Learn Redux。 可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。 Action CreatorView 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator。 12345678910const ADD_TODO = '添加 TODO';function addTodo(text) &#123; return &#123; type: ADD_TODO, text &#125;&#125;const action = addTodo('Learn Redux'); 上面代码中，addTodo函数就是一个 Action Creator。 store.dispatch()store.dispatch()是 View 发出 Action 的唯一方法。 1234567import &#123; createStore &#125; from 'redux';const store = createStore(fn);store.dispatch(&#123; type: 'ADD_TODO', payload: 'Learn Redux'&#125;); 上面代码中，store.dispatch接受一个 Action 对象作为参数，将它发送出去。 结合 Action Creator，这段代码可以改写如下。 1store.dispatch(addTodo('Learn Redux')); ReducerStore 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。 Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。 1234const reducer = function (state, action) &#123; // ... return new_state;&#125;; 整个应用的初始状态，可以作为 State 的默认值。下面是一个实际的例子。 1234567891011121314const defaultState = 0;const reducer = (state = defaultState, action) =&gt; &#123; switch (action.type) &#123; case 'ADD': return state + action.payload; default: return state; &#125;&#125;;const state = reducer(1, &#123; type: 'ADD', payload: 2&#125;); 上面代码中，reducer函数收到名为ADD的 Action 以后，就返回一个新的 State，作为加法的计算结果。其他运算的逻辑（比如减法），也可以根据 Action 的不同来实现。 实际应用中，Reducer 函数不用像上面这样手动调用，store.dispatch方法会触发 Reducer 的自动执行。为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入createStore方法。 12import &#123; createStore &#125; from 'redux';const store = createStore(reducer); 上面代码中，createStore接受 Reducer 作为参数，生成一个新的 Store。以后每当store.dispatch发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State。 为什么这个函数叫做 Reducer 呢？因为它可以作为数组的reduce方法的参数。请看下面的例子，一系列 Action 对象按照顺序作为一个数组。 1234567const actions = [ &#123; type: 'ADD', payload: 0 &#125;, &#123; type: 'ADD', payload: 1 &#125;, &#123; type: 'ADD', payload: 2 &#125;];const total = actions.reduce(reducer, 0); // 3 上面代码中，数组actions表示依次有三个 Action，分别是加0、加1和加2。数组的reduce方法接受 Reducer 函数作为参数，就可以直接得到最终的状态3。 纯函数什么是纯函数？https://www.jianshu.com/p/a5a6d4399d69 由于 Reducer 是纯函数，就可以保证同样的State，必定得到同样的 View。但也正因为这一点，Reducer 函数里面不能改变 State，必须返回一个全新的对象，请参考下面的写法。 1234567891011// State 是一个对象function reducer(state, action) &#123; return Object.assign(&#123;&#125;, state, &#123; thingToChange &#125;); // 或者 return &#123; ...state, ...newState &#125;;&#125;// State 是一个数组function reducer(state, action) &#123; return [...state, newItem];&#125; 最好把 State 对象设成只读。你没法改变它，要得到新的 State，唯一办法就是生成一个新对象。这样的好处是，任何时候，与某个 View 对应的 State 总是一个不变的对象。 store.subscribe()Store 允许使用store.subscribe方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。 1234import &#123; createStore &#125; from 'redux';const store = createStore(reducer);store.subscribe(listener); 显然，只要把 View 的更新函数（对于 React 项目，就是组件的render方法或setState方法）放入listen，就会实现 View 的自动渲染。 store.subscribe方法返回一个函数，调用这个函数就可以解除监听。 12345let unsubscribe = store.subscribe(() =&gt; console.log(store.getState()));unsubscribe(); Store 的实现上一节介绍了 Redux 涉及的基本概念，可以发现 Store 提供了三个方法。 store.getState() store.dispatch() store.subscribe() 12import &#123; createStore &#125; from 'redux';let &#123; subscribe, dispatch, getState &#125; = createStore(reducer); createStore方法还可以接受第二个参数，表示 State 的最初状态。这通常是服务器给出的。 1let store = createStore(todoApp, window.STATE_FROM_SERVER) 上面代码中，window.STATE_FROM_SERVER就是整个应用的状态初始值。注意，如果提供了这个参数，它会覆盖 Reducer 函数的默认初始值。 下面是createStore方法的一个简单实现，可以了解一下 Store 是怎么生成的。 12345678910111213141516171819202122const createStore = (reducer) =&gt; &#123; let state; let listeners = []; const getState = () =&gt; state; const dispatch = (action) =&gt; &#123; state = reducer(state, action); listeners.forEach(listener =&gt; listener()); &#125;; const subscribe = (listener) =&gt; &#123; listeners.push(listener); return () =&gt; &#123; listeners = listeners.filter(l =&gt; l !== listener); &#125; &#125;; dispatch(&#123;&#125;); return &#123; getState, dispatch, subscribe &#125;;&#125;; Reducer 的拆分Reducer 函数负责生成 State。由于整个应用只有一个 State 对象，包含所有数据，对于大型应用来说，这个 State 必然十分庞大，导致 Reducer 函数也十分庞大。 请看下面的例子。 123456789101112131415161718const chatReducer = (state = defaultState, action = &#123;&#125;) =&gt; &#123; const &#123; type, payload &#125; = action; switch (type) &#123; case ADD_CHAT: return Object.assign(&#123;&#125;, state, &#123; chatLog: state.chatLog.concat(payload) &#125;); case CHANGE_STATUS: return Object.assign(&#123;&#125;, state, &#123; statusMessage: payload &#125;); case CHANGE_USERNAME: return Object.assign(&#123;&#125;, state, &#123; userName: payload &#125;); default: return state; &#125;&#125;; 上面代码中，三种 Action 分别改变 State 的三个属性。 ADD_CHAT：chatLog属性 CHANGE_STATUS：statusMessage属性 CHANGE_USERNAME：userName属性 这三个属性之间没有联系，这提示我们可以把 Reducer 函数拆分。不同的函数负责处理不同属性，最终把它们合并成一个大的 Reducer 即可。 1234567const chatReducer = (state = defaultState, action = &#123;&#125;) =&gt; &#123; return &#123; chatLog: chatLog(state.chatLog, action), statusMessage: statusMessage(state.statusMessage, action), userName: userName(state.userName, action) &#125;&#125;; 上面代码中，Reducer 函数被拆成了三个小函数，每一个负责生成对应的属性。 这样一拆，Reducer 就易读易写多了。而且，这种拆分与 React 应用的结构相吻合：一个 React 根组件由很多子组件构成。这就是说，子组件与子 Reducer 完全可以对应。 Redux 提供了一个combineReducers方法，用于 Reducer 的拆分。你只要定义各个子 Reducer 函数，然后用这个方法，将它们合成一个大的 Reducer。 123456789import &#123; combineReducers &#125; from 'redux';const chatReducer = combineReducers(&#123; chatLog, statusMessage, userName&#125;)export default todoApp; 上面的代码通过combineReducers方法将三个子 Reducer 合并成一个大的函数。 这种写法有一个前提，就是 State 的属性名必须与子 Reducer 同名。如果不同名，就要采用下面的写法。 1234567891011121314const reducer = combineReducers(&#123; a: doSomethingWithA, b: processB, c: c&#125;)// 等同于function reducer(state = &#123;&#125;, action) &#123; return &#123; a: doSomethingWithA(state.a, action), b: processB(state.b, action), c: c(state.c, action) &#125;&#125; 总之，combineReducers()做的就是产生一个整体的 Reducer 函数。该函数根据 State 的 key 去执行相应的子 Reducer，并将返回结果合并成一个大的 State 对象。 计数器下面我们来看一个最简单的实例。 12345678910111213const Counter = (&#123; value &#125;) =&gt; ( &lt;h1&gt;&#123;value&#125;&lt;/h1&gt;);const render = () =&gt; &#123; ReactDOM.render( &lt;Counter value=&#123;store.getState()&#125;/&gt;, document.getElementById('root') );&#125;;store.subscribe(render);render 上面是一个简单的计数器，唯一的作用就是把参数value的值，显示在网页上。Store 的监听函数设置为render，每次 State 的变化都会导致网页重新渲染。 下面加入一点变化，为Counter添加递增和递减的 Action。 12345678910111213141516171819202122232425262728293031const Counter = (&#123; value, onIncrement, onDecrement &#125;) =&gt; ( &lt;div&gt; &lt;h1&gt;&#123;value&#125;&lt;/h1&gt; &lt;button onClick=&#123;onIncrement&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;onDecrement&#125;&gt;-&lt;/button&gt; &lt;/div&gt;);const reducer = (state = 0, action) =&gt; &#123; switch (action.type) &#123; case 'INCREMENT': return state + 1; case 'DECREMENT': return state - 1; default: return state; &#125;&#125;;const store = createStore(reducer);const render = () =&gt; &#123; ReactDOM.render( &lt;Counter value=&#123;store.getState()&#125; onIncrement=&#123;() =&gt; store.dispatch(&#123;type: 'INCREMENT'&#125;)&#125; onDecrement=&#123;() =&gt; store.dispatch(&#123;type: 'DECREMENT'&#125;)&#125; /&gt;, document.getElementById('root') );&#125;;render();store.subscribe(render);","categories":[],"tags":[]},{"title":"React Hook","slug":"React Hook","date":"2020-09-15T12:19:32.697Z","updated":"2020-09-16T06:52:59.327Z","comments":true,"path":"2020/09/15/React Hook/","link":"","permalink":"http://yoursite.com/2020/09/15/React%20Hook/","excerpt":"","text":"React Hook📌 State Hook“Hook是react 16.8的新增特性。它可以让你在不编写class的情况下使用state。”这是React官网 对Hook最直接的解释。不使用class而是普通的函数去封装组件或者页面。 123456789101112131415import React, &#123; useState &#125; from 'react';function Example() &#123; // 声明一个新的叫做 “count” 的 state 变量 const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 这里我们引入并解构出useState方法来声明一个Hook当中的state变量。 const [count, setCount] = useState(0);这一个语句中useState的唯一参数为声明的state的初始值，例如这里的count为一个数字，并且初始值为0。setCount则像setState方法一样去改变state的值。 useState 方法的返回值是什么？ 返回值为：当前 state 以及更新 state 的函数。这就是我们写 const [count, setCount] = useState() 的原因。这与 class 里面 this.state.count 和 this.setState 类似，唯一区别就是你需要成对的获取它们。 下面展示同一个class封装的组件。 12345678910111213141516171819202122class Example extends React.Component&#123; constructor()&#123; super(); this.state = &#123; count: 0 &#125; &#125; click() &#123; const &#123;count&#125; = this.state this.setState(&#123; count: count + 1 &#125;); &#125; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;this.click.bind(this)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ); &#125; 大体来说两者可以完成同一个功能就是记下按钮被点击的次数。我们可以明显观察到hook的使用变量的改变和显示都比class要简单很多。 声明多个state变量1234567function ExampleWithManyStates() &#123; // 声明多个 state 变量！ const [age, setAge] = useState(42); const [fruit, setFruit] = useState('banana'); const [todos, setTodos] = useState([&#123; text: 'Learn Hooks' &#125;]); // ...&#125; 那么，什么是 Hook?Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。Hook 不能在 class 组件中使用 —— 这使得你不使用 class 也能使用 React。 React 内置了一些像 useState 这样的 Hook。你也可以创建你自己的 Hook 来复用不同组件之间的状态逻辑。我们会先介绍这些内置的 Hook。 ⚡️ Effect Hook你之前可能已经在 React 组件中执行过数据获取、订阅或者手动修改过 DOM。我们统一把这些操作称为“副作用”，或者简称为“作用”。 useEffect 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 具有相同的用途，只不过被合并成了一个 API。 1234567891011121314151617181920import React, &#123; useState, useEffect &#125; from 'react';function Example() &#123; const [count, setCount] = useState(0); // 相当于 componentDidMount 和 componentDidUpdate: useEffect(() =&gt; &#123; // 使用浏览器的 API 更新页面标题 document.title = `You clicked $&#123;count&#125; times`; &#125;); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 12345678910111213141516171819202122232425262728class Example extends React.Component&#123; constructor()&#123; super(); this.state = &#123; count: 0 &#125; &#125; componentDidMount()&#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125; componentDidUpdate()&#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125; click() &#123; const &#123;count&#125; = this.state this.setState(&#123; count: count + 1 &#125;); &#125; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;this.click.bind(this)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ); &#125; 当你调用 useEffect 时，就是在告诉 React 在完成对 DOM 的更改后运行你的“副作用”函数。由于副作用函数是在组件内声明的，所以它们可以访问到组件的 props 和 state。默认情况下，React 会在每次渲染后调用副作用函数 —— 包括第一次渲染的时候。(useEffect会在每一次页面渲染时调用。) 副作用函数还可以通过返回一个函数来指定如何“清除”副作用。例如，在下面的组件中使用副作用函数来订阅好友的在线状态，并通过取消订阅来进行清除操作： 123456789101112131415161718192021import React, &#123; useState, useEffect &#125; from 'react';function FriendStatus(props) &#123; const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;; &#125;); if (isOnline === null) &#123; return 'Loading...'; &#125; return isOnline ? 'Online' : 'Offline';&#125; 在这个示例中，React 会在组件销毁时取消对 ChatAPI 的订阅，然后在后续渲染时重新执行副作用函数。 12345678....componentDidMount()&#123; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);&#125;componentWillUnmount()&#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);&#125;.... 通过跳过 Effect 进行性能优化在某些情况下，每次渲染后都执行清理或者执行 effect 可能会导致性能问题。在 class 组件中，我们可以通过在 componentDidUpdate 中添加对 prevProps 或 prevState 的比较逻辑解决： 12345componentDidUpdate(prevProps, prevState) &#123; if (prevState.count !== this.state.count) &#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125;&#125; 这是很常见的需求，所以它被内置到了 useEffect 的 Hook API 中。如果某些特定值在两次重渲染之间没有发生变化，你可以通知 React 跳过对 effect 的调用，只要传递数组作为 useEffect 的第二个可选参数即可： 123useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`;&#125;, [count]); // 仅在 count 更改时更新 上面这个示例中，我们传入 [count] 作为第二个参数。这个参数是什么作用呢？如果 count 的值是 5，而且我们的组件重渲染的时候 count 还是等于 5，React 将对前一次渲染的 [5] 和后一次渲染的 [5] 进行比较。因为数组中的所有元素都是相等的(5 === 5)，React 会跳过这个 effect，这就实现了性能的优化。 当渲染时，如果 count 的值更新成了 6，React 将会把前一次渲染时的数组 [5] 和这次渲染的数组 [6] 中的元素进行对比。这次因为 5 !== 6，React 就会再次调用 effect。如果数组中有多个元素，即使只有一个元素发生变化，React 也会执行 effect。 对于有清除操作的 effect 同样适用： 12345678910useEffect(() =&gt; &#123; function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;;&#125;, [props.friend.id]); // 仅在 props.friend.id 发生变化时，重新订阅 未来版本，可能会在构建时自动添加第二个参数。 ✌️ Hook 使用规则Hook 就是 JavaScript 函数，但是使用它们会有两个额外的规则： 只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用。 只能在 React 的函数组件中调用 Hook。不要在其他 JavaScript 函数中调用。（还有一个地方可以调用 Hook —— 就是自定义的 Hook 中，我们稍后会学习到。） React 的函数组件是这样的： 1234const Example = (props) =&gt; &#123; // 你可以在这使用 Hook return &lt;div /&gt;;&#125; 或是这样： 1234function Example(props) &#123; // 你可以在这使用 Hook return &lt;div /&gt;;&#125; 你之前可能把它们叫做“无状态组件”。但现在我们为它们引入了使用 React state 的能力，所以我们更喜欢叫它”函数组件”。 Hook 在 class 内部是不起作用的。但你可以使用它们来取代 class 。 💡 自定义 Hook前面，我们介绍了一个叫 FriendStatus 的组件，它通过调用 useState 和 useEffect 的 Hook 来订阅一个好友的在线状态。假设我们想在另一个组件里重用这个订阅逻辑。 首先，我们把这个逻辑抽取到一个叫做 useFriendStatus 的自定义 Hook 里： 123456789101112131415161718import React, &#123; useState, useEffect &#125; from 'react';function useFriendStatus(friendID) &#123; const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange); &#125;; &#125;); return isOnline;&#125; 它将 friendID 作为参数，并返回该好友是否在线： 现在我们可以在两个组件中使用它： 1234567891011121314151617function FriendStatus(props) &#123; const isOnline = useFriendStatus(props.friend.id); if (isOnline === null) &#123; return 'Loading...'; &#125; return isOnline ? 'Online' : 'Offline';&#125;function FriendListItem(props) &#123; const isOnline = useFriendStatus(props.friend.id); return ( &lt;li style=&#123;&#123; color: isOnline ? 'green' : 'black' &#125;&#125;&gt; &#123;props.friend.name&#125; &lt;/li&gt; );&#125; 每个组件间的 state 是完全独立的。Hook 是一种复用状态逻辑的方式，它不复用 state 本身。事实上 Hook 的每次调用都有一个完全独立的 state —— 因此你可以在单个组件中多次调用同一个自定义 Hook。 自定义 Hook 更像是一种约定而不是功能。如果函数的名字以 “use” 开头并调用其他 Hook，我们就说这是一个自定义 Hook。","categories":[],"tags":[]},{"title":"JS Chapter 7","slug":"JS Chapter 7","date":"2020-06-30T14:02:26.057Z","updated":"2020-10-24T15:55:27.682Z","comments":true,"path":"2020/06/30/JS Chapter 7/","link":"","permalink":"http://yoursite.com/2020/06/30/JS%20Chapter%207/","excerpt":"","text":"Object orientation with prototypes虽然在之后avascript或者其一些框架的使用中，原型和原型链的概念很少被提到。但是原型作为JavaScript的基本的重要概念之一，也是需要被我们掌握的。 原型的概念书上给出的概念 A prototype is an object to which the search for a particular property can be delegated to. 首先最简单的缩句理解prototype就是一个对象，对象有一些特殊的属性。 Understanding protototypes我们可以先创造一个对象，对象里面包含一些字面对象得标记 12345let obj = &#123; prop1: 1, prop2: function()&#123;&#125;, prop3: &#123;&#125;&#125; 我们也可以进行一些修改删除操作,也可以添加一个完全新的属性： 1234obj.prop1 = 1;obj.prop1 = [];delete obj.prop2;obj.prop4 = \"Hello\"; 最后object的内容是这样的： 12345&#123; prop1:[], prop3:&#123;&#125;, prop4:\"Hello\"&#125;; 当在开发软件时，我们会希望减少代码的冗余量，尽可能的去重复利用一些代码，其中我们可以利用Javascript中继承的特性。 123456789101112const yoshi = &#123;skulk: true&#125;;const hattori = &#123;sneak: true&#125;;const kuma = &#123;creep: true&#125;;assert(\"skulk\" in yoshi, \"Yoshi can skulk\");assert(!(\"sneak\" in yoshi), \"Yoshi cannot sneak\");assert(!(\"creep\" in yoshi), \"Yoshi cannot creep\");Object.setPrototypeOf(yoshi, hattori);//把hattori设为yoshi的原型assert(\"sneak\" in yoshi, \"Yoshi can now sneak\");assert(!(\"creep\" in hattori), \"Hattori cannot creep\");Object.setPrototypeOf(hattori, kuma);//把kuma设为hattori的原型assert(\"creep\" in yoshi, \"Hattori can now creep\");assert(\"creep\" in hattori, \"Yoshi can also creep\"); 画一下这个一条原型链。[[prototype]] Object construction and prototypes我们首先使用JavaScript当中的new关键字来完成原型链的构成 123456789function Ninja()&#123; Ninja.prototype.swingSword = function()&#123; return true; &#125;&#125;const ninja1 = Ninja();assert(ninja1 === undefined,\"No instance of Ninja created.\");const ninja2 = new Ninja();assert(ninja2 &amp;&amp; ninja2.swingSword &amp;&amp; ninja2.swingSword(),\"Instance exists and method is callable.\"); Ninja这个函数对象当中我们创建了一个函数在他的原型当中，这个原型对象当中有constructor指向他自己（Ninja）和一个swingSword函数。当我们使用new关键字时，其实一共有四个步骤： new了之后，在内存中申请一块空闲的空间，存储创建的新的对象。 在函数最顶端有一个理论上的空对象即this：把this设置为当前的对象。 执行构造函数把this对象中的数据填满：设置对象的属性和方法的值。 最后一步有一个隐式的return this; 把this这个对象返回。 instance properties这里我们用this参数来完成Ninja函数 1234567891011function Ninja()&#123; this.swung = false; this.swingSword = function()&#123; return !this.swung; &#125;;&#125;Ninja.prototype.swingSword = function()&#123; return this.swung;&#125;;const ninja = new Ninja();assert(ninja.swingSword(), \"Called the instance method, not the prototype method.\"); 上面提到的new关键字的实际四个步骤，这里的ninja其实就是指向ninja本身的this对象。ninja本身会有swung和swingSword属性，和他存在一个原型指向ninja的原型。ninja原型之中也会有一个swingSword方法，但是我们在调用swingSword方法可以看到返回的值为true而不是false本身，因为当我们调用swingSword时，ninja会在其本身去寻找有没有这个swingSword方法，当swingSword不存在时，才再开始在其原型中寻找函数。比如，我们会在一些数组对象Array或者字符串对象String使用一些方法时，sort，map等，我们并没有直接在这些对象之中定义，而是他们继承了Array和String的原型，而去他的原型当中寻找这些方法。 12345Ninja.prototype = &#123; pierce: function()&#123; return true; &#125;&#125; 当执行到该句时，Ninja的原型会指向新的这个对象包含pierce函数。 12345function Ninja()&#123;&#125;const ninja = new Ninja();assert(typeof ninja === \"object\", \"The type of the instance is object.\");assert(ninja instanceof Ninja, \"instanceof identifies the constructor.\");assert(ninja.constructor === Ninja, \"The ninja object was created by the Ninja function\"); 从这几行代码可以得出ninja是一个的对象，也是Ninja得一个实例，而ninja的原型里面的constructor指向的Ninja 12345function Ninja()&#123;&#125;const ninja = new Ninja();const ninja2 = new ninja.constructor();assert(ninja2 instanceof Ninja, \"It's a Ninja!\");assert(ninja !== ninja2,\"But not the same Ninja\"); 我们通过ninja.constructor来构建一个新的对象，而ninja2也是一个Ninja的实例。 Achieving inheritance123456789function Person()&#123;&#125;;Person.prototype.dance = function()&#123;&#125;;function Ninja()&#123;&#125;;Ninja.prototype = new Person();const ninja = new Ninja();assert(ninja instanceof Ninja, \"ninja receives functionality from the Ninja prototype\");assert(ninja instanceof Person, \"...and the Person prototype\");assert(ninja instanceof Object, \"...and the Object prototype\");assert(typeof ninja.dance === \"function\",\"..and can dance!\") 这里是一个原型链的继承，ninja是Ninja的实例也是Person的实例也是一个对象实例。 Using JavaScript “classes” in ES6我们实际在开发过程中，我们会经常使用ES6中的新特性classes。 1234567891011121314151617class Ninja&#123; constructor(name)&#123; this.name = name; walk()&#123; return true; &#125; &#125;&#125;swingSword()&#123; return true;&#125;// ninja.prototype.swingSword = ()&#123; return true&#125;;static dance()&#123; return false;&#125;var ninja = new Ninja(\"Yoshi\");assert(ninja.swingSword(),\"and he can swing a sword\"); 1234567891011121314151617class Person&#123; constructor(name)&#123; this.name = name; &#125; dance()&#123; return true; &#125;&#125;class Ninja extends Person&#123; constructor(name,weapon)&#123; super(name); this.weapon = weapon; &#125; wieldWeapon()&#123; return true; &#125;&#125;","categories":[],"tags":[]},{"title":"JS Chapter 6","slug":"JS Chapter 6","date":"2020-06-10T07:20:54.493Z","updated":"2020-07-11T08:40:06.141Z","comments":true,"path":"2020/06/10/JS Chapter 6/","link":"","permalink":"http://yoursite.com/2020/06/10/JS%20Chapter%206/","excerpt":"","text":"Generator先看三段代码 12345678try&#123; var ninjas = syncGetJSON(\"ninjas.json\"); var missions = syncGetJSON(ninjas[0].missionsUrl); var missionDetails = syncGetJSON(mission[0].detailsUrl); //Study the mission description&#125;catch(e)&#123; //Oh no, we weren't able to get the mission details&#125; 12345678910111213141516171819getJSON(\"ninjas.json\",function(err,ninjas)&#123; if(err)&#123; console.log(\"Error fetching list of ninjas\",err); return; &#125; getJSON(ninjas[0].missionsUrl,function(err,missions)&#123; if(err)&#123; console.log(\"Error locating ninja missions\",err); return; &#125; getJSON(mission[0].detailsUrl,function(err,missionDetails)&#123; if(err)&#123; console.log(\"Error locating mission details\",err); return; &#125; //Study the intel plan &#125;); &#125;);&#125;); 12345678910async(function*()&#123; try&#123; var ninjas = syncGetJSON(\"ninjas.json\"); var missions = syncGetJSON(ninjas[0].missionsUrl); var missionDetails = syncGetJSON(mission[0].detailsUrl); //Study the mission description&#125;catch(e)&#123; //Oh no, we weren't able to get the mission details &#125;&#125;) 第一段代码问题：从服务器获得数据是一个长期运行的操作，因为JavaScript是依赖单线程模式，我们会锁住我们的UI直到这整个代码运行结束。这导致了无法反应的应用和使用户失望。 1234567891011function* WeaponGenerator()&#123; yield \"Katana\"; yield \"Wakizashi\";&#125;const weaponsIterator = WeaponGenerator();const result1 = weaponsIterator.next();assert(typeof result1 === \"object\" &amp;&amp; result1.value === \"katana\" &amp;&amp; !result1.done,\"Katana recevied!\");const result2 = weaponsIterator.next();assert(typeof result2 === \"object\" &amp;&amp; result2.value === \"wakizashi\" &amp;&amp; !result2.done,\"wakizashi recevied!\");const result3 = weaponsIterator.next();assert(typeof result3 === \"object\" &amp;&amp; result3.value === undefined &amp;&amp; result3.done,\"There are no more results!\"); WeaponGenerator是构造器，weaponsIterator.next()会返回一个对象，如果传入值则yield被替换为改值，对象有两个属性value和done，当第三次返回对象时done的值为true。 123456789101112function* WarriorGenerator()&#123; yield \"Katana\"; yield* NinjaGenerator(); yield \"Wakizashi\";&#125;function* NinjaGenerator()&#123; yield \"Hattori\"; yield \"Yoshi\";&#125;for(let warrior of WarriorGenerator())&#123; assert(warrior !== null, warrior);&#125; 类似于链表的结构。 12345678910111213function* NinjaGenerator()&#123; try&#123; yield \"Hattori\"; fail(\"The expected exception didn't occur\"); &#125; catch(e)&#123; assert(e === \"Catch this!\",\"Aha! We caught an exception\"); &#125;&#125;const ninjaIterator = NinjaGenrator();const result1 = ninjaIterator().next();assert(result1.value === \"Hattori\", \"We got Hattori\");ninjaIterator.throw(\"Catch this!\"); 这里是说有throw这个方法 12345678910function* NinjaGenerator(action)&#123; const imposter = yield (\"Hattori\" + action); assert(imposter === \"Hanzo\",\"The generator has been infiltrated\"); yield (\"Yoshi (\" + imposter + \") \" + action);&#125;const ninjaIterator = NinjaGenerator(\"skulk\");const result1 = ninjaIterator.next();assert(result1.value === \"Hattori skulk\", \"Hattori is skulking\");const result2 = ninjaIterator.next(\"Hanzo\");assert(result2.value === \"Yoshi (Hanzo) skulk\", \"We have an imposter!\"); Promise来搬一个别人的博客https://www.jianshu.com/p/1b63a13c2701","categories":[],"tags":[]},{"title":"JS Chapter 5","slug":"JS Chapter 5","date":"2020-06-02T08:54:20.269Z","updated":"2020-07-11T08:26:24.129Z","comments":true,"path":"2020/06/02/JS Chapter 5/","link":"","permalink":"http://yoursite.com/2020/06/02/JS%20Chapter%205/","excerpt":"","text":"Closure一、概念A closure is the combination of a function and the lexical environment within which that function was declared.二、Lexical Environment（词法环境）​ 这个链接详细介绍了什么是词法环境。https://segmentfault.com/a/1190000015172796 三、区分的两个概念​ 一开始看闭包这个部分的时候一直没有搞懂为什么不能在外部变量访问内部变量的问题，其实是我把两个概念给搞混了。 ​ 为什么不能访问内部变量这个问题很简单，就是局部变量的生存周期与函数的调用时一样，一旦函数调用完毕，这些局部变量就不在存在了。 1234let outter = 1;function ()&#123; let inner = 2;&#125; ​ 而我一开始困惑了很久，就是为什么a.b，这样的就可以访问呢？ 那我搞混的两个概念就是局部变量和对象的属性或者方法。 ​ 局部变量就是上面所说的，那么对象的属性或方法来举例子： 123let a = new Object();//a是一个对象a.b = 2;alert(a.b); 四、小桃花穿越故事先举一个简单的例子 123456789 function t1()&#123; var age = 20; function t2()&#123; alert(age); &#125; return t2; &#125;var tmp = t1();tmp();//----------------------------20 ​ 大部分的语言，t1被调用执行，则申请内存，并把其局部变量age, push入栈,t1函数执行完毕，内部的局部变量，随着函数的退出而销毁.因此age = 20 的局部变量已经消失了;​ 但是在js中，age = 20 这个变量，却被t2捕捉，即使t1执行完毕，通过t2仍然可以访问t2依然可以访问该变量。这也是实现上面的访问局部变量。 ​ 再来看一下，这个情形的过程，引入js闭包的知识点。​ 在js中，t1执行过程中又生成了t2，而作用域上来说，t2能访问到age = 20，于是age = 20 不会消失，而是与返回的t1函数形成了一个环境包，这个包是t2的(把其周围的变量环境形成了封闭的环境包 共同返回)，即使t1执行完毕，通过t2仍然可以访问t1依然可以访问该变量，这就是闭包!!!小桃花穿越 12345678910111213function closure()&#123; var sister = '大桃花'; var me = function()&#123; alert(sister); &#125; return me;&#125;function place()&#123; var sister = '清朝大福晋'; var girl = closure(); girl();&#125;place();//------------------------------大桃花 五、闭包计数器闭包来维护一个别人污染不到的变量 做计数器 123456789var fn = (function()&#123; var cnt = 0; return function()&#123; return ++cnt; &#125; &#125;)();alert(fn());//------------------1alert(fn());//------------------2alert(fn());//------------------3 这里放一个经典的案例就也不搬过来了。https://blog.csdn.net/Tacks/article/details/78704922 Stack Heap一开始了解的stack栈就是上进上出 先入后出这样子，也不想搬运别人博客了就放一个链接https://www.jianshu.com/p/90808ed34b86 heap堆之前了解并不多来搬运一下博客链接吧。https://blog.csdn.net/qian3223/article/details/82424757 Types of JavaScript variables​ var关键字是JavaScript创造开始时的一部分，然而let和const关键字的在ES6版本中更新的产物。 变量易变性（variables mutability）​ 如果我们按照变量区分他们，const则与剩余的两个有很大区别。所有以const声明的变量都是不可改变的。那么以剩下两个关键字声明的变量都可以反复改变很多次的值。 12345678910111213141516const firstConst = \"samurai\";assert(firstConst === \"samurai\",\"firstConst is a samruai\");try&#123; firstConst = \"ninja\"; fail(\"Shouldn't be here\");&#125;catch(e)&#123; pass(\"An exception has occurred\");&#125;assert(firstConst === \"samurai\",\"firstCount is still a samuerai\");const secondConst = &#123;&#125;;secondConst.weapon = \"wakizashi\";assert(secondConst.weapon === \"wakizashi\",\"We can add new properties\");const thirdConst = [];assert(thirdConst.length === 0, \"No items in our array\");thirdConst.push(\"Yoshi\");assert(thirdConst.length === 1, \"The array has changed\"); ​ 首先，我们声明且初始化了firstConst变量为samurai，我们继续给他赋一个全新的值ninja，因为firstConst是一个常量，所以我们ninja赋值失败。所以，JavaScript的引擎会丢出一个exception事件，我们用到fail和pass方法（这两者和assert类似）来测试exception事件是否发生了。如果exception发生了，catch语句会被激活，然后pass语句也就被执行了。反之，fail语句就会被执行。 ​ 再而，我们声明一个空对象secondConst和空数组thirdCosnt。我们已经知道了不能改变常量的值，但是我们可以给它增添属性。 变量声明关键字和词法作用域​ 不同关键字声明有不同的作用域，这一部分比较简单，总的来说，就是var无论在哪儿声明都是以最近的函数作用域或者全局作用域，而const和let可以为块作用域。 123456function()&#123; var local = ''; for(var i = 0;i &lt; 10;i++); assert(i == 10,\"i is ten\");&#125;assert(typeof i === \"undefined\",\"We cannot see function variables outside of a function\"); 在词法作用域中的寄存（状态提升）​ 在JavaScript中，代码的执行分为两个阶段。第一阶段为JavaScript引擎会把所有声明变量和函数声明在当前的词法环境内提前。第二阶段为执行阶段，由函数调用执行或者赋值时开始。其中，var function 只是对变量声明，没有赋值操作。","categories":[],"tags":[]},{"title":"Sass","slug":"Sass","date":"2020-04-02T05:26:15.024Z","updated":"2020-04-02T06:25:38.162Z","comments":true,"path":"2020/04/02/Sass/","link":"","permalink":"http://yoursite.com/2020/04/02/Sass/","excerpt":"","text":"Sass学习​ 因为在Taro项目中有用到Sass，但是当时并没有学习所以就分开来写。 一、安装因为Taro项目初始化的时候会自行安装，只要选择Sass就行了。所以这里给出官方链接。https://sass.bootcss.com/install 二、变量变量是存储信息并在将来重复利用的一种方式，在整个样式表中都可访问。 你可以在变量中存储颜色、字体 或任何 CSS 值，并在将来重复利用。Sass 使用 $ 符号 作为变量的标志。 1234567$font-stack: Helvetica, sans-serif;$primary-color: #333;body &#123; font: 100% $font-stack; color: $primary-color;&#125; 1234body &#123; font: 100% Helvetica, sans-serif; color: #333;&#125; 三、嵌套​ 在编写 HTML 时，它有一个清晰的嵌套和可视化层次结构。 而 CSS 则没有。 ​ Sass 允许嵌套 CSS 选择器，嵌套方式 与 HTML 的视觉层次结构相同。请注意，过度嵌套的规则 将导致过度限定的 CSS，这些 CSS 可能很难维护，并且 通常被认为是不好的做法。 ​ 理解了这一点，下面就来看一个典型的网站导航的样式 示例： 123456789101112131415nav &#123; ul &#123; margin: 0; padding: 0; list-style: none; &#125; li &#123; display: inline-block; &#125; a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125;&#125; 12345678910111213nav ul &#123; margin: 0; padding: 0; list-style: none;&#125;nav li &#123; display: inline-block;&#125;nav a &#123; display: block; padding: 6px 12px; text-decoration: none;&#125; 四、片段创建部分Sass文件，其中包含一些CSS片段 ，可以将其包含在其他Sass文件中。这是模块化CSS并帮助使事情易于维护的好方法。部分文件是一个Sass文件，名称前带有一个下划线。可以将其命名为_partial.scss。下划线让Sass知道该文件只是部分文件，不应将其生成为CSS文件。Sass局部函数与@use 规则一起使用。 五、模块不必将所有Sass都写在一个文件中。您可以根据需要将其拆分@use。该规则将另一个Sass文件作为模块加载，这意味着您可以在Sass文件中使用基于文件名的命名空间引用其变量，mixins和函数。使用文件还将在编译输出中包含它生成的CSS！ 12345678// _base.scss$font-stack: Helvetica, sans-serif;$primary-color: #333;body &#123; font: 100% $font-stack; color: $primary-color;&#125; 1234567// styles.scss@use 'base';.inverse &#123; background-color: base.$primary-color; color: white;&#125; 123456789body &#123; font: 100% Helvetica, sans-serif; color: #333;&#125;.inverse &#123; background-color: #333; color: white;&#125; 六、混合​ CSS中的某些内容编写起来有些繁琐，尤其是使用CSS3 和存在的许多供应商前缀时。使用mixin，您可以创建要在整个站点中重复使用的CSS声明组 。您甚至可以传入值以使混入更加灵活。mixin的一个很好的用法是用于供应商前缀。这是的示例 transform。 123456@mixin transform($property) &#123; -webkit-transform: $property; -ms-transform: $property; transform: $property;&#125;.box &#123; @include transform(rotate(30deg)); &#125; 12345.box &#123; -webkit-transform: rotate(30deg); -ms-transform: rotate(30deg); transform: rotate(30deg);&#125; 要创建一个mixin，请使用@mixin指令并为其命名。我们将其命名为mixin transform。我们还在$property括号内使用了变量 ，因此我们可以传递任何所需的变换。创建混入之后，您可以将其用作CSS 声明@include，以混入的名称开头。 七、扩展继承​ 这是Sass最有用的功能之一。使用@extend使您可以将一组CSS属性从一个选择器共享到另一个选择器。它有助于使Sass保持非常干燥。在我们的示例中，我们将使用扩展，占位符类一起使用的另一个功能，为错误，警告和成功创建一系列简单的消息传递。占位符类是一种特殊的类，仅在扩展时才打印，并且可以帮助保持编译后的CSS整洁。 12345678910111213141516171819202122232425262728293031/* This CSS will print because %message-shared is extended. */%message-shared &#123; border: 1px solid #ccc; padding: 10px; color: #333;&#125;// This CSS won't print because %equal-heights is never extended.%equal-heights &#123; display: flex; flex-wrap: wrap;&#125;.message &#123; @extend %message-shared;&#125;.success &#123; @extend %message-shared; border-color: green;&#125;.error &#123; @extend %message-shared; border-color: red;&#125;.warning &#123; @extend %message-shared; border-color: yellow;&#125; 123456789101112131415161718/* This CSS will print because %message-shared is extended. */.message, .success, .error, .warning &#123; border: 1px solid #ccc; padding: 10px; color: #333;&#125;.success &#123; border-color: green;&#125;.error &#123; border-color: red;&#125;.warning &#123; border-color: yellow;&#125; ​ 上面的代码的作用是告诉.message，.success，.error，和.warning做人一样%message-shared。这意味着任何地方%message-shared显示来，.message，.success，.error，和 .warning也会这样做的。魔术发生在生成的CSS中，其中每个类将获得与相同的CSS属性%message-shared。这有助于您避免在HTML 元素上编写多个类名。 ​ 除了Sass中的占位符类之外，您还可以扩展最简单的CSS选择器，但是使用占位符是确保不扩展嵌套在样式中其他位置的类的最简单方法，这会导致CSS中意外的选择器 。 ​ 请注意，不会生成CSS in %equal-heights，因为%equal-heights它不会被扩展。 八、操作符​ 在 CSS 中经常需要做数学计算。Sass 支持一些标准的 数学运算符，例如 +、-、*、/ 和 %。在下面的例子中，我们 将做一些简单的数学运算来计算出 aside &amp; article 的宽度。 12345678910111213.container &#123; width: 100%;&#125;article[role=\"main\"] &#123; float: left; width: 600px / 960px * 100%;&#125;aside[role=\"complementary\"] &#123; float: right; width: 300px / 960px * 100%;&#125;","categories":[],"tags":[]},{"title":"孤独星球--Taro框架总结","slug":"孤独星球--Taro框架总结","date":"2020-04-01T15:30:56.708Z","updated":"2020-04-01T17:02:39.079Z","comments":true,"path":"2020/04/01/孤独星球--Taro框架总结/","link":"","permalink":"http://yoursite.com/2020/04/01/%E5%AD%A4%E7%8B%AC%E6%98%9F%E7%90%83--Taro%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/","excerpt":"","text":"孤独星球–Taro框架总结​ 大一下学期用Taro框架写了QQ的小程序–孤独星球，项目链接在这里。https://github.com/The-Planet-of-Loneline/project ​ 项目分为白天和黑夜两个部分，白天是同组的刘安完成的，技术含量也比较高；黑夜和登录部分就是由我完成的。接下来就说一下Taro里面的一些细节。 一、项目结构​ 因为一开始没有去参照学姐学长做的客栈的框架，所以这个项目的框架比较乱，一些组件的页面的位置也存放的不正确。希望以后的项目能够把公共组件和私有组件分开，组件和页面分开以形成更明晰的结构。以下是参照木犀客栈的结构： 123456789101112131415--src --assets //存放图片 --png --svg --components //存放组件 --common //公用组件 --index //私有组件 --pages //页面 --index --index.jsx --service //Fech API --Fech.jsx --app.jsx //配置 --app.scss //样式 --index.html //接口 一般来说一个项目的结构就如上所示了。 二、Taro内置组件​ 刚刚开始写静态页面的时候使用错了组件，还是用的HTML的标签&lt;div&gt; &lt;span&gt;等。要注意以下代码的含义： 12import Taro, &#123; Component &#125; from '@tarojs/taro'import &#123; View, Text,Image &#125; from '@tarojs/components' ​ Taro里面有内置的组件使用，&lt;View&gt; &lt;Text&gt;等类似于HTML中的标签使用。要注意的是，HTML中使用的class选择器，class关键字要改变成classname，因为关键字的保留class类。 这里的import也是webpack的方法吧，引入你需要的组件例如黑夜的头部和底部： 12import Head from '../component/Head'import Footer from '../component/Footer' 一定要from正确的路径&#39;../&#39;是返回上一级目录，也可以返回多次。 三、Taro中的输入框​ Taro中的输入框也是Taro当中的内置组件也分为input和textarea，但是要大写&lt;Input /&gt; &lt;Textarea /&gt;，这里顺便提一下Taro里面所有组件开头都要大写。 ​ 输入框输入值的时候value要空，且还有监听事件函数onInput，onChange也可以。但是比较坑的事，onInput函数对于Input和Textarea不同。当时产品组给我提的要求是控制行数限制，这里也要说一下Textarea的特性，有换行的监听函数。但是由于onInput对于Textarea的value的改变不能显示于Textarea，而可以显示于Input。最后也是需求改成了字数限制。 12345678910&lt;Textarea className='write' value=&#123;Value&#125; onInput=&#123;this.handleInputChange.bind(this)&#125; onFocus=&#123;this.handleInput.bind(this)&#125;onBlur=&#123;this.handleback.bind(this)&#125; showConfirmBar=&#123;false&#125;maxlength=&#123;75&#125;autoFocus=&#123;true&#125;&gt;&lt;/Textarea&gt; ​ 组件的写法可以这样换行以更醒目的看见，太长不方便查看。但是一些View好像就不行。 四、API​ 写整个项目前最重要的就是沟通，和产品沟通和后端沟通。没有沟通好的后果就是白天好像重新写页面的结构。还好因为黑夜也不难，所以没有做好沟通也影响不大。其中我觉得比较重要的是分页这个部分。因为要考虑到页面的实际需求来看分页的形式和需不需要分页。参考swaggerUI是一个很重要的东西，一定要反复比对。 123456789101112131415onReachBottom()&#123; if (this.state.history.length % 5 == 0) &#123; this.setState(&#123; page: this.state.page + 1 &#125;, () =&gt; &#123; Fetch(`secret/history?page=$&#123;this.state.page&#125;`, &#123;&#125;, 'GET').then(res =&gt; &#123; this.setState(&#123; history: this.state.history.concat(res.history) &#125;) &#125;) &#125;) &#125;&#125; ​ 这里是一个后端的分页方法，需要的事我每一次请求时发送一个页面数字给后端，他再返回给我对应数字的内容。这种分页方法个人感觉比较适合网页，而不适合小程序去写。所以我加了限定条件只有显示内容为5个时候才会进行下一次的请求。 ​ API的路径一定要对，我举例困扰我很久的删除功能。 1234567891011121314handleDelete()&#123; Fetch(`secret/delete/:secret_id/?secretId=$&#123;this.props.Debunkid&#125;`, &#123;&#125;, 'DELETE').then(res =&gt; &#123; Taro.showToast(&#123; title: '删除成功', icon: 'none' &#125;) this.props.onCloseDelete() Taro.reLaunch(&#123; url:`/pages/Mine/Mine` &#125;) &#125;) &#125; ​ 这里因为我少了一个/导致我应该不能与后端连接，但是开发者工具可以我也就没有想太多。牢记！！ 五、QQ授权和分享​ QQ授权和分享是要过审核必须写的一个API，我们也是事后才写的。 1&lt;Button open-type='getUserInfo' className='login' onClick=&#123;this.power&#125;&gt;登录&lt;/Button&gt; 12345678910power () &#123; Taro.getSetting(&#123; success: (res) =&gt; &#123; this.setState(&#123; powered:res.authSetting['scope.userInfo']&#125;) if (res.authSetting['scope.userInfo']) &#123; this.onHandleLogin() &#125; &#125; &#125;) &#125; 123Taro.showShareMenu(&#123; showShareItems: ['qq', 'qzone', 'wechatFriends', 'wechatMoment'] &#125;) 第一二个代码块是处理授权的部分，第三个是分享。","categories":[],"tags":[]},{"title":"浏览器输入URL后发生了什么","slug":"浏览器输入URL后发生了什么","date":"2019-11-20T07:15:20.193Z","updated":"2019-12-08T01:13:08.716Z","comments":true,"path":"2019/11/20/浏览器输入URL后发生了什么/","link":"","permalink":"http://yoursite.com/2019/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/","excerpt":"","text":"当我们在浏览器的网址栏输入网址并回车后，一个网页页面就呈现在我们面前。我们有没有思考过浏览器时如何将一个内容丰富的页面给“变”出来的呢？ 基本步骤 浏览器的地址栏输入URL并按下回车。 浏览器查找当前URL是否存在缓存，并比较缓存是否过期。 DNS解析URL对应的IP。 根据IP建立TCP（三次握手）。 HTTP发出请求。 服务器处理请求，浏览器接受HTTP请求。 渲染页面，构建DOM树。 关闭TCP连接（四次挥手）。 URLURL的格式 protocol://hostname[:port]/path/[;parameters] [?query]#fragment protocal,协议头，比如http，https等 host，主机域名或IP地址 port，端口号一般为默认指所以隐藏起来 path，目录路径 query，查询参数 fragment，#后hash值，一般用来定位到某个位置 缓存浏览器会对你输入的网址进行判断，有缓存或无。有缓存则直接加载，无则向服务器发出请求。 DNS域名解析​ 我们知道在地址栏输入的域名并不是最后资源所在的真实位置，域名只是与IP地址的一个映射。网络服务器的IP地址那么多，我们不可能去记一串串的数字，因此域名就产生了，域名解析的过程实际是将域名还原为IP地址的过程。 首先浏览器先检查本地hosts文件是否有这个网址映射关系，如果有就调用这个IP地址映射，完成域名解析。 如果没找到则会查找本地DNS解析器缓存，如果查找到则返回。如果还是没有找到则会查找本地DNS服务器，如果查找到则返回。 ​ TCP链接拿到服务器IP地址则进行三次握手的连接。 客户端发送一个带有SYN标志的数据包给服务端，服务端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息，最后客户端再回传一个带ACK标志的数据包，代表握手结束，连接成功。 发送HTTP请求 与服务器建立了连接后，就可以向服务器发起请求了。这里我们先看下请求报文的结构（如下图）： 请求报文在浏览器中查看报文首部（以google浏览器为例）： ​ 请求行包括请求方法、URI、HTTP版本。首部字段传递重要信息，包括请求首部字段、通用首部字段和实体首部字段。我们可以从报文中看到发出的请求的具体信息。 请求报文的简要分析 服务器处理请求​ 服务器端收到请求后的由web服务器（准确说应该是http服务器）处理请求，诸如Apache、Ngnix、IIS等。web服务器解析用户请求，知道了需要调度哪些资源文件，再通过相应的这些资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过web服务器返回给浏览器客户端。 返回响应结果在HTTP里，有请求就会有响应，哪怕是错误信息。这里我们同样看下响应报文的组成结构： 响应报文 在响应结果中都会有个一个HTTP状态码，比如我们熟知的200、301、404、500等。通过这个状态码我们可以知道服务器端的处理是否正常，并能了解具体的错误。 状态码由3位数字和原因短语组成。根据首位数字，状态码可以分为五类： 1xx：指示信息–表示请求已接收，继续处理。 2xx：成功–表示请求已被成功接收、理解、接受。 3xx：重定向–要完成请求必须进行更进一步的操作。 4xx：客户端错误–请求有语法错误或请求无法实现。 5xx：服务器端错误–服务器未能实现合法的请求。 页面渲染前面有提到http交互，那么接下来就是浏览器获取到html，然后解析，渲染 解析HTML，构建DOM树 解析CSS，生成CSS规则树 合并DOM树和CSS规则，生成render树 布局render树（Layout/reflow），负责各元素尺寸、位置的计算 绘制render树（paint），绘制页面像素信息 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上 如下图： DOM tree CSSOM tree render tree 在浏览器还没接收到完整的 HTML 文件时，它就开始渲染页面了，在遇到外部链入的脚本标签或样式标签或图片时，会再次发送 HTTP 请求重复上述的步骤。在收到 CSS 文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完立刻显示在相应位置。在这一过程中可能会触发页面的重绘或重排。这里就涉及了两个重要概念：Reflow和Repaint。 Reflow，也称作Layout，中文叫回流，一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树，这个过程称为Reflow。 Repaint，中文重绘，意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就OK了，这个过程称为Repaint。 所以说Reflow的成本比Repaint的成本高得多的多。DOM树里的每个结点都会有reflow方法，一个结点的reflow很有可能导致子结点，甚至父点以及同级结点的reflow。 关闭TCP连接或继续保持连接通过四次挥手关闭连接(FIN ACK, ACK, FIN ACK, ACK)。 第一次挥手是浏览器发完数据后，发送FIN请求断开连接。 第二次挥手是服务器发送ACK表示同意，如果在这一次服务器也发送FIN请求断开连接似乎也没有不妥，但考虑到服务器可能还有数据要发送，所以服务器发送FIN应该放在第三次挥手中。 这样浏览器需要返回ACK表示同意，也就是第四次挥手","categories":[],"tags":[]},{"title":"学而页面总结","slug":"学而页面总结","date":"2019-11-06T06:30:16.775Z","updated":"2019-11-08T13:36:09.217Z","comments":true,"path":"2019/11/06/学而页面总结/","link":"","permalink":"http://yoursite.com/2019/11/06/%E5%AD%A6%E8%80%8C%E9%A1%B5%E9%9D%A2%E6%80%BB%E7%BB%93/","excerpt":"","text":"关于HTML和CSS的总结在这两周时间，我写了静态的学而网页并进行了一些修改。在学姐学长的帮助和指导之下，我对网页的一些整体布局有所了解，以下为一些自己在写学而时犯下的错误。HEADER PART1.布局方式不要混用（其实适用于很多地方），flex inline-block 和float最好不要混合使用。 2.尽量减少div的使用。学会思考span和div的使用情况。span作为行内元素，可以用来标记一些行内特殊的元素；div作为块元素，更好的区分出每一个区域。有时候会用很多个div，变成inline-block的样子是因为在行内中出现了不同的功能区。 3.消除间隙。由于行内元素都是有间隙的所以一般需要消除间隙，例如图片与搜索框之间。 4.搜索框的写法，一般是用一个大的div把input和图片包裹起来，设置div的border的颜色来展示边框。 5.实现:hover之后，要确保前后元素的大小一致，这样才美观。 MIDDLE PART1.整体布局，用一个div来使多个中间部分水平居中。 2.在整个页面中最好只采取一种布局方式。 3.position：sticky可以适用于更多的场合，也更符合如今的审美需求。 4.input的样式用CSS来改变 FOOTER PART1.注意字符间距 2.body的margin为0或者padding为0；","categories":[],"tags":[]},{"title":"自适应居中","slug":"自适应居中","date":"2019-11-02T08:35:02.165Z","updated":"2019-11-08T07:51:09.465Z","comments":true,"path":"2019/11/02/自适应居中/","link":"","permalink":"http://yoursite.com/2019/11/02/%E8%87%AA%E9%80%82%E5%BA%94%E5%B1%85%E4%B8%AD/","excerpt":"","text":"关于网页布局中的水平垂直居中一、首先来分享最简单的flex布局中如何居中12345.father&#123; display: flex; justify-content: center;/*水平居中*/ align-items: center;/*垂直居中*/&#125; ​ 这里father指的是夫元素的盒子，对父元素进行设置display: flex;其中的子元素就会变成项目，父元素本身就成为了flex容器。利用flex的一些特性就可以进行居中的布局。 ​ 关于更详细的flex布局，这里有一个链接：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool 二、”display:inline-block”中如何实现居中123456.father&#123; text-align: center;/*水平居中*/&#125;.son&#123; display:inline-block;&#125; ​ 当block变成inline-block时，多个div在一个父元素的容器中，margin: 0 auto；就不再有作用。目前我找到的方法只有在父元素中设置text-align: center;使这些div居中。百度中这么解释到，“我们的行内元素就相当于一行之内的文字了”，我也只能这么理解了。对于div中的文字，我们只能再使用text-align: start；之类的属性来使文字排版更理想化。 1234567891011121314.father&#123; width:auto; height:200px;&#125;.father:after&#123; display:inline-block; height:100%; font-size:0; content: \"\";&#125;.son&#123; display:inline-block; vertical-align: middle;/*垂直居中*/&#125; ​ 这一串css代码是用来inline-block当中的垂直居中问题，可以用于head当中，因为大多时候head定宽，用一个伪元素设置其高度为100%时，将父元素撑开，子元素就垂直居中啦！也适用于多行文字！ 当然如果head之中只有一行文字，在父元素中设置height与line-height相等时，也可以垂直居中，只是会出现一些小问题。比如只是文字居中而div没有居中。（如果div高和head高不相等）三、“display：block”一个block的居中123.son&#123; margin: 0 auto;&#125; ​ 这一串代码十分简洁，十分容易记住，但是一定要找到使用场合。在一个父元素只有一个子元素时，此代码可以时该元素自适应的居中，比较常用于head套用，page整体布局中。 1234.father&#123; height:100px; line-height:100px;&#125; ​ 不多说了，注意只能用于单行文字。会使子元素高度变大。 四、“display: table”的居中1234567.father&#123; display:table;&#125;.son&#123; display:table-cell; vertical-align: middle;&#125; ​ 这种方法适用性不强，因为大多数display属性为block,inlin-block或者flex。再次使用display时可能会改变一些属性。 五、定位123456789101112131415.father&#123; width: 500px; height: 300px; position: relative;&#125;.son&#123; width: 100px; height: 100px; position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto;&#125; ​ 该方法用于son宽高已知！ 1234567891011.father&#123; width: 500px; height: 300px; position: relative;&#125;.son&#123; position: absolute; left: 50%; top: 50%; transform: translateX(-50%) translateY(-50%);&#125; ​ 该方法用于son宽高未知！ 总的来说自适应居中的方法就这些了，如果想看到更多的居中方式可以点击这里访问李雪莲学姐做的总结！！ https://lilixuelian.github.io/2019/05/22/center/","categories":[],"tags":[]}]}