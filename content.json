{"meta":{"title":"HCL's Blog","subtitle":"Recording the study progress","description":"Fighting!","author":"HCLacids","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"this pointer","slug":"this pointer","date":"2021-11-23T02:09:31.337Z","updated":"2021-11-23T02:09:31.337Z","comments":true,"path":"2021/11/23/this pointer/","link":"","permalink":"http://yoursite.com/2021/11/23/this%20pointer/","excerpt":"","text":"今天主要是总结一下看的书的第一小节，主要是关于this指针的指向问题和new关键字的实现与bind的实现的知识点。this指针this指针总的来说用一句话总结就是谁调用就指向谁。但是还是不太全面，所以我们将分以下几个部分来总结：1. 显示绑定 2. 隐式绑定 3. new关键字 4. 箭头函数 5. 混合的优先级 显示绑定显示绑定的函数有bind，call和apply。他们之间没有什么大的区别，区别在于之后的传参的形式和返回的值。 call和apply回立刻执行函数，而bind是返回绑定this指向的函数。 123456const target = &#123;&#125;fn.call(target, 'arg1', 'arg2');fn.apply(target, ['arg1', 'arg2']);fn.bind(target, 'arg1', 'arg2')(); 隐式绑定那么隐式绑定的口诀就是我们说的那一句话。 123456789101112131415161718const person = &#123; name: 'Lucas', fn: function() &#123; return this.name &#125;, brother: &#123; name: 'Mike', fn: function() &#123; return this.name &#125; &#125;&#125;var fn1 = person.brother.fn;console.log(fn1());console.log(person.fn());console.log(person.brother.fn()); new关键字new关键字生成的实例中，this的指向为该对象。 关于new关键字的更多操作在之后讲。 123456789101112131415const person = function() &#123; this.name = 'Lucas', this.fn = function() &#123; return this.name &#125;, this.brother = &#123; name: 'Mike', fn: function() &#123; return this.name &#125; &#125;&#125;console.log(new person().fn());console.log(new person().brother.fn()); 箭头函数箭头函数是es6中的新特性，他本身没有this指针。所以this指针的指向是在形成时，其外部作用域（函数作用域或者全局作用域）的指向。 123456789101112const a = &#123; fn:()=&gt;&#123; console.log(this) &#125; fn2: (function() &#123; console.log(this) &#125;)()&#125;console.log(a.fn())console.log(a.fn2()) this的优先级new关键字高于显示绑定高于隐式绑定，箭头函数的this不能被改变。 new关键字实现 创建新对象，将对象的__proto__指向函数的prototype 将属性挂在新对象上 this的指向指向新对象 如果没有返回对象则返回this，否则返回该对象 12345var _new = function(fn, ...arg) &#123; let obj = Object.create(fn.prototype); //1 const res = fn.apply(obj, arg); //2,3 return res instanceof Object ? res : object; //4&#125; bind实现12345678910var _bind = Function.prototype.bind || function() &#123; var me = this var context = Array.prototype.shift.call(arguments) var arg = Array.prototype.slice.call(arguments) return function bound()&#123; var innnerArg = Array.prototype.slice.call(arguments) var args = arg.contact(innerArg); return me.apply(context, args); &#125;&#125;","categories":[],"tags":[]},{"title":"Echarts Project Summary","slug":"Echarts Project Summary","date":"2021-10-08T09:18:04.317Z","updated":"2021-10-08T09:18:04.317Z","comments":true,"path":"2021/10/08/Echarts Project Summary/","link":"","permalink":"http://yoursite.com/2021/10/08/Echarts%20Project%20Summary/","excerpt":"","text":"引言 2021年的暑期在summer2021的活动当中找了一个开源项目，并且在学姐的建议下找一个比较大的开源团队（Apache）项目去写。最终也是捡漏捡到了Echarts的这样一个高难度的项目去写。（只有我一个人报了这个项目 现在写这篇博客的时候正是9月22日，还有几天就要期末考核了，但是我的导师还是没有review我的代码和对第二个需求的详细解答。我也很无奈，很想结项啊！！！把我的code合进去也不擦啊啊啊！ 需求分析当时接到需求的时候大概心里是有了个想法的，“关于节点自指”，其实就是节点的边信息当中的始末节点都为一个节点。有了想法就去实施，我把仓库clone下来时，我又懵了。只知道按照惯例开始往src里面找代码。 在这里我利用了搜索工具，搜索了一下graph这么个关键字，找到了对应的文件夹，开始啥也不懂的乱看。这里有提到test文件夹里面的例子，其实是已经帮我们链接好了，所以我反复对比官网和代码。找到了可以改变内容的代码之后，立马跑过去问导师了，导师也给出了相应的回复，这时才慢慢走上了正道。 类突然想起来我刚刚开始看的时候是把几个类看了才开始写的。类也是面向对象最基本的思想，我涉及部分的类有Graph类、GraphNode类、GraphEdge类、List类、Line类。现在想想只有最开始把这些类搞清楚了，到后面看代码的时候才对一些方法和属性搞糊涂。 Graph类，是最基础的图类，其中有GraphNode数组和Graph Edge数组作为属性，data和edgeData两个List类。以及一些其他的方法和属性。这里最主要的就是这些。 12345678910111213class Graph &#123; type: 'graph' = 'graph'; readonly nodes: GraphNode[] = []; readonly edges: GraphEdge[] = []; data: List; edgeData: List; ...//部分代码展示&#125; GraphNode类，是图结点类 123456789101112131415class GraphNode &#123; id: string; inEdges: GraphEdge[] = []; outEdges: GraphEdge[] = []; edges: GraphEdge[] = []; hostGraph: Graph; dataIndex: number = -1; ...//部分代码展示&#125; GraphEdge类，是图关系类 123456789101112131415class GraphEdge &#123; /** * The first node. If directed graph, it represents the source node. */ node1: GraphNode; /** * The second node. If directed graph, it represents the target node. */ node2: GraphNode; dataIndex: number = -1; hostGraph: Graph; ...//部分代码展示&#125; List类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class List&lt; HostModel extends Model = Model, Visual extends DefaultDataVisual = DefaultDataVisual&gt; &#123; readonly type = 'list'; readonly dimensions: string[]; // Infomation of each data dimension, like data type. private _dimensionInfos: &#123;[dimName: string]: DataDimensionInfo&#125;; readonly hostModel: HostModel; ...//部分代码展示 // eslint-disable-next-line setItemVisual&lt;K extends keyof Visual&gt;(idx: number, key: K, value: Visual[K]): void; setItemVisual(idx: number, kvObject: Partial&lt;Visual&gt;): void; // eslint-disable-next-line setItemVisual&lt;K extends keyof Visual&gt;(idx: number, key: K | Partial&lt;Visual&gt;, value?: Visual[K]): void &#123; const itemVisual = this._itemVisuals[idx] || &#123;&#125;; this._itemVisuals[idx] = itemVisual; if (isObject(key)) &#123; zrUtil.extend(itemVisual, key); &#125; else &#123; itemVisual[key as string] = value; &#125; &#125; setLayout(key: string, val: any): void; setLayout(kvObj: Dictionary&lt;any&gt;): void; setLayout(key: string | Dictionary&lt;any&gt;, val?: any): void &#123; if (isObject(key)) &#123; for (const name in key) &#123; if (key.hasOwnProperty(name)) &#123; this.setLayout(name, key[name]); &#125; &#125; return; &#125; this._layout[key] = val; &#125; /** * Get layout property. */ getLayout(key: string): any &#123; return this._layout[key]; &#125; /** * Get layout of single data item */ getItemLayout(idx: number): any &#123; return this._itemLayouts[idx]; &#125; ...//部分代码展示&#125; Bezire curvehttps://www.jianshu.com/p/8f82db9556d2 实现实现贝塞尔曲线。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102function createLine(points: number[][]) &#123; const line = new ECLinePath(&#123; name: 'line', subPixelOptimize: true &#125;); setLinePoints(line.shape, points); return line;&#125;function setLinePoints(targetShape: ECLinePath['shape'], points: number[][]) &#123; type CurveShape = ECLinePath['shape'] &amp; &#123; cpx1: number cpy1: number cpx2?: number cpy2?: number &#125;; targetShape.x1 = points[0][0]; targetShape.y1 = points[0][1]; targetShape.x2 = points[1][0]; targetShape.y2 = points[1][1]; targetShape.percent = 1; const cp1 = points[2]; const cp2 = points[3]; if (cp1) &#123; (targetShape as CurveShape).cpx1 = cp1[0]; (targetShape as CurveShape).cpy1 = cp1[1]; &#125; else &#123; (targetShape as CurveShape).cpx1 = NaN; (targetShape as CurveShape).cpy1 = NaN; &#125; if (cp2) &#123; (targetShape as CurveShape).cpx2 = cp2[0]; (targetShape as CurveShape).cpy2 = cp2[1]; &#125;&#125;class Line extends graphic.Group &#123; private _fromSymbolType: string; private _toSymbolType: string; constructor(lineData: List, idx: number, seriesScope?: LineDrawSeriesScope) &#123; super(); this._createLine(lineData as LineList, idx, seriesScope); &#125; _createLine(lineData: LineList, idx: number, seriesScope?: LineDrawSeriesScope) &#123; const seriesModel = lineData.hostModel; const linePoints = lineData.getItemLayout(idx); const line = createLine(linePoints); line.shape.percent = 0; graphic.initProps(line, &#123; shape: &#123; percent: 1 &#125; &#125;, seriesModel, idx); this.add(line); each(SYMBOL_CATEGORIES, function (symbolCategory) &#123; const symbol = createSymbol(symbolCategory, lineData, idx); // symbols must added after line to make sure // it will be updated after line#update. // Or symbol position and rotation update in line#beforeUpdate will be one frame slow this.add(symbol); this[makeSymbolTypeKey(symbolCategory)] = lineData.getItemVisual(idx, symbolCategory); &#125;, this); this._updateCommonStl(lineData, idx, seriesScope); &#125; updateData(lineData: List, idx: number, seriesScope: LineDrawSeriesScope) &#123; const seriesModel = lineData.hostModel; const line = this.childOfName('line') as ECLinePath; const linePoints = lineData.getItemLayout(idx); const target = &#123; shape: &#123;&#125; as ECLinePath['shape'] &#125;; setLinePoints(target.shape, linePoints); graphic.updateProps(line, target, seriesModel, idx); each(SYMBOL_CATEGORIES, function (symbolCategory) &#123; const symbolType = (lineData as LineList).getItemVisual(idx, symbolCategory); const key = makeSymbolTypeKey(symbolCategory); // Symbol changed if (this[key] !== symbolType) &#123; this.remove(this.childOfName(symbolCategory)); const symbol = createSymbol(symbolCategory, lineData as LineList, idx); this.add(symbol); &#125; this[key] = symbolType; &#125;, this); this._updateCommonStl(lineData, idx, seriesScope); &#125;; //部分代码&#125; 在line类中调用了createLine方法，createLine方法有调用了setLinePoints方法。而原来的setLinePoints方法没有cpx2和cpy2的属性，更改之后如上，percent属性是描述线段显示的百分比。通过lineData是lineList类也是List的子类，通过getItemLayout方法获取数组。也就是setLinePoints的points参数，分别为source，curvepoint1，curvepoint2，target。这样我们就可以通过nodeEgde的setLayout方法来设定边的属性了。 如何计算curvePoints的位置这里就需要用到一些简单的数学几何知识，因为LoopEdge的source和target为同一个目标，所以我们只需要确定curvePoint的位置就好了。我们可以取一条过圆心的线，而两个curvePoint所成线段被该线垂直平分，此时所形成的贝塞尔曲线就是我们需要的形状。 123456function getCubicControlPoint(radToXPosi: number, cpDistToCenter: number): number[] &#123; return [ Math.cos(radToXPosi) * cpDistToCenter + centerPt[0], Math.sin(radToXPosi) * cpDistToCenter + centerPt[1] ]; &#125;; 这里就是直接计算点坐标的公式了，而这里的radToXposi是弧度为单位的，乘上长度变成了坐标。 而当我们的节点与其他节点有其他边的关系时，我们如何选取LoopEdge的中线位置来画边呢？这里是导师给出的思路。 取该节点的相邻边，并依据边的正切值对边进行排序。 再一次根据正切值画出每一个 section，并找出最小的 section 部分。如果最小部分 大于 60°，则放入 sectionlist 内，且将 availableCount 加上在这个部分可以放入的边的数。 如果可以放边的数大于需要放的 Loop 边，则在 section 中找到最大的部分，将边 放入。 当边太多时，我们则不考虑边的交叠影响。 放边的算法：在每个 section 中有 edgeCount 属性，如果该属性为 0，则直接跳出， 反之继续； edgeCount 主要把 section 再次细分成几个部分。在计算部分的中线，进行计算剩 下两个点的坐标。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243import Graph, &#123; GraphEdge, GraphNode &#125; from '../../data/Graph';import &#123; sub, VectorArray &#125; from 'zrender/src/core/vector';import &#123; assert, bind, each, retrieve2 &#125; from 'zrender/src/core/util';import &#123; GraphEdgeItemOption &#125; from './GraphSeries';import &#123; getSymbolSize &#125; from './graphHelper';type Radian = number;type NodeAttrOnEdge = 'node1' | 'node2';interface EdgeWrap &#123; /** * Vector of the tangent line at the center node. */ tangentVec: VectorArray; /** * Radian of tangentVec (to x positive) of tangentVec. [-Math.PI / 2, Math.PI / 2]. */ radToXPosi: Radian;&#125;interface SectionWrap &#123; /** * Radian of tangentVec (to x positive) of tangentVec. [-Math.PI / 2, Math.PI / 2]. * Make sure radToXPosiStart &lt;= radToXPosiEnd. */ radToXPosiStart: Radian; radToXPosiEnd: Radian; /** * The count of edges that assign to this section. */ edgeCount: number;&#125;const MATH_PI = Math.PI;const MATH_2PI = MATH_PI * 2;/** * This is the radian of the intersection angle of the two control * point of a self-loop cubic bezier edge. * If the angle is bigger or smaller, the cubic curve is not pretty. */const MAX_EDGE_SECTION_RADIAN = MATH_PI - getRadianToXPositive([4, 5.5]) * 2;const MIN_EDGE_SECTION_RADIAN = MATH_PI / 3;/** * @caution This method should only be called after all * nodes and non-self-loop edges layout finished. * * @note [Self-loop edge layout strategy]: * To make it have good looking when there are muliple self-loop edges, * place them from the biggest angle (&gt; 60 degree) one by one. * If there is no enough angles, put mulitple edges in one angle * and use different curvenesses. * * @pending Should the section angle and self-loop edge direction be able to set by user? * `curveness` can not express it. * * @pending Consider the self-loop edge might overlow the canvas. * When calculating the view transform, there is no self-loop layout info yet. */export function layoutSelfLoopEdges( graph: Graph, // Get from `getNodeGlobalScale(seriesModel)` nodeScaleOnCoordSys: number): void &#123; graph.eachNode(node =&gt; &#123; const selfLoopEdges: GraphEdge[] = []; // inEdges includes outEdges if self-loop. each(node.inEdges, edge =&gt; &#123; if (isSelfLoopEdge(edge)) &#123; selfLoopEdges.push(edge); &#125; &#125;); if (selfLoopEdges.length) &#123; const sectionList = prepareSectionList(node, selfLoopEdges.length); placeSelfLoopEdges(node, sectionList, selfLoopEdges, nodeScaleOnCoordSys); &#125; &#125;);&#125;/** * @return Sections that can arrange self-loop angles. Ensure that: * `selfLoopEdgeCount &lt;= sectionList.reduce((sum, sec) === sec.edgeCount + sum, 0)` */function prepareSectionList(centerNode: GraphNode, selfLoopEdgeCount: number): SectionWrap[] &#123; const adjacentEdges: EdgeWrap[] = []; function addAdjacentEdge(centerNodeAttr: NodeAttrOnEdge, edge: GraphEdge): void &#123; if (isSelfLoopEdge(edge)) &#123; return; &#125; const tangentVec = getTangentVector(edge, centerNodeAttr); const radToXPosi = getRadianToXPositive(tangentVec); adjacentEdges.push(&#123; tangentVec, radToXPosi &#125;); &#125; each(centerNode.inEdges, bind(addAdjacentEdge, null, 'node2')); each(centerNode.outEdges, bind(addAdjacentEdge, null, 'node1')); // Sort by radian asc. adjacentEdges.sort((edgeA, edgeB) =&gt; edgeA.radToXPosi - edgeB.radToXPosi); let availableEdgeCount = 0; const sectionList: SectionWrap[] = []; for (let i = 0, len = adjacentEdges.length; i &lt; len; i++) &#123; const radToXPosiStart = adjacentEdges[i].radToXPosi; const radToXPosiEnd = i &lt; len - 1 ? adjacentEdges[i + 1].radToXPosi : adjacentEdges[0].radToXPosi + MATH_2PI; // Make sure radToXPosiStart &lt;= radToXPosiEnd. const rad2Minus1 = radToXPosiEnd - radToXPosiStart; if (rad2Minus1 &gt;= MIN_EDGE_SECTION_RADIAN) &#123; sectionList.push(&#123; radToXPosiStart, radToXPosiEnd, edgeCount: 0 &#125;); &#125; availableEdgeCount += rad2Minus1 / MIN_EDGE_SECTION_RADIAN; &#125; if (availableEdgeCount &gt;= selfLoopEdgeCount) &#123; for (let iEdge = 0; iEdge &lt; selfLoopEdgeCount; iEdge++) &#123; // Find the largest section to arrange an edge. let iSecInMax = 0; let secRadInMax = 0; for (let iSec = 0; iSec &lt; sectionList.length; iSec++) &#123; const thisSec = sectionList[iSec]; // If a section is too larger than anohter section, split that large section and // arrange multiple edges in it is probably better then arrange only one edge in // the large section. const rad = (thisSec.radToXPosiEnd - thisSec.radToXPosiStart) / (thisSec.edgeCount + 1); if (rad &gt; secRadInMax) &#123; secRadInMax = rad; iSecInMax = iSec; &#125; &#125; sectionList[iSecInMax].edgeCount++; &#125; &#125; // In this case there are probably too many edge on a node, and intersection between // edges can not avoid. So we do not care about intersection any more. else &#123; sectionList.length = 0; sectionList.push(&#123; radToXPosiStart: -MATH_PI / 2, radToXPosiEnd: -MATH_PI / 2 + MATH_2PI, edgeCount: selfLoopEdgeCount &#125;); &#125; return sectionList;&#125;/** * @return cubic bezier curve: [p1, p2, cp1, cp2] */function placeSelfLoopEdges( centerNode: GraphNode, sectionList: SectionWrap[], selfLoopEdges: GraphEdge[], nodeScaleOnCoordSys: number): void &#123; const symbolSize = getSymbolSize(centerNode); const centerPt = centerNode.getLayout(); function getCubicControlPoint(radToXPosi: number, cpDistToCenter: number): number[] &#123; return [ Math.cos(radToXPosi) * cpDistToCenter + centerPt[0], Math.sin(radToXPosi) * cpDistToCenter + centerPt[1] ]; &#125;; let iEdge = 0; each(sectionList, section =&gt; &#123; const secEdgeCount = section.edgeCount; if (!secEdgeCount) &#123; // No self-loop edge arranged in this section. return; &#125; const secRadStart = section.radToXPosiStart; const secRadEnd = section.radToXPosiEnd; const splitRadHalfSpan = (secRadEnd - secRadStart) / section.edgeCount / 2; const edgeRadHalfSpan = Math.min(splitRadHalfSpan, MAX_EDGE_SECTION_RADIAN / 2); // const radMid = secRadStart + secRadSpan / section.edgeCount * (iEdge - iEdgeFirstInSec); for (let iEdgeInSec = 0; iEdgeInSec &lt; section.edgeCount; iEdgeInSec++) &#123; const edge = selfLoopEdges[iEdge++]; const cpMidRad = secRadStart + splitRadHalfSpan * (iEdgeInSec * 2 + 1); // This is a experimental strategy to make it look better: // If the symbol size is small, the bezier control point need to be far from the // center to make the buckle obvious, while if the symbol size is big, the control // ponit should not too far to make the buckle too significant. // So we alway make control point dist to symbol radius `100`, and enable users to // use option `curveness` to adjust it. // Becuase at present we do not layout multiple self-loop edges into single // `[cp1Rad, cp2Rad]`, we do not use option `autoCurveness`. const curveness = retrieve2( edge.getModel&lt;GraphEdgeItemOption&gt;().get(['lineStyle', 'curveness']), 0 ); const cpDistToCenter = (symbolSize / 2 + 100) * nodeScaleOnCoordSys * (curveness + 1) // Formula: // If `cpDistToCenter = symbolSize / 2 * nodeScaleOnCoordSys / 3 * 4 / Math.cos(edgeRadHalfSpan)`, // the control point can be tangent to the symbol circle. // Hint: `distCubicMiddlePtToCenterPt / 3 * 4` get the hight of the isosceles triangle made by // control points and center point. / 3 * 4 / Math.cos(edgeRadHalfSpan); edge.setLayout([ centerPt.slice(), centerPt.slice(), getCubicControlPoint(cpMidRad - edgeRadHalfSpan, cpDistToCenter), getCubicControlPoint(cpMidRad + edgeRadHalfSpan, cpDistToCenter) ]); &#125; &#125;); assert(iEdge === selfLoopEdges.length);&#125;/** * @return vector representing the tangant line * (from edge['node1' | 'node2'] to cp1 of the cubic bezier curve) */function getTangentVector(edge: GraphEdge, nodeAttr: NodeAttrOnEdge): VectorArray &#123; // points is [p1, p2] or [p1, p2, cp1]. const points = edge.getLayout(); const targetPt = points[2] ? points[2] : points[1]; return sub([], targetPt, edge[nodeAttr].getLayout());&#125;function getRadianToXPositive(vec: VectorArray): Radian &#123; return Math.atan2(vec[1], vec[0]);&#125;export function isSelfLoopEdge(edge: GraphEdge): boolean &#123; return edge.node1 === edge.node2;&#125; AjustEgde在原本的需求里面还有一个adjustEgde的对于边的渲染的改变，使得symbol的坐标在节点边上而不是圆心。这里的算法思路就是利用二分法找到在线段上和节点最近的点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215import * as curveTool from 'zrender/src/core/curve';import * as vec2 from 'zrender/src/core/vector';import &#123;getSymbolSize&#125; from './graphHelper';import Graph from '../../data/Graph';const v1: number[] = [];const v2: number[] = [];const v3: number[] = [];const quadraticAt = curveTool.quadraticAt;const cubicAt = curveTool.cubicAt;const v2DistSquare = vec2.distSquare;const mathAbs = Math.abs;export function intersectCurveCircle( curvePoints: number[][], center: number[], radius: number) &#123; const p0 = curvePoints[0]; // source point const p1 = curvePoints[1]; // curve point 1 const p2 = curvePoints[2]; // curve point 2 or target point const p3 = curvePoints[3] ?? [null, null]; // target point let d = Infinity; let t; const radiusSquare = radius * radius; let interval = 0.1; const bezierAt = p3[0] &amp;&amp; p3[1] ? cubicAt // 计算三次贝塞尔值 : function (p0: number, p1: number, p2: number, p3: number, t: number): number &#123; return quadraticAt(p0, p1, p2, t); //计算二次贝塞尔值 &#125;; for (let _t = 0.1; _t &lt;= 0.9; _t += 0.1) &#123; v1[0] = bezierAt(p0[0], p1[0], p2[0], p3[0], _t); //bezire curve point of x v1[1] = bezierAt(p0[1], p1[1], p2[1], p3[1], _t); //bezire curve point of y const diff = mathAbs(v2DistSquare(v1, center) - radiusSquare); if (diff &lt; d) &#123; d = diff; t = _t; &#125; &#125; // Assume the segment is monotone，Find root through Bisection method // At most 32 iteration for (let i = 0; i &lt; 32; i++) &#123; // const prev = t - interval; const next = t + interval; // v1[0] = bezierAt(p0[0], p1[0], p2[0], p3[0], prev); // v1[1] = bezierAt(p0[1], p1[1], p2[1], p3[1], prev); v2[0] = bezierAt(p0[0], p1[0], p2[0], p3[0], t); v2[1] = bezierAt(p0[1], p1[1], p2[1], p3[1], t); v3[0] = bezierAt(p0[0], p1[0], p2[0], p3[0], next); v3[1] = bezierAt(p0[1], p1[1], p2[1], p3[1], next); const diff = v2DistSquare(v2, center) - radiusSquare; if (mathAbs(diff) &lt; 1e-2) &#123; break; &#125; // let prevDiff = v2DistSquare(v1, center) - radiusSquare; const nextDiff = v2DistSquare(v3, center) - radiusSquare; interval /= 2; if (diff &lt; 0) &#123; if (nextDiff &gt;= 0) &#123; t = t + interval; &#125; else &#123; t = t - interval; &#125; &#125; else &#123; if (nextDiff &gt;= 0) &#123; t = t - interval; &#125; else &#123; t = t + interval; &#125; &#125; &#125; return t;&#125;// Adjust edge to avoidexport default function adjustEdge(graph: Graph, scale: number) &#123; const tmp0: number[] = []; const quadraticSubdivide = curveTool.quadraticSubdivide; //细分二次贝塞尔曲线 const cubicSubdivide = curveTool.cubicSubdivide; //细分三次贝塞尔曲线 const pts3: number[][] = [[], [], []]; const pts2: number[][] = [[], []]; const pts4 : number[][] = [[], [], [], []]; const v: number[] = []; scale /= 2; graph.eachEdge(function (edge, idx) &#123; const linePoints = edge.getLayout(); const fromSymbol = edge.getVisual('fromSymbol'); const toSymbol = edge.getVisual('toSymbol'); if (!linePoints.__original) &#123; linePoints.__original = [ vec2.clone(linePoints[0]), vec2.clone(linePoints[1]) ]; if (linePoints[2]) &#123; linePoints.__original.push(vec2.clone(linePoints[2])); &#125; if (linePoints[3]) &#123; linePoints.__original.push(vec2.clone(linePoints[3])); &#125; &#125; const originalPoints = linePoints.__original; // Cubic curve if (linePoints[3] != null) &#123; vec2.copy(pts4[0], originalPoints[0]); vec2.copy(pts4[1], originalPoints[2]); vec2.copy(pts4[2], originalPoints[3]); vec2.copy(pts4[3], originalPoints[1]); if (fromSymbol &amp;&amp; fromSymbol !== 'none') &#123; const symbolSize = getSymbolSize(edge.node1); let t = intersectCurveCircle(pts4, originalPoints[0], symbolSize * scale); if (t &gt; 0.5) &#123; t = 1 - t; &#125; // Subdivide and get the second cubicSubdivide(pts4[0][0], pts4[1][0], pts4[2][0], pts4[3][0], t, tmp0); pts4[0][0] = tmp0[4]; pts4[1][0] = tmp0[5]; pts4[2][0] = tmp0[6]; cubicSubdivide(pts4[0][1], pts4[1][1], pts4[2][1], pts4[3][1], t, tmp0); pts4[0][1] = tmp0[4]; pts4[1][1] = tmp0[5]; pts4[2][1] = tmp0[6]; &#125; if (toSymbol &amp;&amp; toSymbol !== 'none') &#123; const symbolSize = getSymbolSize(edge.node2); let t = intersectCurveCircle(pts4, originalPoints[1], symbolSize * scale); if (t &lt; 0.5) &#123; t = 1 - t; &#125; // Subdivide and get the first cubicSubdivide(pts4[0][0], pts4[1][0], pts4[2][0], pts4[3][0], t, tmp0); pts4[1][0] = tmp0[1]; pts4[2][0] = tmp0[2]; pts4[3][0] = tmp0[3]; cubicSubdivide(pts4[0][1], pts4[1][1], pts4[2][1], pts4[3][1], t, tmp0); pts4[1][1] = tmp0[1]; pts4[2][1] = tmp0[2]; pts4[3][1] = tmp0[3]; &#125; vec2.copy(linePoints[0], pts4[0]); vec2.copy(linePoints[1], pts4[3]); vec2.copy(linePoints[2], pts4[1]); vec2.copy(linePoints[3], pts4[2]); &#125; // Quadratic curve else if (linePoints[2] != null) &#123; vec2.copy(pts3[0], originalPoints[0]); vec2.copy(pts3[1], originalPoints[2]); vec2.copy(pts3[2], originalPoints[1]); if (fromSymbol &amp;&amp; fromSymbol !== 'none') &#123; const symbolSize = getSymbolSize(edge.node1); const t = intersectCurveCircle(pts3, originalPoints[0], symbolSize * scale); // Subdivide and get the second quadraticSubdivide(pts3[0][0], pts3[1][0], pts3[2][0], t, tmp0); pts3[0][0] = tmp0[3]; pts3[1][0] = tmp0[4]; quadraticSubdivide(pts3[0][1], pts3[1][1], pts3[2][1], t, tmp0); pts3[0][1] = tmp0[3]; pts3[1][1] = tmp0[4]; &#125; if (toSymbol &amp;&amp; toSymbol !== 'none') &#123; const symbolSize = getSymbolSize(edge.node2); const t = intersectCurveCircle(pts3, originalPoints[1], symbolSize * scale); // Subdivide and get the first quadraticSubdivide(pts3[0][0], pts3[1][0], pts3[2][0], t, tmp0); pts3[1][0] = tmp0[1]; pts3[2][0] = tmp0[2]; quadraticSubdivide(pts3[0][1], pts3[1][1], pts3[2][1], t, tmp0); pts3[1][1] = tmp0[1]; pts3[2][1] = tmp0[2]; &#125; // Copy back to layout vec2.copy(linePoints[0], pts3[0]); vec2.copy(linePoints[1], pts3[2]); vec2.copy(linePoints[2], pts3[1]); &#125; // Line else &#123; vec2.copy(pts2[0], originalPoints[0]); vec2.copy(pts2[1], originalPoints[1]); vec2.sub(v, pts2[1], pts2[0]); vec2.normalize(v, v); if (fromSymbol &amp;&amp; fromSymbol !== 'none') &#123; const symbolSize = getSymbolSize(edge.node1); vec2.scaleAndAdd(pts2[0], pts2[0], v, symbolSize * scale); &#125; if (toSymbol &amp;&amp; toSymbol !== 'none') &#123; const symbolSize = getSymbolSize(edge.node2); vec2.scaleAndAdd(pts2[1], pts2[1], v, -symbolSize * scale); &#125; vec2.copy(linePoints[0], pts2[0]); vec2.copy(linePoints[1], pts2[1]); &#125; &#125;);&#125;","categories":[],"tags":[]},{"title":"Sass","slug":"Sass","date":"2021-09-22T02:41:04.473Z","updated":"2020-04-02T06:25:38.000Z","comments":true,"path":"2021/09/22/Sass/","link":"","permalink":"http://yoursite.com/2021/09/22/Sass/","excerpt":"","text":"Sass学习​ 因为在Taro项目中有用到Sass，但是当时并没有学习所以就分开来写。 一、安装因为Taro项目初始化的时候会自行安装，只要选择Sass就行了。所以这里给出官方链接。https://sass.bootcss.com/install 二、变量变量是存储信息并在将来重复利用的一种方式，在整个样式表中都可访问。 你可以在变量中存储颜色、字体 或任何 CSS 值，并在将来重复利用。Sass 使用 $ 符号 作为变量的标志。 1234567$font-stack: Helvetica, sans-serif;$primary-color: #333;body &#123; font: 100% $font-stack; color: $primary-color;&#125; 1234body &#123; font: 100% Helvetica, sans-serif; color: #333;&#125; 三、嵌套​ 在编写 HTML 时，它有一个清晰的嵌套和可视化层次结构。 而 CSS 则没有。 ​ Sass 允许嵌套 CSS 选择器，嵌套方式 与 HTML 的视觉层次结构相同。请注意，过度嵌套的规则 将导致过度限定的 CSS，这些 CSS 可能很难维护，并且 通常被认为是不好的做法。 ​ 理解了这一点，下面就来看一个典型的网站导航的样式 示例： 123456789101112131415nav &#123; ul &#123; margin: 0; padding: 0; list-style: none; &#125; li &#123; display: inline-block; &#125; a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125;&#125; 12345678910111213nav ul &#123; margin: 0; padding: 0; list-style: none;&#125;nav li &#123; display: inline-block;&#125;nav a &#123; display: block; padding: 6px 12px; text-decoration: none;&#125; 四、片段创建部分Sass文件，其中包含一些CSS片段 ，可以将其包含在其他Sass文件中。这是模块化CSS并帮助使事情易于维护的好方法。部分文件是一个Sass文件，名称前带有一个下划线。可以将其命名为_partial.scss。下划线让Sass知道该文件只是部分文件，不应将其生成为CSS文件。Sass局部函数与@use 规则一起使用。 五、模块不必将所有Sass都写在一个文件中。您可以根据需要将其拆分@use。该规则将另一个Sass文件作为模块加载，这意味着您可以在Sass文件中使用基于文件名的命名空间引用其变量，mixins和函数。使用文件还将在编译输出中包含它生成的CSS！ 12345678// _base.scss$font-stack: Helvetica, sans-serif;$primary-color: #333;body &#123; font: 100% $font-stack; color: $primary-color;&#125; 1234567// styles.scss@use 'base';.inverse &#123; background-color: base.$primary-color; color: white;&#125; 123456789body &#123; font: 100% Helvetica, sans-serif; color: #333;&#125;.inverse &#123; background-color: #333; color: white;&#125; 六、混合​ CSS中的某些内容编写起来有些繁琐，尤其是使用CSS3 和存在的许多供应商前缀时。使用mixin，您可以创建要在整个站点中重复使用的CSS声明组 。您甚至可以传入值以使混入更加灵活。mixin的一个很好的用法是用于供应商前缀。这是的示例 transform。 123456@mixin transform($property) &#123; -webkit-transform: $property; -ms-transform: $property; transform: $property;&#125;.box &#123; @include transform(rotate(30deg)); &#125; 12345.box &#123; -webkit-transform: rotate(30deg); -ms-transform: rotate(30deg); transform: rotate(30deg);&#125; 要创建一个mixin，请使用@mixin指令并为其命名。我们将其命名为mixin transform。我们还在$property括号内使用了变量 ，因此我们可以传递任何所需的变换。创建混入之后，您可以将其用作CSS 声明@include，以混入的名称开头。 七、扩展继承​ 这是Sass最有用的功能之一。使用@extend使您可以将一组CSS属性从一个选择器共享到另一个选择器。它有助于使Sass保持非常干燥。在我们的示例中，我们将使用扩展，占位符类一起使用的另一个功能，为错误，警告和成功创建一系列简单的消息传递。占位符类是一种特殊的类，仅在扩展时才打印，并且可以帮助保持编译后的CSS整洁。 12345678910111213141516171819202122232425262728293031/* This CSS will print because %message-shared is extended. */%message-shared &#123; border: 1px solid #ccc; padding: 10px; color: #333;&#125;// This CSS won't print because %equal-heights is never extended.%equal-heights &#123; display: flex; flex-wrap: wrap;&#125;.message &#123; @extend %message-shared;&#125;.success &#123; @extend %message-shared; border-color: green;&#125;.error &#123; @extend %message-shared; border-color: red;&#125;.warning &#123; @extend %message-shared; border-color: yellow;&#125; 123456789101112131415161718/* This CSS will print because %message-shared is extended. */.message, .success, .error, .warning &#123; border: 1px solid #ccc; padding: 10px; color: #333;&#125;.success &#123; border-color: green;&#125;.error &#123; border-color: red;&#125;.warning &#123; border-color: yellow;&#125; ​ 上面的代码的作用是告诉.message，.success，.error，和.warning做人一样%message-shared。这意味着任何地方%message-shared显示来，.message，.success，.error，和 .warning也会这样做的。魔术发生在生成的CSS中，其中每个类将获得与相同的CSS属性%message-shared。这有助于您避免在HTML 元素上编写多个类名。 ​ 除了Sass中的占位符类之外，您还可以扩展最简单的CSS选择器，但是使用占位符是确保不扩展嵌套在样式中其他位置的类的最简单方法，这会导致CSS中意外的选择器 。 ​ 请注意，不会生成CSS in %equal-heights，因为%equal-heights它不会被扩展。 八、操作符​ 在 CSS 中经常需要做数学计算。Sass 支持一些标准的 数学运算符，例如 +、-、*、/ 和 %。在下面的例子中，我们 将做一些简单的数学运算来计算出 aside &amp; article 的宽度。 12345678910111213.container &#123; width: 100%;&#125;article[role=\"main\"] &#123; float: left; width: 600px / 960px * 100%;&#125;aside[role=\"complementary\"] &#123; float: right; width: 300px / 960px * 100%;&#125;","categories":[],"tags":[]},{"title":"React UI娓叉煋","slug":"React UI娓叉煋","date":"2021-09-22T02:40:58.908Z","updated":"2021-04-27T12:46:22.000Z","comments":true,"path":"2021/09/22/React UI娓叉煋/","link":"","permalink":"http://yoursite.com/2021/09/22/React%20UI%E5%A8%93%E5%8F%89%E7%85%8B/","excerpt":"","text":"​ 一开始是因为老板给发的useEffect的链接去看到里面还有一篇关于React渲染机制的，因为老是看到菁程里面渲染次数问题一直没搞清楚，所以就又去看了一下，下面也会写一篇关于useEffect（其实不是特别想写因为怕是直接抄了，还是要想一下怎么用自己的理解写一篇分享吧） 一个小Demo123456import React from 'react'const element = &lt;div title=\"ele\"&gt;This is an element.&lt;/div&gt;;const container = document.getElementById(\"root\");ReactDOM.render(element, container); 这里element是一个简单的div块,是一个react元素。这里区分一下DOM节点和react元素。container是获取到的DOM节点作为容器。而这里使用的还是JSX语法，Babel会将编译一下变成： 12345678910import React from 'react'const element = React.createElement( \"div\", &#123; title: \"ele\" &#125;, \"This is an element\");const container = document.getElementById(\"root\");ReactDOM.render(element, container); createElement接受的第一个参数是元素类型div；第二的参数是attribute对象，有title等属性；第三个参数是textNode。 而事实上的一个react元素是这样审的： 1234567const element = &#123; type: \"div\", props: &#123; title: \"ele\", children: \"This is an element\" &#125;&#125; 而在渲染时，发生了以下的传统DOM操作： 123456789// 在 ReactDOM 渲染器内部（简化版）function createHostInstance(reactElement) &#123; let domNode = document.createElement(reactElement.type); domNode.className = reactElement.props.className; let textNode = document.createTextNode(\"\")； textNode.nodeValue = reactElement.props.children; domNode.appendChild(textNode); return domNode;&#125; 从而将react元素变成了dom的节点。 这里很明显就出现了一个问题，如何处理children是需要优化的。因为children也有可能是一个数组对象（其他的react元素）。 例如这样的一个element： 12345678910111213const element = ( &lt;div id=\"foo\"&gt; &lt;a&gt;bar&lt;/a&gt; &lt;b /&gt; &lt;/div&gt;)//经过编译后const element = React.createElement( \"div\", &#123; id: \"foo\" &#125;, React.createElement(\"a\", null, \"bar\"), React.createElement(\"b\")) 我们开始工厂模式创造元素： 1234567891011121314151617181920212223function createElement(type, props, ...children) &#123; return &#123; type, props: &#123; ...props, children: children.map(child =&gt; typeof child === \"object\" ? child : createTextElement(child) ), &#125;, &#125;&#125;function createTextElement(text) &#123; return &#123; type: \"TEXT_ELEMENT\", props: &#123; nodeValue: text, children: [], &#125;, &#125;&#125; 我们自己设计了两个函数，来生成元素节点或者文本节点。文本节点的type为”TEXT_ELEMENT“,且将children置为空数组。这样就可以区分不同的child了。 接下来就是render部分了：follow step by step. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function render(element, container) &#123; // TODO create dom nodes&#125;function render(element, container) &#123; const dom = document.createElement(element.type) container.appendChild(dom)&#125;// 将react元素转化为dom节点function render(element, container) &#123; const dom = document.createElement(element.type) element.props.children.forEach(child =&gt; render(child, dom) )// 遍历children， 递归调用 container.appendChild(dom)&#125;function render(element, container) &#123; const dom = element.type == \"TEXT_ELEMENT\" ? document.createTextNode(\"\") : document.createElement(element.type) //dom可能为文本节点和元素节点两类 element.props.children.forEach(child =&gt; render(child, dom) ) container.appendChild(dom)&#125;function render(element, container) &#123; const dom = element.type == \"TEXT_ELEMENT\" ? document.createTextNode(\"\") : document.createElement(element.type) const isProperty = key =&gt; key !== \"children\" //判断是不是children属性 Object.keys(element.props) .filter(isProperty) .forEach(name =&gt; &#123; dom[name] = element.props[name] &#125;)//将除了children属性的属性赋给节点 element.props.children.forEach(child =&gt; render(child, dom) ) container.appendChild(dom)&#125; 在大概讲了render和元素的一些基本概念后（突然感觉跑偏了好多），react元素之间通过父子的关系形成了数的结构。 在某一时间节点调用 React 的 render() 方法，会创建一棵由 React 元素组成的树。在下一次 state 或 props 更新时，相同的 render() 方法会返回一棵不同的树。React 需要基于这两棵树之间的差别来判断如何高效的更新 UI，以保证当前 UI 与最新的树保持同步。 此算法有一些通用的解决方案，即生成将一棵树转换成另一棵树的最小操作次数。然而，即使使用最优的算法，该算法的复杂程度仍为 O(n^3 )，其中 n 是树中元素的数量。 如果在 React 中使用该算法，那么展示 1000 个元素则需要 10 亿次的比较。这个开销实在是太过高昂。于是 React 在以下两个假设的基础之上提出了一套 O(n) 的启发式算法： 两个不同类型的元素会产生出不同的树； 开发者可以通过设置 key 属性，来告知渲染哪些子元素在不同的渲染下可以保存不变； 在实践中，我们发现以上假设在几乎所有实用的场景下都成立。 123456789101112131415// 第一次渲染ReactDOM.render( &lt;dialog&gt; &lt;input /&gt; &lt;/dialog&gt;, domContainer);// 下一次渲染ReactDOM.render( &lt;dialog&gt; &lt;p&gt;I was just added here!&lt;/p&gt; &lt;input /&gt; &lt;/dialog&gt;, domContainer); react会对比元素类型，dialog ==&gt; dialog不变，仅比对更新有改变的属性；input ==&gt; p 发生了改变。删掉原来的节点，新建新的节点。(nothing) ==&gt; input ：需要重新创建一个 input 宿主实例。 在现实写代码我们不会多次调用render，而是在p标签的位置做一些手脚。 而当遇到动态列表时，我们不能确定其中的顺序总是一成不变的。 12345678910111213function ShoppingList(&#123; list &#125;) &#123; return ( &lt;form&gt; &#123;list.map(item =&gt; ( &lt;p&gt; You bought &#123;item.name&#125; &lt;br /&gt; Enter how many do you want: &lt;input /&gt; &lt;/p&gt; ))&#125; &lt;/form&gt; )&#125; 如果我们的商品列表被重新排序了，React 只会看到所有的 p 以及里面的 input 拥有相同的类型，并不知道该如何移动它们。（在 React 看来，虽然这些商品本身改变了，但是它们的顺序并没有改变。） 所以 React 会对这十个商品进行类似如下的重排序： 12345for (let i = 0; i &lt; 10; i++) &#123; let pNode = formNode.childNodes[i]; let textNode = pNode.firstChild; textNode.textContent = 'You bought ' + items[i].name;&#125; React 只会对其中的每个元素进行更新而不是将其重新排序。这样做会造成性能上的问题和潜在的 bug 。例如，当商品列表的顺序改变时，原本在第一个输入框的内容仍然会存在于现在的第一个输入框中 — 尽管事实上在商品列表里它应该代表着其他的商品！ 这就是为什么每次当输出中包含元素数组时，React 都会让你指定一个叫做 key 的属性： 123456789101112function ShoppingList(&#123; list &#125;) &#123; return ( &lt;form&gt; &#123;list.map(item =&gt; ( &lt;p key=&#123;item.productId&#125;&gt; You bought &#123;item.name&#125; &lt;br /&gt; Enter how many do you want: &lt;input /&gt; &lt;/p&gt; ))&#125; &lt;/form&gt; )&#125; key 给予 React 判断子元素是否真正相同的能力，即使在渲染前后它在父元素中的位置不是相同的。 当 React 在 &lt;form&gt; 中发现 &lt;p key=&quot;42&quot;&gt; ，它就会检查之前版本中的 &lt;form&gt; 是否同样含有 &lt;p key=&quot;&quot;42&gt; 。即使 &lt;form&gt; 中的子元素们改变位置后，这个方法同样有效。在渲染前后当 key 仍然相同时，React 会重用先前的宿主实例，然后重新排序其兄弟元素。 需要注意的是 key 只与特定的父亲 React 元素相关联，比如 &lt;form&gt; 。React 并不会去匹配父元素不同但 key 相同的子元素。（React 并没有惯用的支持对在不重新创建元素的情况下让宿主实例在不同的父元素之间移动。） 给 key 赋予什么值最好呢？最好的答案就是：什么时候你会说一个元素不会改变即使它在父元素中的顺序被改变？ 例如，在我们的商品列表中，商品本身的 ID 是区别于其他商品的唯一标识，那么它就最适合作为 key 。 最后，你也可以使用元素在数组中的下标作为 key。这个策略在元素不进行重新排序时比较合适，如果有顺序修改，diff 就会变慢。 当基于下标的组件进行重新排序时，组件 state 可能会遇到一些问题。由于组件实例是基于它们的 key 来决定是否更新以及复用，如果 key 是一个下标，那么修改顺序时会修改当前的 key，导致非受控组件的 state（比如输入框）可能相互篡改，会出现无法预期的变动。","categories":[],"tags":[]},{"title":"React Redux","slug":"React Redux","date":"2021-09-22T02:40:58.104Z","updated":"2020-10-31T06:21:22.000Z","comments":true,"path":"2021/09/22/React Redux/","link":"","permalink":"http://yoursite.com/2021/09/22/React%20Redux/","excerpt":"","text":"Connect()Connect()是连接React和Redux store的函数。 它可以从Store当中拿出一些碎片的数据，传递给和它相连的组件。函数还可以发送一些action给Store。 它不会修改传递给它的组件类。而是返回一个新的，已连接的组件类，该类包含传入的组件。 1function connect(mapStateToProps?, mapDispatchToProps?, mergeProps?, options?) mapStateToProps和mapDispatchToProps分别处理的是Redux Store的state数据和dispatch方法。 函数返回的mapStateToProps和mapDispatchToProps分别指向组件内部的stateProps和dispatchProps。 connect() 参数connect 可以接受四个不同的参数, 全部都是可选的： mapStateToProps?: Function mapDispatchToProps?: Function | Object mergeProps?: Function options?: Object Connect: Extracting Data with mapStateToProps作为第一个传入connect的参数，mapStateToProps从Store选择一部分数据，传给需要的组件。 当store的state数据变化的时候会调用改函数。 它接受一整个store state，返回一个对象包含组件需要的数据。 定义 mapStateToPropsmapStateToProps应该被定义为一个函数： 1function mapStateToProps(state, ownProps?) 它应该接受一个名为state的第一个参数，可以选择一个称为ownProps的第二个参数，并返回一个包含连接组件所需数据的普通对象。 此函数应作为connect的第一个参数传递，并将在每次Redux存储状态更改时调用。如果您不想订阅存储，请传递null或undefined来代替mapStateToProps进行连接。 不管mapstatetops函数是使用function关键字（function mapState（state）{}）还是作为箭头函数（constmapstate=（state）=&gt;{}编写的，它的工作方式都是一样的。 Arguments state ownProps (可选的) statemapStateToProps函数的第一个参数是整个Redux存储状态（调用存储.getState()). 因此，第一个论点传统上被称为state。（虽然您可以给参数指定任何名称，但将其称为store是不正确的-它是“state value”，而不是“store instance”。） 至少state作为参数是应该被传入到mapStateToProps函数。 12345function mapStateToProps(state) &#123; const &#123; todos &#125; = state return &#123; todoList: todos.allIds &#125;&#125;export default connect(mapStateToProps)(TodoList) ownProps (optional)如果组件需要从自己的属性中获取数据来从存储中检索数据，则可以使用第二个参数ownProps定义函数。此参数将包含给connect生成的包装器组件的所有属性。 123456789101112function mapStateToProps(state, ownProps) &#123; const &#123; visibilityFilter &#125; = state const &#123; id &#125; = ownProps const todo = getTodoById(state, id) // component receives additionally: return &#123; todo, visibilityFilter &#125;&#125;// Later, in your application, a parent component renders:;&lt;ConnectedTodo id=&#123;123&#125; /&gt;// and your component receives props.id, props.todo, and props.visibilityFilter ReturnmapToProps函数应返回一个包含组件所需数据的纯对象： Each field in the object will become a prop for your actual component The values in the fields will be used to determine if your component needs to re-render 123456789function mapStateToProps(state) &#123; return &#123; a: 42, todos: state.todos, filter: state.visibilityFilter &#125;&#125;// component will receive: props.a, props.todos, and props.filter Usage Guidelines Let mapStateToProps Reshape the Data from the Store Use Selector Functions to Extract and Transform Data mapStateToProps Functions Should Be Fast mapStateToProps Functions Should Be Pure and Synchronous Connect: Dispatching Actions with mapDispatchToProps作为传递给connect的第二个参数，mapDispatchToProps用于将操作分派到存储区。 dispatch是Redux Store之中唯一的函数。我们只有调用store.dispatch去发送一个action。 使用React Redux，您的组件永远不会直接访问存储区—connect会为您执行此操作。React Redux为您提供了两种让组件分派操作的方法： By default, a connected component receives props.dispatch and can dispatch actions itself. connect can accept an argument called mapDispatchToProps, which lets you create functions that dispatch when called, and pass those functions as props to your component. Approaches for DispatchingDefault: dispatch as a Prop如果不指定connect（）的第二个参数，则默认情况下，组件将接收dispatch。例如： 123456789connect()(MyComponent)// which is equivalent withconnect( null, null)(MyComponent)// orconnect(mapStateToProps /** no second argument */)(MyComponent) 以这种方式连接组件后，组件将接收道具调度. 您可以使用它将操作分派到存储。 12345678910function Counter(&#123; count, dispatch &#125;) &#123; return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: 'DECREMENT' &#125;)&#125;&gt;-&lt;/button&gt; &lt;span&gt;&#123;count&#125;&lt;/span&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: 'INCREMENT' &#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: 'RESET' &#125;)&#125;&gt;reset&lt;/button&gt; &lt;/div&gt; )&#125; Providing A mapDispatchToProps Parameter提供mapDispatchToProps允许您指定哪一种的action需要被分派。它允许您提供action dispatch作为传参。因此，与其调用函数props.dispatch(()=&gt;increment())，可以调用直接调用prop.increment()。你可能想这么做有几个原因。 More Declarative首先，将dispatch逻辑封装到函数中使实现更具声明性。dispatch一个动作并让Redux存储处理数据流是如何实现行为的，而不是它做什么。 一个很好的例子是在单击按钮时dispatch操作。直接连接按钮在概念上可能没有意义，按钮引用dispatch也没有意义。 12345// button needs to be aware of \"dispatch\"&lt;button onClick=&#123;() =&gt; dispatch(&#123; type: \"SOMETHING\" &#125;)&#125; /&gt;// button unaware of \"dispatch\",&lt;button onClick=&#123;doSomething&#125; /&gt; 一旦您用dispatch动作的函数包装了所有action创建者，组件就不需要分派了。因此，如果您定义自己的mapDispatchToProps，则连接的组件将不再接收dispatch。 Pass Down Action Dispatching Logic to ( Unconnected ) Child Components此外，您还可以将操作分派函数传递给子（可能是未连接的）组件。这允许更多的组件分派动作，同时让它们“不知道”Redux。 123456789// pass down toggleTodo to child component// making Todo able to dispatch the toggleTodo actionconst TodoList = (&#123; todos, toggleTodo &#125;) =&gt; ( &lt;div&gt; &#123;todos.map(todo =&gt; ( &lt;Todo todo=&#123;todo&#125; onClick=&#123;toggleTodo&#125; /&gt; ))&#125; &lt;/div&gt;) 这就是React Redux的connect所做的——它封装了与Redux store对话的逻辑，让您不用担心它。这是你应该在你的实现中充分利用的。 Two Forms of mapDispatchToPropsmapDispatchToProps参数可以有两种形式。虽然函数形式允许更多的定制，但对象形式易于使用。 Function form: Allows more customization, gains access to dispatch and optionally ownProps Object shorthand form: More declarative and easier to use Defining mapDispatchToProps As A Function将mapDispatchToProps定义为一个函数，可以在自定义组件接收的函数以及它们如何分派操作方面提供最大的灵活性。你可以获得调度和拥有权。您可以利用这个机会编写自定义函数，以供连接的组件调用。 Arguments dispatch ownProps (optional) dispatch 将调用mapDispatchToProps函数，并将dispatch作为第一个参数。通常，通过返回在其内部调用dispatch()的新函数，并直接传入纯操作对象或传入操作创建者的结果来使用此方法。 12345678const mapDispatchToProps = dispatch =&gt; &#123; return &#123; // dispatching plain actions increment: () =&gt; dispatch(&#123; type: 'INCREMENT' &#125;), decrement: () =&gt; dispatch(&#123; type: 'DECREMENT' &#125;), reset: () =&gt; dispatch(&#123; type: 'RESET' &#125;) &#125;&#125; 您还可能希望将参数转发给action creator： 12345678910const mapDispatchToProps = dispatch =&gt; &#123; return &#123; // explicitly forwarding arguments onClick: event =&gt; dispatch(trackClick(event)), //trackClick() is an anction creator // implicitly forwarding arguments onReceiveImpressions: (...impressions) =&gt; dispatch(trackImpressions(impressions)) //trackImpressions() is also an anction creator &#125;&#125; ownProps ( optional ) 如果您的mapDispatchToProps函数被声明为接受两个参数，那么它将被调用，第一个参数是dispatch，传递给连接组件的属性作为第二个参数，并且在连接的组件接收到新的属性时将重新调用它。 这意味着，在组件重新呈现时，您可以在组件的属性发生更改时进行重新绑定，而不是在组件重新呈现时将新的属性重新绑定到action dispatchers。 Binds on component mount 123456789render() &#123; return &lt;button onClick=&#123;() =&gt; this.props.toggleTodo(this.props.todoId)&#125; /&gt;&#125;const mapDispatchToProps = dispatch =&gt; &#123; return &#123; toggleTodo: todoId =&gt; dispatch(toggleTodo(todoId)) &#125;&#125; Binds on props change 123456789render() &#123; return &lt;button onClick=&#123;() =&gt; this.props.toggleTodo()&#125; /&gt;&#125;const mapDispatchToProps = (dispatch, ownProps) =&gt; &#123; return &#123; toggleTodo: () =&gt; dispatch(toggleTodo(ownProps.todoId)) &#125;&#125; ReturnmapDispatchToProps函数应返回一个纯对象： Each field in the object will become a separate prop for your own component, and the value should normally be a function that dispatches an action when called. If you use action creators ( as oppose to plain object actions ) inside dispatch, it is a convention to simply name the field key the same name as the action creator: 123456789101112const increment = () =&gt; (&#123; type: 'INCREMENT' &#125;)const decrement = () =&gt; (&#123; type: 'DECREMENT' &#125;)const reset = () =&gt; (&#123; type: 'RESET' &#125;)const mapDispatchToProps = dispatch =&gt; &#123; return &#123; // dispatching actions returned by action creators increment: () =&gt; dispatch(increment()), decrement: () =&gt; dispatch(decrement()), reset: () =&gt; dispatch(reset()) &#125;&#125; mapDispatchToProps函数的返回将作为道具合并到连接的组件中。你可以直接调用他们，让他们dispatch action。 12345678910function Counter(&#123; count, increment, decrement, reset &#125;) &#123; return ( &lt;div&gt; &lt;button onClick=&#123;decrement&#125;&gt;-&lt;/button&gt; &lt;span&gt;&#123;count&#125;&lt;/span&gt; &lt;button onClick=&#123;increment&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;reset&#125;&gt;reset&lt;/button&gt; &lt;/div&gt; )&#125; Defining the mapDispatchToProps Function with bindActionCreators手动的将这些函数包装起来是可笑的，所以Redux提供了一个函数去简化。 bindActionCreators accepts two parameters: A function (an action creator) or an object (each field an action creator) dispatch bindActionCreators生成的包装器函数将自动转发它们的所有参数，因此您不需要手动执行此操作。 123456789101112131415161718192021import &#123; bindActionCreators &#125; from 'redux'const increment = () =&gt; (&#123; type: 'INCREMENT' &#125;)const decrement = () =&gt; (&#123; type: 'DECREMENT' &#125;)const reset = () =&gt; (&#123; type: 'RESET' &#125;)// binding an action creator// returns (...args) =&gt; dispatch(increment(...args))const boundIncrement = bindActionCreators(increment, dispatch)// binding an object full of action creatorsconst boundActionCreators = bindActionCreators( &#123; increment, decrement, reset &#125;, dispatch)// returns// &#123;// increment: (...args) =&gt; dispatch(increment(...args)),// decrement: (...args) =&gt; dispatch(decrement(...args)),// reset: (...args) =&gt; dispatch(reset(...args)),// &#125; To use bindActionCreators in our mapDispatchToProps function: 123456789101112import &#123; bindActionCreators &#125; from 'redux'// ...function mapDispatchToProps(dispatch) &#123; return bindActionCreators(&#123; increment, decrement, reset &#125;, dispatch)&#125;// component receives props.increment, props.decrement, props.resetconnect( null, mapDispatchToProps)(Counter) Manually Injecting dispatch如果提供了mapDispatchToProps参数，组件将不再接收默认分派。您可以通过手动将其添加到mapDispatchToProps的返回中来恢复它，尽管大多数情况下您不需要这样做： 123456789import &#123; bindActionCreators &#125; from 'redux'// ...function mapDispatchToProps(dispatch) &#123; return &#123; dispatch, ...bindActionCreators(&#123; increment, decrement, reset &#125;, dispatch) &#125;&#125; Defining mapDispatchToProps As An Object您已经看到，在React组件中调度Redux动作的设置过程非常相似：定义一个动作创建者，将其包装在另一个类似于的函数中(…args) =&gt; dispatch(actionCreator(…args))，并将该包装函数作为prop传递给您的组件。 因为这很普遍，所以connect支持参数的“对象简写”形式mapDispatchToProps：如果传递的对象中包含操作创建者而不是函数，connect则将bindActionCreators在内部自动调用您。 我们建议始终使用的“对象简写”形式mapDispatchToProps，除非您有特定的原因自定义调度行为。 注意： mapDispatchToProps假定对象的每个字段都是动作创建者 您的组件将不再dispatch作为道具接收 12// React Redux does this for you automatically:dispatch =&gt; bindActionCreators(mapDispatchToProps, dispatch) Therefore, our mapDispatchToProps can simply be: 12345const mapDispatchToProps = &#123; increment, decrement, reset&#125; Since the actual name of the variable is up to you, you might want to give it a name like actionCreators, or even define the object inline in the call to connect: 12345678910111213import &#123;increment, decrement, reset&#125; from \"./counterActions\";const actionCreators = &#123; increment, decrement, reset&#125;export default connect(mapState, actionCreators)(Counter);// orexport default connect( mapState, &#123; increment, decrement, reset &#125;)(Counter);","categories":[],"tags":[]},{"title":"鍓嶇","slug":"鍓嶇","date":"2021-09-22T02:40:56.450Z","updated":"2021-05-21T05:04:16.000Z","comments":true,"path":"2021/09/22/鍓嶇/","link":"","permalink":"http://yoursite.com/2021/09/22/%E9%8D%93%E5%B6%87%EE%81%AC/","excerpt":"","text":"这篇文章主要是来分享一下我这一年多时间以来在前端方面学习的方法和路径。 什么是前端？为用户提供可交互的可视化界面。在传统的MVC式的开发当中，M为Model模型，V为View视图，C为Controller控制器。而前后端分离之后，前端主要负责的是V视图的部分。而如今前端早已不再是只能开发web方向了，如今它也具有数据可视化，垮端技术，中后台技术等方向。 如何学习前端？其实如何前端这个话题和如何学习是一个道理，我们其实只要掌握了学习的方法，用来学习什么都。 独立解决问题的能力。 独立思考能力。 英语阅读能力。 独立解决问题主要在于怎么提高自己的搜商。在如今互联网发达的时代，很多东西都是可以自己找到问题的答案的。那么难点就在于如何抽象出来问题，和提炼搜索内容。同样的问题可能有不同的关键字那么出来的结果就可能不一样。 独立思考能力，这一点也不用多说，凡事只有自己多思考过了才能成为自己的东西。我们在除了光去查去看了之后也要多实践。有时候看了也只是看了，多动手去写写代码。 而英语阅读能力也很重要在于英文文献的阅读，有很多时候我们中文的搜索解决不了我们的问题，这个时候我们就可以用英文去搜索并且阅读英文的文献。再者国外很多技术都比国内发展更好一些，所以要了解比较新的技术也需要去阅读英文。 其实以上说的这些点也不局限于前端的学习，而更多是通用的现代学习方法。 前端三大基石HTML HTML的全称为超文本标记语言，是一种标记语言。它包括一系列标签．通过这些标签可以将网络上的文档格式统一，使分散的Internet资源连接为一个逻辑整体。HTML文本是由HTML命令组成的描述性文本，HTML命令可以说明文字，图形、动画、声音、表格、链接。 CSS 层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。 Javascript JavaScript（简称“JS”） 是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。虽然它是作为开发Web页面的脚本语言而出名，但是它也被用到了很多非浏览器环境中，JavaScript 基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如函数式编程）风格。 Javascript衍生的学习内容就十分的多，介于JavaScript的弱类型的语言，微软推出了对应的强类型语言TypeScript。 CSS的预处理的编译也有许多Less和SCSS都是可以去学一学，在开发更大型的项目的时候使用更好。 关于前端的框架来说，三大热门的框架React、Vue和Angular。这三个框架是基于Javascript的Web开发框架。了解这些内容之前我们应该要学习DOM和CSSOM等内容，Javascript是如何操控DOM元素的。 这里就又要问一个问题了，你们为什么学习前端？就业？写项目？感兴趣？ 为什么要问这个问题呢？其实就是一个时间成本的问题。其实大家在学了HTML之后，学习Vue要更容易上手，因为它的视图和模块区分的更明显，还有就是是它的开发团队当中有许多的中国人，中文文档阅读起来也是十分方便且中文文档的质量也十分的高。十分推荐只是用来写项目的同学去学习，相比于React框架来说时间成本要低很多。 那么更想以前端就业的同学来说学习React和Vue 也是都要去学习和了解的框架。React相对于Vue来说需要了解class组件和它对应的声明周期。当然在16年后？他们也推出了React Hooks。从class组件变成了函数组件。用函数的思想去写组件可以使更多的组件抽取更加容易。 除了基本的React和Vue框架，也有对应的包去学习。Router实现路由跳转，Redux实现状态的管理。在比较简单的项目当中，不推荐使用Redux。刚刚开始学习写项目时候，我不建议去使用别人写好的组件。例如Antd这个比较知名的阿里前端开发的开源组件库。 当我们需要开发小程序的时候推荐一些框架。Taro框架是现在可以支持React和Vue的开发一个比较丰富的框架。但是现在Taro框架还是不太稳定，bug还挺多的。 当然这里说的都是一些关于前端web开发的部分，在实现可视化和中后台的方面还没有特别深入了解，也就不好多说什么了。我也最近才刚刚开始学习nodejs一些简单的服务搭建的。 计算机基础计算机基础是一个要成为专业的程序猿必备的技能了，也不管你在哪个领域里面所需要知道和了解的。 第一个就是C语言的学习，了解到其实我们院20级的管工的同学并没有C语言这门课，还是推荐大家在学习数据结构的时候把C语言的结构体，指针等概念了解清楚。 数据结构和算法 数据结构也是比较基础的一门课，链表，队列，堆栈，数组，串，二叉树等概念是我们专业所学习的，但是还有像图等我们专业都不会讲解，可以看看熊回香老师的那本书，也是写的很好的。在加上算法，书里面讲到的比较基础的算法有查找和排序，查找有二分法，二叉排序树，嘻哈表。排序有直接插入，选择排序，推排序，冒泡排序，快速排序，归并排序，桶排序等。这些排序和查找最后考试也是都会考的。 我们专业在数据结构这方面出的代码设计题会比较简单，导致你不需要动手去实践已知的一些算法，可能只需要逻辑上理解就够了，而我们要知道逻辑上面的理解和能真正把代码写出来是两回事。我自己也是吃了这方面的亏，自己刷题的时候也是知道怎么去完成，但是代码多多少少都会出现一点bug。 虽然前端对算法的要求部不是特别高，但是也不是没有要求的，所以多刷题多总结就没什么错了。 计算机网络 计算机网络我们学院开设的课程主要集中于在应用层之下了，而我们实际的网络开发，更多的需要的知识是应用层的，http协议就是应用层的主要协议。这个大家可以看老师推荐的教材或者《图解HTTP》这本书。 剩余的操作系统和计算机组成原理里面，还是推荐大家可以多多学习操作系统，机组的话可能更多的偏向硬件一些，学起来可能回比较枯燥乏味。","categories":[],"tags":[]},{"title":"鑷€傚簲灞呬腑","slug":"鑷€傚簲灞呬腑","date":"2021-09-22T02:40:55.506Z","updated":"2019-11-08T07:51:08.000Z","comments":true,"path":"2021/09/22/鑷€傚簲灞呬腑/","link":"","permalink":"http://yoursite.com/2021/09/22/%E9%91%B7%EE%81%88%E2%82%AC%E5%82%9A%E7%B0%B2%E7%81%9E%E5%91%AC%E8%85%91/","excerpt":"","text":"关于网页布局中的水平垂直居中一、首先来分享最简单的flex布局中如何居中12345.father&#123; display: flex; justify-content: center;/*水平居中*/ align-items: center;/*垂直居中*/&#125; ​ 这里father指的是夫元素的盒子，对父元素进行设置display: flex;其中的子元素就会变成项目，父元素本身就成为了flex容器。利用flex的一些特性就可以进行居中的布局。 ​ 关于更详细的flex布局，这里有一个链接：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool 二、”display:inline-block”中如何实现居中123456.father&#123; text-align: center;/*水平居中*/&#125;.son&#123; display:inline-block;&#125; ​ 当block变成inline-block时，多个div在一个父元素的容器中，margin: 0 auto；就不再有作用。目前我找到的方法只有在父元素中设置text-align: center;使这些div居中。百度中这么解释到，“我们的行内元素就相当于一行之内的文字了”，我也只能这么理解了。对于div中的文字，我们只能再使用text-align: start；之类的属性来使文字排版更理想化。 1234567891011121314.father&#123; width:auto; height:200px;&#125;.father:after&#123; display:inline-block; height:100%; font-size:0; content: \"\";&#125;.son&#123; display:inline-block; vertical-align: middle;/*垂直居中*/&#125; ​ 这一串css代码是用来inline-block当中的垂直居中问题，可以用于head当中，因为大多时候head定宽，用一个伪元素设置其高度为100%时，将父元素撑开，子元素就垂直居中啦！也适用于多行文字！ 当然如果head之中只有一行文字，在父元素中设置height与line-height相等时，也可以垂直居中，只是会出现一些小问题。比如只是文字居中而div没有居中。（如果div高和head高不相等）三、“display：block”一个block的居中123.son&#123; margin: 0 auto;&#125; ​ 这一串代码十分简洁，十分容易记住，但是一定要找到使用场合。在一个父元素只有一个子元素时，此代码可以时该元素自适应的居中，比较常用于head套用，page整体布局中。 1234.father&#123; height:100px; line-height:100px;&#125; ​ 不多说了，注意只能用于单行文字。会使子元素高度变大。 四、“display: table”的居中1234567.father&#123; display:table;&#125;.son&#123; display:table-cell; vertical-align: middle;&#125; ​ 这种方法适用性不强，因为大多数display属性为block,inlin-block或者flex。再次使用display时可能会改变一些属性。 五、定位123456789101112131415.father&#123; width: 500px; height: 300px; position: relative;&#125;.son&#123; width: 100px; height: 100px; position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto;&#125; ​ 该方法用于son宽高已知！ 1234567891011.father&#123; width: 500px; height: 300px; position: relative;&#125;.son&#123; position: absolute; left: 50%; top: 50%; transform: translateX(-50%) translateY(-50%);&#125; ​ 该方法用于son宽高未知！ 总的来说自适应居中的方法就这些了，如果想看到更多的居中方式可以点击这里访问李雪莲学姐做的总结！！ https://lilixuelian.github.io/2019/05/22/center/","categories":[],"tags":[]},{"title":"闃叉姈鑺傛祦","slug":"闃叉姈鑺傛祦","date":"2021-09-22T02:40:54.562Z","updated":"2021-05-27T14:53:50.000Z","comments":true,"path":"2021/09/22/闃叉姈鑺傛祦/","link":"","permalink":"http://yoursite.com/2021/09/22/%E9%97%83%E5%8F%89%E5%A7%88%E9%91%BA%E5%82%9B%E7%A5%A6/","excerpt":"","text":"​ 其实在了解防抖和节流的作用是什么了之后就实现起来会比较容易 防抖防抖是防止短时间内一直调用一个函数，在n秒后执行函数，在n秒内多次触发事件，则重新开始计时。 1234567891011121314151617181920let request = (val) =&gt; &#123; console.log(\"request: \" + val);&#125;function debounce(fn, delay)&#123; let timeout; return function() &#123; clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; fn.apply(this, arguments); &#125;, delay); &#125;&#125;let inputEle = document.getElementById(\"input\");let debounceInput = debounce(request, 500);inputEle.addEventListener(\"keyup\", function(e)&#123; debounceInput(e.target.value);&#125;); 节流在规定时间内，函数只执行一次，在单位时间内触发多次也执行一次。 12345678910111213141516let request = (val) =&gt; &#123; console.log(\"request: \" + val);&#125;function throttle(fn, delay)&#123; let timer; return function()&#123; if(!timer) &#123; fn.apply(this,arguments); timer = setTimeout(()=&gt;&#123; clearTimeout(timer); time = null; &#125;,delay) &#125; &#125;&#125; 然而让我考虑了好久这里为什么要使用apply方法去执行。我查到的原因就是因为request函数的参数个数未知性，应该直接传入arguments的参数对象。还可以改成fn(…arguments)。","categories":[],"tags":[]},{"title":"瀛ょ嫭鏄熺悆--Taro妗嗘灦鎬荤粨","slug":"瀛ょ嫭鏄熺悆--Taro妗嗘灦鎬荤粨","date":"2021-09-22T02:40:51.485Z","updated":"2020-04-01T17:02:38.000Z","comments":true,"path":"2021/09/22/瀛ょ嫭鏄熺悆--Taro妗嗘灦鎬荤粨/","link":"","permalink":"http://yoursite.com/2021/09/22/%E7%80%9B%E3%82%87%E5%AB%AD%E9%8F%84%E7%86%BA%E6%82%86--Taro%E5%A6%97%E5%97%98%E7%81%A6%E9%8E%AC%E8%8D%A4%E7%B2%A8/","excerpt":"","text":"孤独星球–Taro框架总结​ 大一下学期用Taro框架写了QQ的小程序–孤独星球，项目链接在这里。https://github.com/The-Planet-of-Loneline/project ​ 项目分为白天和黑夜两个部分，白天是同组的刘安完成的，技术含量也比较高；黑夜和登录部分就是由我完成的。接下来就说一下Taro里面的一些细节。 一、项目结构​ 因为一开始没有去参照学姐学长做的客栈的框架，所以这个项目的框架比较乱，一些组件的页面的位置也存放的不正确。希望以后的项目能够把公共组件和私有组件分开，组件和页面分开以形成更明晰的结构。以下是参照木犀客栈的结构： 123456789101112131415--src --assets //存放图片 --png --svg --components //存放组件 --common //公用组件 --index //私有组件 --pages //页面 --index --index.jsx --service //Fech API --Fech.jsx --app.jsx //配置 --app.scss //样式 --index.html //接口 一般来说一个项目的结构就如上所示了。 二、Taro内置组件​ 刚刚开始写静态页面的时候使用错了组件，还是用的HTML的标签&lt;div&gt; &lt;span&gt;等。要注意以下代码的含义： 12import Taro, &#123; Component &#125; from '@tarojs/taro'import &#123; View, Text,Image &#125; from '@tarojs/components' ​ Taro里面有内置的组件使用，&lt;View&gt; &lt;Text&gt;等类似于HTML中的标签使用。要注意的是，HTML中使用的class选择器，class关键字要改变成classname，因为关键字的保留class类。 这里的import也是webpack的方法吧，引入你需要的组件例如黑夜的头部和底部： 12import Head from '../component/Head'import Footer from '../component/Footer' 一定要from正确的路径&#39;../&#39;是返回上一级目录，也可以返回多次。 三、Taro中的输入框​ Taro中的输入框也是Taro当中的内置组件也分为input和textarea，但是要大写&lt;Input /&gt; &lt;Textarea /&gt;，这里顺便提一下Taro里面所有组件开头都要大写。 ​ 输入框输入值的时候value要空，且还有监听事件函数onInput，onChange也可以。但是比较坑的事，onInput函数对于Input和Textarea不同。当时产品组给我提的要求是控制行数限制，这里也要说一下Textarea的特性，有换行的监听函数。但是由于onInput对于Textarea的value的改变不能显示于Textarea，而可以显示于Input。最后也是需求改成了字数限制。 12345678910&lt;Textarea className='write' value=&#123;Value&#125; onInput=&#123;this.handleInputChange.bind(this)&#125; onFocus=&#123;this.handleInput.bind(this)&#125;onBlur=&#123;this.handleback.bind(this)&#125; showConfirmBar=&#123;false&#125;maxlength=&#123;75&#125;autoFocus=&#123;true&#125;&gt;&lt;/Textarea&gt; ​ 组件的写法可以这样换行以更醒目的看见，太长不方便查看。但是一些View好像就不行。 四、API​ 写整个项目前最重要的就是沟通，和产品沟通和后端沟通。没有沟通好的后果就是白天好像重新写页面的结构。还好因为黑夜也不难，所以没有做好沟通也影响不大。其中我觉得比较重要的是分页这个部分。因为要考虑到页面的实际需求来看分页的形式和需不需要分页。参考swaggerUI是一个很重要的东西，一定要反复比对。 123456789101112131415onReachBottom()&#123; if (this.state.history.length % 5 == 0) &#123; this.setState(&#123; page: this.state.page + 1 &#125;, () =&gt; &#123; Fetch(`secret/history?page=$&#123;this.state.page&#125;`, &#123;&#125;, 'GET').then(res =&gt; &#123; this.setState(&#123; history: this.state.history.concat(res.history) &#125;) &#125;) &#125;) &#125;&#125; ​ 这里是一个后端的分页方法，需要的事我每一次请求时发送一个页面数字给后端，他再返回给我对应数字的内容。这种分页方法个人感觉比较适合网页，而不适合小程序去写。所以我加了限定条件只有显示内容为5个时候才会进行下一次的请求。 ​ API的路径一定要对，我举例困扰我很久的删除功能。 1234567891011121314handleDelete()&#123; Fetch(`secret/delete/:secret_id/?secretId=$&#123;this.props.Debunkid&#125;`, &#123;&#125;, 'DELETE').then(res =&gt; &#123; Taro.showToast(&#123; title: '删除成功', icon: 'none' &#125;) this.props.onCloseDelete() Taro.reLaunch(&#123; url:`/pages/Mine/Mine` &#125;) &#125;) &#125; ​ 这里因为我少了一个/导致我应该不能与后端连接，但是开发者工具可以我也就没有想太多。牢记！！ 五、QQ授权和分享​ QQ授权和分享是要过审核必须写的一个API，我们也是事后才写的。 1&lt;Button open-type='getUserInfo' className='login' onClick=&#123;this.power&#125;&gt;登录&lt;/Button&gt; 12345678910power () &#123; Taro.getSetting(&#123; success: (res) =&gt; &#123; this.setState(&#123; powered:res.authSetting['scope.userInfo']&#125;) if (res.authSetting['scope.userInfo']) &#123; this.onHandleLogin() &#125; &#125; &#125;) &#125; 123Taro.showShareMenu(&#123; showShareItems: ['qq', 'qzone', 'wechatFriends', 'wechatMoment'] &#125;) 第一二个代码块是处理授权的部分，第三个是分享。","categories":[],"tags":[]},{"title":"瀛﹁€岄〉闈㈡€荤粨","slug":"瀛﹁€岄〉闈㈡€荤粨","date":"2021-09-22T02:40:49.072Z","updated":"2019-11-08T13:36:08.000Z","comments":true,"path":"2021/09/22/瀛﹁€岄〉闈㈡€荤粨/","link":"","permalink":"http://yoursite.com/2021/09/22/%E7%80%9B%EF%B9%81%E2%82%AC%E5%B2%84%E3%80%89%E9%97%88%E3%88%A1%E2%82%AC%E8%8D%A4%E7%B2%A8/","excerpt":"","text":"关于HTML和CSS的总结在这两周时间，我写了静态的学而网页并进行了一些修改。在学姐学长的帮助和指导之下，我对网页的一些整体布局有所了解，以下为一些自己在写学而时犯下的错误。HEADER PART1.布局方式不要混用（其实适用于很多地方），flex inline-block 和float最好不要混合使用。 2.尽量减少div的使用。学会思考span和div的使用情况。span作为行内元素，可以用来标记一些行内特殊的元素；div作为块元素，更好的区分出每一个区域。有时候会用很多个div，变成inline-block的样子是因为在行内中出现了不同的功能区。 3.消除间隙。由于行内元素都是有间隙的所以一般需要消除间隙，例如图片与搜索框之间。 4.搜索框的写法，一般是用一个大的div把input和图片包裹起来，设置div的border的颜色来展示边框。 5.实现:hover之后，要确保前后元素的大小一致，这样才美观。 MIDDLE PART1.整体布局，用一个div来使多个中间部分水平居中。 2.在整个页面中最好只采取一种布局方式。 3.position：sticky可以适用于更多的场合，也更符合如今的审美需求。 4.input的样式用CSS来改变 FOOTER PART1.注意字符间距 2.body的margin为0或者padding为0；","categories":[],"tags":[]},{"title":"React Hook","slug":"React Hook","date":"2021-09-22T02:40:43.043Z","updated":"2020-09-16T06:52:58.000Z","comments":true,"path":"2021/09/22/React Hook/","link":"","permalink":"http://yoursite.com/2021/09/22/React%20Hook/","excerpt":"","text":"React Hook📌 State Hook“Hook是react 16.8的新增特性。它可以让你在不编写class的情况下使用state。”这是React官网 对Hook最直接的解释。不使用class而是普通的函数去封装组件或者页面。 123456789101112131415import React, &#123; useState &#125; from 'react';function Example() &#123; // 声明一个新的叫做 “count” 的 state 变量 const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 这里我们引入并解构出useState方法来声明一个Hook当中的state变量。 const [count, setCount] = useState(0);这一个语句中useState的唯一参数为声明的state的初始值，例如这里的count为一个数字，并且初始值为0。setCount则像setState方法一样去改变state的值。 useState 方法的返回值是什么？ 返回值为：当前 state 以及更新 state 的函数。这就是我们写 const [count, setCount] = useState() 的原因。这与 class 里面 this.state.count 和 this.setState 类似，唯一区别就是你需要成对的获取它们。 下面展示同一个class封装的组件。 12345678910111213141516171819202122class Example extends React.Component&#123; constructor()&#123; super(); this.state = &#123; count: 0 &#125; &#125; click() &#123; const &#123;count&#125; = this.state this.setState(&#123; count: count + 1 &#125;); &#125; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;this.click.bind(this)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ); &#125; 大体来说两者可以完成同一个功能就是记下按钮被点击的次数。我们可以明显观察到hook的使用变量的改变和显示都比class要简单很多。 声明多个state变量1234567function ExampleWithManyStates() &#123; // 声明多个 state 变量！ const [age, setAge] = useState(42); const [fruit, setFruit] = useState('banana'); const [todos, setTodos] = useState([&#123; text: 'Learn Hooks' &#125;]); // ...&#125; 那么，什么是 Hook?Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。Hook 不能在 class 组件中使用 —— 这使得你不使用 class 也能使用 React。 React 内置了一些像 useState 这样的 Hook。你也可以创建你自己的 Hook 来复用不同组件之间的状态逻辑。我们会先介绍这些内置的 Hook。 ⚡️ Effect Hook你之前可能已经在 React 组件中执行过数据获取、订阅或者手动修改过 DOM。我们统一把这些操作称为“副作用”，或者简称为“作用”。 useEffect 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 具有相同的用途，只不过被合并成了一个 API。 1234567891011121314151617181920import React, &#123; useState, useEffect &#125; from 'react';function Example() &#123; const [count, setCount] = useState(0); // 相当于 componentDidMount 和 componentDidUpdate: useEffect(() =&gt; &#123; // 使用浏览器的 API 更新页面标题 document.title = `You clicked $&#123;count&#125; times`; &#125;); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 12345678910111213141516171819202122232425262728class Example extends React.Component&#123; constructor()&#123; super(); this.state = &#123; count: 0 &#125; &#125; componentDidMount()&#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125; componentDidUpdate()&#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125; click() &#123; const &#123;count&#125; = this.state this.setState(&#123; count: count + 1 &#125;); &#125; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;this.click.bind(this)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ); &#125; 当你调用 useEffect 时，就是在告诉 React 在完成对 DOM 的更改后运行你的“副作用”函数。由于副作用函数是在组件内声明的，所以它们可以访问到组件的 props 和 state。默认情况下，React 会在每次渲染后调用副作用函数 —— 包括第一次渲染的时候。(useEffect会在每一次页面渲染时调用。) 副作用函数还可以通过返回一个函数来指定如何“清除”副作用。例如，在下面的组件中使用副作用函数来订阅好友的在线状态，并通过取消订阅来进行清除操作： 123456789101112131415161718192021import React, &#123; useState, useEffect &#125; from 'react';function FriendStatus(props) &#123; const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;; &#125;); if (isOnline === null) &#123; return 'Loading...'; &#125; return isOnline ? 'Online' : 'Offline';&#125; 在这个示例中，React 会在组件销毁时取消对 ChatAPI 的订阅，然后在后续渲染时重新执行副作用函数。 12345678....componentDidMount()&#123; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);&#125;componentWillUnmount()&#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);&#125;.... 通过跳过 Effect 进行性能优化在某些情况下，每次渲染后都执行清理或者执行 effect 可能会导致性能问题。在 class 组件中，我们可以通过在 componentDidUpdate 中添加对 prevProps 或 prevState 的比较逻辑解决： 12345componentDidUpdate(prevProps, prevState) &#123; if (prevState.count !== this.state.count) &#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125;&#125; 这是很常见的需求，所以它被内置到了 useEffect 的 Hook API 中。如果某些特定值在两次重渲染之间没有发生变化，你可以通知 React 跳过对 effect 的调用，只要传递数组作为 useEffect 的第二个可选参数即可： 123useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`;&#125;, [count]); // 仅在 count 更改时更新 上面这个示例中，我们传入 [count] 作为第二个参数。这个参数是什么作用呢？如果 count 的值是 5，而且我们的组件重渲染的时候 count 还是等于 5，React 将对前一次渲染的 [5] 和后一次渲染的 [5] 进行比较。因为数组中的所有元素都是相等的(5 === 5)，React 会跳过这个 effect，这就实现了性能的优化。 当渲染时，如果 count 的值更新成了 6，React 将会把前一次渲染时的数组 [5] 和这次渲染的数组 [6] 中的元素进行对比。这次因为 5 !== 6，React 就会再次调用 effect。如果数组中有多个元素，即使只有一个元素发生变化，React 也会执行 effect。 对于有清除操作的 effect 同样适用： 12345678910useEffect(() =&gt; &#123; function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;;&#125;, [props.friend.id]); // 仅在 props.friend.id 发生变化时，重新订阅 未来版本，可能会在构建时自动添加第二个参数。 ✌️ Hook 使用规则Hook 就是 JavaScript 函数，但是使用它们会有两个额外的规则： 只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用。 只能在 React 的函数组件中调用 Hook。不要在其他 JavaScript 函数中调用。（还有一个地方可以调用 Hook —— 就是自定义的 Hook 中，我们稍后会学习到。） React 的函数组件是这样的： 1234const Example = (props) =&gt; &#123; // 你可以在这使用 Hook return &lt;div /&gt;;&#125; 或是这样： 1234function Example(props) &#123; // 你可以在这使用 Hook return &lt;div /&gt;;&#125; 你之前可能把它们叫做“无状态组件”。但现在我们为它们引入了使用 React state 的能力，所以我们更喜欢叫它”函数组件”。 Hook 在 class 内部是不起作用的。但你可以使用它们来取代 class 。 💡 自定义 Hook前面，我们介绍了一个叫 FriendStatus 的组件，它通过调用 useState 和 useEffect 的 Hook 来订阅一个好友的在线状态。假设我们想在另一个组件里重用这个订阅逻辑。 首先，我们把这个逻辑抽取到一个叫做 useFriendStatus 的自定义 Hook 里： 123456789101112131415161718import React, &#123; useState, useEffect &#125; from 'react';function useFriendStatus(friendID) &#123; const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange); &#125;; &#125;); return isOnline;&#125; 它将 friendID 作为参数，并返回该好友是否在线： 现在我们可以在两个组件中使用它： 1234567891011121314151617function FriendStatus(props) &#123; const isOnline = useFriendStatus(props.friend.id); if (isOnline === null) &#123; return 'Loading...'; &#125; return isOnline ? 'Online' : 'Offline';&#125;function FriendListItem(props) &#123; const isOnline = useFriendStatus(props.friend.id); return ( &lt;li style=&#123;&#123; color: isOnline ? 'green' : 'black' &#125;&#125;&gt; &#123;props.friend.name&#125; &lt;/li&gt; );&#125; 每个组件间的 state 是完全独立的。Hook 是一种复用状态逻辑的方式，它不复用 state 本身。事实上 Hook 的每次调用都有一个完全独立的 state —— 因此你可以在单个组件中多次调用同一个自定义 Hook。 自定义 Hook 更像是一种约定而不是功能。如果函数的名字以 “use” 开头并调用其他 Hook，我们就说这是一个自定义 Hook。","categories":[],"tags":[]},{"title":"JS Chapter 6","slug":"JS Chapter 6","date":"2021-09-22T02:34:07.946Z","updated":"2020-07-11T08:40:06.000Z","comments":true,"path":"2021/09/22/JS Chapter 6/","link":"","permalink":"http://yoursite.com/2021/09/22/JS%20Chapter%206/","excerpt":"","text":"Generator先看三段代码 12345678try&#123; var ninjas = syncGetJSON(\"ninjas.json\"); var missions = syncGetJSON(ninjas[0].missionsUrl); var missionDetails = syncGetJSON(mission[0].detailsUrl); //Study the mission description&#125;catch(e)&#123; //Oh no, we weren't able to get the mission details&#125; 12345678910111213141516171819getJSON(\"ninjas.json\",function(err,ninjas)&#123; if(err)&#123; console.log(\"Error fetching list of ninjas\",err); return; &#125; getJSON(ninjas[0].missionsUrl,function(err,missions)&#123; if(err)&#123; console.log(\"Error locating ninja missions\",err); return; &#125; getJSON(mission[0].detailsUrl,function(err,missionDetails)&#123; if(err)&#123; console.log(\"Error locating mission details\",err); return; &#125; //Study the intel plan &#125;); &#125;);&#125;); 12345678910async(function*()&#123; try&#123; var ninjas = syncGetJSON(\"ninjas.json\"); var missions = syncGetJSON(ninjas[0].missionsUrl); var missionDetails = syncGetJSON(mission[0].detailsUrl); //Study the mission description&#125;catch(e)&#123; //Oh no, we weren't able to get the mission details &#125;&#125;) 第一段代码问题：从服务器获得数据是一个长期运行的操作，因为JavaScript是依赖单线程模式，我们会锁住我们的UI直到这整个代码运行结束。这导致了无法反应的应用和使用户失望。 1234567891011function* WeaponGenerator()&#123; yield \"Katana\"; yield \"Wakizashi\";&#125;const weaponsIterator = WeaponGenerator();const result1 = weaponsIterator.next();assert(typeof result1 === \"object\" &amp;&amp; result1.value === \"katana\" &amp;&amp; !result1.done,\"Katana recevied!\");const result2 = weaponsIterator.next();assert(typeof result2 === \"object\" &amp;&amp; result2.value === \"wakizashi\" &amp;&amp; !result2.done,\"wakizashi recevied!\");const result3 = weaponsIterator.next();assert(typeof result3 === \"object\" &amp;&amp; result3.value === undefined &amp;&amp; result3.done,\"There are no more results!\"); WeaponGenerator是构造器，weaponsIterator.next()会返回一个对象，如果传入值则yield被替换为改值，对象有两个属性value和done，当第三次返回对象时done的值为true。 123456789101112function* WarriorGenerator()&#123; yield \"Katana\"; yield* NinjaGenerator(); yield \"Wakizashi\";&#125;function* NinjaGenerator()&#123; yield \"Hattori\"; yield \"Yoshi\";&#125;for(let warrior of WarriorGenerator())&#123; assert(warrior !== null, warrior);&#125; 类似于链表的结构。 12345678910111213function* NinjaGenerator()&#123; try&#123; yield \"Hattori\"; fail(\"The expected exception didn't occur\"); &#125; catch(e)&#123; assert(e === \"Catch this!\",\"Aha! We caught an exception\"); &#125;&#125;const ninjaIterator = NinjaGenrator();const result1 = ninjaIterator().next();assert(result1.value === \"Hattori\", \"We got Hattori\");ninjaIterator.throw(\"Catch this!\"); 这里是说有throw这个方法 12345678910function* NinjaGenerator(action)&#123; const imposter = yield (\"Hattori\" + action); assert(imposter === \"Hanzo\",\"The generator has been infiltrated\"); yield (\"Yoshi (\" + imposter + \") \" + action);&#125;const ninjaIterator = NinjaGenerator(\"skulk\");const result1 = ninjaIterator.next();assert(result1.value === \"Hattori skulk\", \"Hattori is skulking\");const result2 = ninjaIterator.next(\"Hanzo\");assert(result2.value === \"Yoshi (Hanzo) skulk\", \"We have an imposter!\"); Promise来搬一个别人的博客https://www.jianshu.com/p/1b63a13c2701","categories":[],"tags":[]},{"title":"Redux","slug":"Redux","date":"2021-09-22T02:34:07.891Z","updated":"2020-10-26T08:07:08.000Z","comments":true,"path":"2021/09/22/Redux/","link":"","permalink":"http://yoursite.com/2021/09/22/Redux/","excerpt":"","text":"Redux什么时候需要 Redux首先明确一点，Redux 是一个有用的架构，但不是非用不可。事实上，大多数情况，你可以不用它，只用 React 就够了。 简单说，如果你的UI层非常简单，没有很多互动，Redux 就是不必要的，用了反而增加复杂性。Redux 的适用场景：多交互、多数据源。 从组件角度看，如果你的应用有以下场景，可以考虑使用 Redux。 某个组件的状态，需要共享 某个状态需要在任何地方都可以拿到 一个组件需要改变全局状态 一个组件需要改变另一个组件的状态 基本概念和 APIStoreStore 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。 Redux 提供createStore这个函数，用来生成 Store。 12import &#123; createStore &#125; from 'redux';const store = createStore(fn); 上面代码中，createStore函数接受另一个函数作为参数，返回新生成的 Store 对象。 StateStore对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。 当前时刻的 State，可以通过store.getState()拿到。 1234import &#123; createStore &#125; from 'redux';const store = createStore(fn);const state = store.getState(); Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。 ActionState 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。 Action 是一个对象。其中的type属性是必须的，表示 Action 的名称。 1234const action = &#123; type: 'ADD_TODO', payload: 'Learn Redux'&#125;; 上面代码中，Action 的名称是ADD_TODO，它携带的信息是字符串Learn Redux。 可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。 Action CreatorView 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator。 12345678910const ADD_TODO = '添加 TODO';function addTodo(text) &#123; return &#123; type: ADD_TODO, text &#125;&#125;const action = addTodo('Learn Redux'); 上面代码中，addTodo函数就是一个 Action Creator。 store.dispatch()store.dispatch()是 View 发出 Action 的唯一方法。 1234567import &#123; createStore &#125; from 'redux';const store = createStore(fn);store.dispatch(&#123; type: 'ADD_TODO', payload: 'Learn Redux'&#125;); 上面代码中，store.dispatch接受一个 Action 对象作为参数，将它发送出去。 结合 Action Creator，这段代码可以改写如下。 1store.dispatch(addTodo('Learn Redux')); ReducerStore 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。 Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。 1234const reducer = function (state, action) &#123; // ... return new_state;&#125;; 整个应用的初始状态，可以作为 State 的默认值。下面是一个实际的例子。 1234567891011121314const defaultState = 0;const reducer = (state = defaultState, action) =&gt; &#123; switch (action.type) &#123; case 'ADD': return state + action.payload; default: return state; &#125;&#125;;const state = reducer(1, &#123; type: 'ADD', payload: 2&#125;); 上面代码中，reducer函数收到名为ADD的 Action 以后，就返回一个新的 State，作为加法的计算结果。其他运算的逻辑（比如减法），也可以根据 Action 的不同来实现。 实际应用中，Reducer 函数不用像上面这样手动调用，store.dispatch方法会触发 Reducer 的自动执行。为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入createStore方法。 12import &#123; createStore &#125; from 'redux';const store = createStore(reducer); 上面代码中，createStore接受 Reducer 作为参数，生成一个新的 Store。以后每当store.dispatch发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State。 为什么这个函数叫做 Reducer 呢？因为它可以作为数组的reduce方法的参数。请看下面的例子，一系列 Action 对象按照顺序作为一个数组。 1234567const actions = [ &#123; type: 'ADD', payload: 0 &#125;, &#123; type: 'ADD', payload: 1 &#125;, &#123; type: 'ADD', payload: 2 &#125;];const total = actions.reduce(reducer, 0); // 3 上面代码中，数组actions表示依次有三个 Action，分别是加0、加1和加2。数组的reduce方法接受 Reducer 函数作为参数，就可以直接得到最终的状态3。 纯函数什么是纯函数？https://www.jianshu.com/p/a5a6d4399d69 由于 Reducer 是纯函数，就可以保证同样的State，必定得到同样的 View。但也正因为这一点，Reducer 函数里面不能改变 State，必须返回一个全新的对象，请参考下面的写法。 1234567891011// State 是一个对象function reducer(state, action) &#123; return Object.assign(&#123;&#125;, state, &#123; thingToChange &#125;); // 或者 return &#123; ...state, ...newState &#125;;&#125;// State 是一个数组function reducer(state, action) &#123; return [...state, newItem];&#125; 最好把 State 对象设成只读。你没法改变它，要得到新的 State，唯一办法就是生成一个新对象。这样的好处是，任何时候，与某个 View 对应的 State 总是一个不变的对象。 store.subscribe()Store 允许使用store.subscribe方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。 1234import &#123; createStore &#125; from 'redux';const store = createStore(reducer);store.subscribe(listener); 显然，只要把 View 的更新函数（对于 React 项目，就是组件的render方法或setState方法）放入listen，就会实现 View 的自动渲染。 store.subscribe方法返回一个函数，调用这个函数就可以解除监听。 12345let unsubscribe = store.subscribe(() =&gt; console.log(store.getState()));unsubscribe(); Store 的实现上一节介绍了 Redux 涉及的基本概念，可以发现 Store 提供了三个方法。 store.getState() store.dispatch() store.subscribe() 12import &#123; createStore &#125; from 'redux';let &#123; subscribe, dispatch, getState &#125; = createStore(reducer); createStore方法还可以接受第二个参数，表示 State 的最初状态。这通常是服务器给出的。 1let store = createStore(todoApp, window.STATE_FROM_SERVER) 上面代码中，window.STATE_FROM_SERVER就是整个应用的状态初始值。注意，如果提供了这个参数，它会覆盖 Reducer 函数的默认初始值。 下面是createStore方法的一个简单实现，可以了解一下 Store 是怎么生成的。 12345678910111213141516171819202122const createStore = (reducer) =&gt; &#123; let state; let listeners = []; const getState = () =&gt; state; const dispatch = (action) =&gt; &#123; state = reducer(state, action); listeners.forEach(listener =&gt; listener()); &#125;; const subscribe = (listener) =&gt; &#123; listeners.push(listener); return () =&gt; &#123; listeners = listeners.filter(l =&gt; l !== listener); &#125; &#125;; dispatch(&#123;&#125;); return &#123; getState, dispatch, subscribe &#125;;&#125;; Reducer 的拆分Reducer 函数负责生成 State。由于整个应用只有一个 State 对象，包含所有数据，对于大型应用来说，这个 State 必然十分庞大，导致 Reducer 函数也十分庞大。 请看下面的例子。 123456789101112131415161718const chatReducer = (state = defaultState, action = &#123;&#125;) =&gt; &#123; const &#123; type, payload &#125; = action; switch (type) &#123; case ADD_CHAT: return Object.assign(&#123;&#125;, state, &#123; chatLog: state.chatLog.concat(payload) &#125;); case CHANGE_STATUS: return Object.assign(&#123;&#125;, state, &#123; statusMessage: payload &#125;); case CHANGE_USERNAME: return Object.assign(&#123;&#125;, state, &#123; userName: payload &#125;); default: return state; &#125;&#125;; 上面代码中，三种 Action 分别改变 State 的三个属性。 ADD_CHAT：chatLog属性 CHANGE_STATUS：statusMessage属性 CHANGE_USERNAME：userName属性 这三个属性之间没有联系，这提示我们可以把 Reducer 函数拆分。不同的函数负责处理不同属性，最终把它们合并成一个大的 Reducer 即可。 1234567const chatReducer = (state = defaultState, action = &#123;&#125;) =&gt; &#123; return &#123; chatLog: chatLog(state.chatLog, action), statusMessage: statusMessage(state.statusMessage, action), userName: userName(state.userName, action) &#125;&#125;; 上面代码中，Reducer 函数被拆成了三个小函数，每一个负责生成对应的属性。 这样一拆，Reducer 就易读易写多了。而且，这种拆分与 React 应用的结构相吻合：一个 React 根组件由很多子组件构成。这就是说，子组件与子 Reducer 完全可以对应。 Redux 提供了一个combineReducers方法，用于 Reducer 的拆分。你只要定义各个子 Reducer 函数，然后用这个方法，将它们合成一个大的 Reducer。 123456789import &#123; combineReducers &#125; from 'redux';const chatReducer = combineReducers(&#123; chatLog, statusMessage, userName&#125;)export default todoApp; 上面的代码通过combineReducers方法将三个子 Reducer 合并成一个大的函数。 这种写法有一个前提，就是 State 的属性名必须与子 Reducer 同名。如果不同名，就要采用下面的写法。 1234567891011121314const reducer = combineReducers(&#123; a: doSomethingWithA, b: processB, c: c&#125;)// 等同于function reducer(state = &#123;&#125;, action) &#123; return &#123; a: doSomethingWithA(state.a, action), b: processB(state.b, action), c: c(state.c, action) &#125;&#125; 总之，combineReducers()做的就是产生一个整体的 Reducer 函数。该函数根据 State 的 key 去执行相应的子 Reducer，并将返回结果合并成一个大的 State 对象。 计数器下面我们来看一个最简单的实例。 12345678910111213const Counter = (&#123; value &#125;) =&gt; ( &lt;h1&gt;&#123;value&#125;&lt;/h1&gt;);const render = () =&gt; &#123; ReactDOM.render( &lt;Counter value=&#123;store.getState()&#125;/&gt;, document.getElementById('root') );&#125;;store.subscribe(render);render 上面是一个简单的计数器，唯一的作用就是把参数value的值，显示在网页上。Store 的监听函数设置为render，每次 State 的变化都会导致网页重新渲染。 下面加入一点变化，为Counter添加递增和递减的 Action。 12345678910111213141516171819202122232425262728293031const Counter = (&#123; value, onIncrement, onDecrement &#125;) =&gt; ( &lt;div&gt; &lt;h1&gt;&#123;value&#125;&lt;/h1&gt; &lt;button onClick=&#123;onIncrement&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;onDecrement&#125;&gt;-&lt;/button&gt; &lt;/div&gt;);const reducer = (state = 0, action) =&gt; &#123; switch (action.type) &#123; case 'INCREMENT': return state + 1; case 'DECREMENT': return state - 1; default: return state; &#125;&#125;;const store = createStore(reducer);const render = () =&gt; &#123; ReactDOM.render( &lt;Counter value=&#123;store.getState()&#125; onIncrement=&#123;() =&gt; store.dispatch(&#123;type: 'INCREMENT'&#125;)&#125; onDecrement=&#123;() =&gt; store.dispatch(&#123;type: 'DECREMENT'&#125;)&#125; /&gt;, document.getElementById('root') );&#125;;render();store.subscribe(render);","categories":[],"tags":[]},{"title":"JS Chapter 7","slug":"JS Chapter 7","date":"2021-09-22T02:34:07.866Z","updated":"2020-10-25T05:20:44.000Z","comments":true,"path":"2021/09/22/JS Chapter 7/","link":"","permalink":"http://yoursite.com/2021/09/22/JS%20Chapter%207/","excerpt":"","text":"Object orientation with prototypes虽然在之后avascript或者其一些框架的使用中，原型和原型链的概念很少被提到。但是原型作为JavaScript的基本的重要概念之一，也是需要被我们掌握的。 原型的概念书上给出的概念 A prototype is an object to which the search for a particular property can be delegated to. 首先最简单的缩句理解prototype就是一个对象，对象有一些特殊的属性。 Understanding protototypes我们可以先创造一个对象，对象里面包含一些字面对象得标记 12345let obj = &#123; prop1: 1, prop2: function()&#123;&#125;, prop3: &#123;&#125;&#125; 我们也可以进行一些修改删除操作,也可以添加一个完全新的属性： 1234obj.prop1 = 1;obj.prop1 = [];delete obj.prop2;obj.prop4 = \"Hello\"; 最后object的内容是这样的： 12345&#123; prop1:[], prop3:&#123;&#125;, prop4:\"Hello\"&#125;; 当在开发软件时，我们会希望减少代码的冗余量，尽可能的去重复利用一些代码，其中我们可以利用Javascript中继承的特性。 123456789101112const yoshi = &#123;skulk: true&#125;;const hattori = &#123;sneak: true&#125;;const kuma = &#123;creep: true&#125;;assert(\"skulk\" in yoshi, \"Yoshi can skulk\");assert(!(\"sneak\" in yoshi), \"Yoshi cannot sneak\");assert(!(\"creep\" in yoshi), \"Yoshi cannot creep\");Object.setPrototypeOf(yoshi, hattori);//把hattori设为yoshi的原型assert(\"sneak\" in yoshi, \"Yoshi can now sneak\");assert(!(\"creep\" in hattori), \"Hattori cannot creep\");Object.setPrototypeOf(hattori, kuma);//把kuma设为hattori的原型assert(\"creep\" in yoshi, \"Hattori can now creep\");assert(\"creep\" in hattori, \"Yoshi can also creep\"); 画一下这个一条原型链。[[prototype]] Object construction and prototypes我们首先使用JavaScript当中的new关键字来完成原型链的构成 123456789function Ninja()&#123; Ninja.prototype.swingSword = function()&#123; return true; &#125;&#125;const ninja1 = Ninja();assert(ninja1 === undefined,\"No instance of Ninja created.\");const ninja2 = new Ninja();assert(ninja2 &amp;&amp; ninja2.swingSword &amp;&amp; ninja2.swingSword(),\"Instance exists and method is callable.\"); Ninja这个函数对象当中我们创建了一个函数在他的原型当中，这个原型对象当中有constructor指向他自己（Ninja）和一个swingSword函数。当我们使用new关键字时，其实一共有四个步骤： new了之后，在内存中申请一块空闲的空间，存储创建的新的对象。 在函数最顶端有一个理论上的空对象即this：把this设置为当前的对象。 执行构造函数把this对象中的数据填满：设置对象的属性和方法的值。 最后一步有一个隐式的return this; 把this这个对象返回。 instance properties这里我们用this参数来完成Ninja函数 1234567891011function Ninja()&#123; this.swung = false; this.swingSword = function()&#123; return !this.swung; &#125;;&#125;Ninja.prototype.swingSword = function()&#123; return this.swung;&#125;;const ninja = new Ninja();assert(ninja.swingSword(), \"Called the instance method, not the prototype method.\"); 上面提到的new关键字的实际四个步骤，这里的ninja其实就是指向ninja本身的this对象。ninja本身会有swung和swingSword属性，和他存在一个原型指向ninja的原型。ninja原型之中也会有一个swingSword方法，但是我们在调用swingSword方法可以看到返回的值为true而不是false本身，因为当我们调用swingSword时，ninja会在其本身去寻找有没有这个swingSword方法，当swingSword不存在时，才再开始在其原型中寻找函数。比如，我们会在一些数组对象Array或者字符串对象String使用一些方法时，sort，map等，我们并没有直接在这些对象之中定义，而是他们继承了Array和String的原型，而去他的原型当中寻找这些方法。 12345Ninja.prototype = &#123; pierce: function()&#123; return true; &#125;&#125; 当执行到该句时，Ninja的原型会指向新的这个对象包含pierce函数。 12345function Ninja()&#123;&#125;const ninja = new Ninja();assert(typeof ninja === \"object\", \"The type of the instance is object.\");assert(ninja instanceof Ninja, \"instanceof identifies the constructor.\");assert(ninja.constructor === Ninja, \"The ninja object was created by the Ninja function\"); 从这几行代码可以得出ninja是一个的对象，也是Ninja得一个实例，而ninja的原型里面的constructor指向的Ninja 12345function Ninja()&#123;&#125;const ninja = new Ninja();const ninja2 = new ninja.constructor();assert(ninja2 instanceof Ninja, \"It's a Ninja!\");assert(ninja !== ninja2,\"But not the same Ninja\"); 我们通过ninja.constructor来构建一个新的对象，而ninja2也是一个Ninja的实例。 Achieving inheritance123456789function Person()&#123;&#125;;Person.prototype.dance = function()&#123;&#125;;function Ninja()&#123;&#125;;Ninja.prototype = new Person();const ninja = new Ninja();assert(ninja instanceof Ninja, \"ninja receives functionality from the Ninja prototype\");assert(ninja instanceof Person, \"...and the Person prototype\");assert(ninja instanceof Object, \"...and the Object prototype\");assert(typeof ninja.dance === \"function\",\"..and can dance!\") 这里是一个原型链的继承，ninja是Ninja的实例也是Person的实例也是一个对象实例。 Using JavaScript “classes” in ES6我们实际在开发过程中，我们会经常使用ES6中的新特性classes。 1234567891011121314151617class Ninja&#123; constructor(name)&#123; this.name = name; walk()&#123; return true; &#125; &#125;&#125;swingSword()&#123; return true;&#125;// ninja.prototype.swingSword = ()&#123; return true&#125;;static dance()&#123; return false;&#125;var ninja = new Ninja(\"Yoshi\");assert(ninja.swingSword(),\"and he can swing a sword\"); 1234567891011121314151617class Person&#123; constructor(name)&#123; this.name = name; &#125; dance()&#123; return true; &#125;&#125;class Ninja extends Person&#123; constructor(name,weapon)&#123; super(name); this.weapon = weapon; &#125; wieldWeapon()&#123; return true; &#125;&#125;","categories":[],"tags":[]},{"title":"JS Chapter 5","slug":"JS Chapter 5","date":"2021-09-22T02:34:07.774Z","updated":"2020-07-11T08:26:24.000Z","comments":true,"path":"2021/09/22/JS Chapter 5/","link":"","permalink":"http://yoursite.com/2021/09/22/JS%20Chapter%205/","excerpt":"","text":"Closure一、概念A closure is the combination of a function and the lexical environment within which that function was declared.二、Lexical Environment（词法环境）​ 这个链接详细介绍了什么是词法环境。https://segmentfault.com/a/1190000015172796 三、区分的两个概念​ 一开始看闭包这个部分的时候一直没有搞懂为什么不能在外部变量访问内部变量的问题，其实是我把两个概念给搞混了。 ​ 为什么不能访问内部变量这个问题很简单，就是局部变量的生存周期与函数的调用时一样，一旦函数调用完毕，这些局部变量就不在存在了。 1234let outter = 1;function ()&#123; let inner = 2;&#125; ​ 而我一开始困惑了很久，就是为什么a.b，这样的就可以访问呢？ 那我搞混的两个概念就是局部变量和对象的属性或者方法。 ​ 局部变量就是上面所说的，那么对象的属性或方法来举例子： 123let a = new Object();//a是一个对象a.b = 2;alert(a.b); 四、小桃花穿越故事先举一个简单的例子 123456789 function t1()&#123; var age = 20; function t2()&#123; alert(age); &#125; return t2; &#125;var tmp = t1();tmp();//----------------------------20 ​ 大部分的语言，t1被调用执行，则申请内存，并把其局部变量age, push入栈,t1函数执行完毕，内部的局部变量，随着函数的退出而销毁.因此age = 20 的局部变量已经消失了;​ 但是在js中，age = 20 这个变量，却被t2捕捉，即使t1执行完毕，通过t2仍然可以访问t2依然可以访问该变量。这也是实现上面的访问局部变量。 ​ 再来看一下，这个情形的过程，引入js闭包的知识点。​ 在js中，t1执行过程中又生成了t2，而作用域上来说，t2能访问到age = 20，于是age = 20 不会消失，而是与返回的t1函数形成了一个环境包，这个包是t2的(把其周围的变量环境形成了封闭的环境包 共同返回)，即使t1执行完毕，通过t2仍然可以访问t1依然可以访问该变量，这就是闭包!!!小桃花穿越 12345678910111213function closure()&#123; var sister = '大桃花'; var me = function()&#123; alert(sister); &#125; return me;&#125;function place()&#123; var sister = '清朝大福晋'; var girl = closure(); girl();&#125;place();//------------------------------大桃花 五、闭包计数器闭包来维护一个别人污染不到的变量 做计数器 123456789var fn = (function()&#123; var cnt = 0; return function()&#123; return ++cnt; &#125; &#125;)();alert(fn());//------------------1alert(fn());//------------------2alert(fn());//------------------3 这里放一个经典的案例就也不搬过来了。https://blog.csdn.net/Tacks/article/details/78704922 Stack Heap一开始了解的stack栈就是上进上出 先入后出这样子，也不想搬运别人博客了就放一个链接https://www.jianshu.com/p/90808ed34b86 heap堆之前了解并不多来搬运一下博客链接吧。https://blog.csdn.net/qian3223/article/details/82424757 Types of JavaScript variables​ var关键字是JavaScript创造开始时的一部分，然而let和const关键字的在ES6版本中更新的产物。 变量易变性（variables mutability）​ 如果我们按照变量区分他们，const则与剩余的两个有很大区别。所有以const声明的变量都是不可改变的。那么以剩下两个关键字声明的变量都可以反复改变很多次的值。 12345678910111213141516const firstConst = \"samurai\";assert(firstConst === \"samurai\",\"firstConst is a samruai\");try&#123; firstConst = \"ninja\"; fail(\"Shouldn't be here\");&#125;catch(e)&#123; pass(\"An exception has occurred\");&#125;assert(firstConst === \"samurai\",\"firstCount is still a samuerai\");const secondConst = &#123;&#125;;secondConst.weapon = \"wakizashi\";assert(secondConst.weapon === \"wakizashi\",\"We can add new properties\");const thirdConst = [];assert(thirdConst.length === 0, \"No items in our array\");thirdConst.push(\"Yoshi\");assert(thirdConst.length === 1, \"The array has changed\"); ​ 首先，我们声明且初始化了firstConst变量为samurai，我们继续给他赋一个全新的值ninja，因为firstConst是一个常量，所以我们ninja赋值失败。所以，JavaScript的引擎会丢出一个exception事件，我们用到fail和pass方法（这两者和assert类似）来测试exception事件是否发生了。如果exception发生了，catch语句会被激活，然后pass语句也就被执行了。反之，fail语句就会被执行。 ​ 再而，我们声明一个空对象secondConst和空数组thirdCosnt。我们已经知道了不能改变常量的值，但是我们可以给它增添属性。 变量声明关键字和词法作用域​ 不同关键字声明有不同的作用域，这一部分比较简单，总的来说，就是var无论在哪儿声明都是以最近的函数作用域或者全局作用域，而const和let可以为块作用域。 123456function()&#123; var local = ''; for(var i = 0;i &lt; 10;i++); assert(i == 10,\"i is ten\");&#125;assert(typeof i === \"undefined\",\"We cannot see function variables outside of a function\"); 在词法作用域中的寄存（状态提升）​ 在JavaScript中，代码的执行分为两个阶段。第一阶段为JavaScript引擎会把所有声明变量和函数声明在当前的词法环境内提前。第二阶段为执行阶段，由函数调用执行或者赋值时开始。其中，var function 只是对变量声明，没有赋值操作。","categories":[],"tags":[]}]}