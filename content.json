{"meta":{"title":"HCL's Blog","subtitle":"Recording the study progress","description":"Fighting!","author":"HCLacids","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"React Hook","slug":"React Hook","date":"2020-09-15T12:19:32.697Z","updated":"2020-09-16T06:52:59.327Z","comments":true,"path":"2020/09/15/React Hook/","link":"","permalink":"http://yoursite.com/2020/09/15/React%20Hook/","excerpt":"","text":"React Hook📌 State Hook“Hook是react 16.8的新增特性。它可以让你在不编写class的情况下使用state。”这是React官网 对Hook最直接的解释。不使用class而是普通的函数去封装组件或者页面。 123456789101112131415import React, &#123; useState &#125; from 'react';function Example() &#123; // 声明一个新的叫做 “count” 的 state 变量 const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 这里我们引入并解构出useState方法来声明一个Hook当中的state变量。 const [count, setCount] = useState(0);这一个语句中useState的唯一参数为声明的state的初始值，例如这里的count为一个数字，并且初始值为0。setCount则像setState方法一样去改变state的值。 useState 方法的返回值是什么？ 返回值为：当前 state 以及更新 state 的函数。这就是我们写 const [count, setCount] = useState() 的原因。这与 class 里面 this.state.count 和 this.setState 类似，唯一区别就是你需要成对的获取它们。 下面展示同一个class封装的组件。 12345678910111213141516171819202122class Example extends React.Component&#123; constructor()&#123; super(); this.state = &#123; count: 0 &#125; &#125; click() &#123; const &#123;count&#125; = this.state this.setState(&#123; count: count + 1 &#125;); &#125; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;this.click.bind(this)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ); &#125; 大体来说两者可以完成同一个功能就是记下按钮被点击的次数。我们可以明显观察到hook的使用变量的改变和显示都比class要简单很多。 声明多个state变量1234567function ExampleWithManyStates() &#123; // 声明多个 state 变量！ const [age, setAge] = useState(42); const [fruit, setFruit] = useState('banana'); const [todos, setTodos] = useState([&#123; text: 'Learn Hooks' &#125;]); // ...&#125; 那么，什么是 Hook?Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。Hook 不能在 class 组件中使用 —— 这使得你不使用 class 也能使用 React。 React 内置了一些像 useState 这样的 Hook。你也可以创建你自己的 Hook 来复用不同组件之间的状态逻辑。我们会先介绍这些内置的 Hook。 ⚡️ Effect Hook你之前可能已经在 React 组件中执行过数据获取、订阅或者手动修改过 DOM。我们统一把这些操作称为“副作用”，或者简称为“作用”。 useEffect 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 具有相同的用途，只不过被合并成了一个 API。 1234567891011121314151617181920import React, &#123; useState, useEffect &#125; from 'react';function Example() &#123; const [count, setCount] = useState(0); // 相当于 componentDidMount 和 componentDidUpdate: useEffect(() =&gt; &#123; // 使用浏览器的 API 更新页面标题 document.title = `You clicked $&#123;count&#125; times`; &#125;); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 12345678910111213141516171819202122232425262728class Example extends React.Component&#123; constructor()&#123; super(); this.state = &#123; count: 0 &#125; &#125; componentDidMount()&#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125; componentDidUpdate()&#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125; click() &#123; const &#123;count&#125; = this.state this.setState(&#123; count: count + 1 &#125;); &#125; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;this.click.bind(this)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ); &#125; 当你调用 useEffect 时，就是在告诉 React 在完成对 DOM 的更改后运行你的“副作用”函数。由于副作用函数是在组件内声明的，所以它们可以访问到组件的 props 和 state。默认情况下，React 会在每次渲染后调用副作用函数 —— 包括第一次渲染的时候。(useEffect会在每一次页面渲染时调用。) 副作用函数还可以通过返回一个函数来指定如何“清除”副作用。例如，在下面的组件中使用副作用函数来订阅好友的在线状态，并通过取消订阅来进行清除操作： 123456789101112131415161718192021import React, &#123; useState, useEffect &#125; from 'react';function FriendStatus(props) &#123; const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;; &#125;); if (isOnline === null) &#123; return 'Loading...'; &#125; return isOnline ? 'Online' : 'Offline';&#125; 在这个示例中，React 会在组件销毁时取消对 ChatAPI 的订阅，然后在后续渲染时重新执行副作用函数。 12345678....componentDidMount()&#123; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);&#125;componentWillUnmount()&#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);&#125;.... 通过跳过 Effect 进行性能优化在某些情况下，每次渲染后都执行清理或者执行 effect 可能会导致性能问题。在 class 组件中，我们可以通过在 componentDidUpdate 中添加对 prevProps 或 prevState 的比较逻辑解决： 12345componentDidUpdate(prevProps, prevState) &#123; if (prevState.count !== this.state.count) &#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125;&#125; 这是很常见的需求，所以它被内置到了 useEffect 的 Hook API 中。如果某些特定值在两次重渲染之间没有发生变化，你可以通知 React 跳过对 effect 的调用，只要传递数组作为 useEffect 的第二个可选参数即可： 123useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`;&#125;, [count]); // 仅在 count 更改时更新 上面这个示例中，我们传入 [count] 作为第二个参数。这个参数是什么作用呢？如果 count 的值是 5，而且我们的组件重渲染的时候 count 还是等于 5，React 将对前一次渲染的 [5] 和后一次渲染的 [5] 进行比较。因为数组中的所有元素都是相等的(5 === 5)，React 会跳过这个 effect，这就实现了性能的优化。 当渲染时，如果 count 的值更新成了 6，React 将会把前一次渲染时的数组 [5] 和这次渲染的数组 [6] 中的元素进行对比。这次因为 5 !== 6，React 就会再次调用 effect。如果数组中有多个元素，即使只有一个元素发生变化，React 也会执行 effect。 对于有清除操作的 effect 同样适用： 12345678910useEffect(() =&gt; &#123; function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;;&#125;, [props.friend.id]); // 仅在 props.friend.id 发生变化时，重新订阅 未来版本，可能会在构建时自动添加第二个参数。 ✌️ Hook 使用规则Hook 就是 JavaScript 函数，但是使用它们会有两个额外的规则： 只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用。 只能在 React 的函数组件中调用 Hook。不要在其他 JavaScript 函数中调用。（还有一个地方可以调用 Hook —— 就是自定义的 Hook 中，我们稍后会学习到。） React 的函数组件是这样的： 1234const Example = (props) =&gt; &#123; // 你可以在这使用 Hook return &lt;div /&gt;;&#125; 或是这样： 1234function Example(props) &#123; // 你可以在这使用 Hook return &lt;div /&gt;;&#125; 你之前可能把它们叫做“无状态组件”。但现在我们为它们引入了使用 React state 的能力，所以我们更喜欢叫它”函数组件”。 Hook 在 class 内部是不起作用的。但你可以使用它们来取代 class 。 💡 自定义 Hook前面，我们介绍了一个叫 FriendStatus 的组件，它通过调用 useState 和 useEffect 的 Hook 来订阅一个好友的在线状态。假设我们想在另一个组件里重用这个订阅逻辑。 首先，我们把这个逻辑抽取到一个叫做 useFriendStatus 的自定义 Hook 里： 123456789101112131415161718import React, &#123; useState, useEffect &#125; from 'react';function useFriendStatus(friendID) &#123; const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange); &#125;; &#125;); return isOnline;&#125; 它将 friendID 作为参数，并返回该好友是否在线： 现在我们可以在两个组件中使用它： 1234567891011121314151617function FriendStatus(props) &#123; const isOnline = useFriendStatus(props.friend.id); if (isOnline === null) &#123; return 'Loading...'; &#125; return isOnline ? 'Online' : 'Offline';&#125;function FriendListItem(props) &#123; const isOnline = useFriendStatus(props.friend.id); return ( &lt;li style=&#123;&#123; color: isOnline ? 'green' : 'black' &#125;&#125;&gt; &#123;props.friend.name&#125; &lt;/li&gt; );&#125; 每个组件间的 state 是完全独立的。Hook 是一种复用状态逻辑的方式，它不复用 state 本身。事实上 Hook 的每次调用都有一个完全独立的 state —— 因此你可以在单个组件中多次调用同一个自定义 Hook。 自定义 Hook 更像是一种约定而不是功能。如果函数的名字以 “use” 开头并调用其他 Hook，我们就说这是一个自定义 Hook。","categories":[],"tags":[]},{"title":"JS Chapter 10","slug":"JS Chapter 10","date":"2020-06-30T14:02:26.057Z","updated":"2020-06-30T14:02:26.057Z","comments":true,"path":"2020/06/30/JS Chapter 10/","link":"","permalink":"http://yoursite.com/2020/06/30/JS%20Chapter%2010/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"JS Chapter 6","slug":"JS Chapter 6","date":"2020-06-10T07:20:54.493Z","updated":"2020-07-11T08:40:06.141Z","comments":true,"path":"2020/06/10/JS Chapter 6/","link":"","permalink":"http://yoursite.com/2020/06/10/JS%20Chapter%206/","excerpt":"","text":"Generator先看三段代码 12345678try&#123; var ninjas = syncGetJSON(\"ninjas.json\"); var missions = syncGetJSON(ninjas[0].missionsUrl); var missionDetails = syncGetJSON(mission[0].detailsUrl); //Study the mission description&#125;catch(e)&#123; //Oh no, we weren't able to get the mission details&#125; 12345678910111213141516171819getJSON(\"ninjas.json\",function(err,ninjas)&#123; if(err)&#123; console.log(\"Error fetching list of ninjas\",err); return; &#125; getJSON(ninjas[0].missionsUrl,function(err,missions)&#123; if(err)&#123; console.log(\"Error locating ninja missions\",err); return; &#125; getJSON(mission[0].detailsUrl,function(err,missionDetails)&#123; if(err)&#123; console.log(\"Error locating mission details\",err); return; &#125; //Study the intel plan &#125;); &#125;);&#125;); 12345678910async(function*()&#123; try&#123; var ninjas = syncGetJSON(\"ninjas.json\"); var missions = syncGetJSON(ninjas[0].missionsUrl); var missionDetails = syncGetJSON(mission[0].detailsUrl); //Study the mission description&#125;catch(e)&#123; //Oh no, we weren't able to get the mission details &#125;&#125;) 第一段代码问题：从服务器获得数据是一个长期运行的操作，因为JavaScript是依赖单线程模式，我们会锁住我们的UI直到这整个代码运行结束。这导致了无法反应的应用和使用户失望。 1234567891011function* WeaponGenerator()&#123; yield \"Katana\"; yield \"Wakizashi\";&#125;const weaponsIterator = WeaponGenerator();const result1 = weaponsIterator.next();assert(typeof result1 === \"object\" &amp;&amp; result1.value === \"katana\" &amp;&amp; !result1.done,\"Katana recevied!\");const result2 = weaponsIterator.next();assert(typeof result2 === \"object\" &amp;&amp; result2.value === \"wakizashi\" &amp;&amp; !result2.done,\"wakizashi recevied!\");const result3 = weaponsIterator.next();assert(typeof result3 === \"object\" &amp;&amp; result3.value === undefined &amp;&amp; result3.done,\"There are no more results!\"); WeaponGenerator是构造器，weaponsIterator.next()会返回一个对象，如果传入值则yield被替换为改值，对象有两个属性value和done，当第三次返回对象时done的值为true。 123456789101112function* WarriorGenerator()&#123; yield \"Katana\"; yield* NinjaGenerator(); yield \"Wakizashi\";&#125;function* NinjaGenerator()&#123; yield \"Hattori\"; yield \"Yoshi\";&#125;for(let warrior of WarriorGenerator())&#123; assert(warrior !== null, warrior);&#125; 类似于链表的结构。 12345678910111213function* NinjaGenerator()&#123; try&#123; yield \"Hattori\"; fail(\"The expected exception didn't occur\"); &#125; catch(e)&#123; assert(e === \"Catch this!\",\"Aha! We caught an exception\"); &#125;&#125;const ninjaIterator = NinjaGenrator();const result1 = ninjaIterator().next();assert(result1.value === \"Hattori\", \"We got Hattori\");ninjaIterator.throw(\"Catch this!\"); 这里是说有throw这个方法 12345678910function* NinjaGenerator(action)&#123; const imposter = yield (\"Hattori\" + action); assert(imposter === \"Hanzo\",\"The generator has been infiltrated\"); yield (\"Yoshi (\" + imposter + \") \" + action);&#125;const ninjaIterator = NinjaGenerator(\"skulk\");const result1 = ninjaIterator.next();assert(result1.value === \"Hattori skulk\", \"Hattori is skulking\");const result2 = ninjaIterator.next(\"Hanzo\");assert(result2.value === \"Yoshi (Hanzo) skulk\", \"We have an imposter!\"); Promise来搬一个别人的博客https://www.jianshu.com/p/1b63a13c2701","categories":[],"tags":[]},{"title":"JS Chapter 5","slug":"JS Chapter 5","date":"2020-06-02T08:54:20.269Z","updated":"2020-07-11T08:26:24.129Z","comments":true,"path":"2020/06/02/JS Chapter 5/","link":"","permalink":"http://yoursite.com/2020/06/02/JS%20Chapter%205/","excerpt":"","text":"Closure一、概念A closure is the combination of a function and the lexical environment within which that function was declared.二、Lexical Environment（词法环境）​ 这个链接详细介绍了什么是词法环境。https://segmentfault.com/a/1190000015172796 三、区分的两个概念​ 一开始看闭包这个部分的时候一直没有搞懂为什么不能在外部变量访问内部变量的问题，其实是我把两个概念给搞混了。 ​ 为什么不能访问内部变量这个问题很简单，就是局部变量的生存周期与函数的调用时一样，一旦函数调用完毕，这些局部变量就不在存在了。 1234let outter = 1;function ()&#123; let inner = 2;&#125; ​ 而我一开始困惑了很久，就是为什么a.b，这样的就可以访问呢？ 那我搞混的两个概念就是局部变量和对象的属性或者方法。 ​ 局部变量就是上面所说的，那么对象的属性或方法来举例子： 123let a = new Object();//a是一个对象a.b = 2;alert(a.b); 四、小桃花穿越故事先举一个简单的例子 123456789 function t1()&#123; var age = 20; function t2()&#123; alert(age); &#125; return t2; &#125;var tmp = t1();tmp();//----------------------------20 ​ 大部分的语言，t1被调用执行，则申请内存，并把其局部变量age, push入栈,t1函数执行完毕，内部的局部变量，随着函数的退出而销毁.因此age = 20 的局部变量已经消失了;​ 但是在js中，age = 20 这个变量，却被t2捕捉，即使t1执行完毕，通过t2仍然可以访问t2依然可以访问该变量。这也是实现上面的访问局部变量。 ​ 再来看一下，这个情形的过程，引入js闭包的知识点。​ 在js中，t1执行过程中又生成了t2，而作用域上来说，t2能访问到age = 20，于是age = 20 不会消失，而是与返回的t1函数形成了一个环境包，这个包是t2的(把其周围的变量环境形成了封闭的环境包 共同返回)，即使t1执行完毕，通过t2仍然可以访问t1依然可以访问该变量，这就是闭包!!!小桃花穿越 12345678910111213function closure()&#123; var sister = '大桃花'; var me = function()&#123; alert(sister); &#125; return me;&#125;function place()&#123; var sister = '清朝大福晋'; var girl = closure(); girl();&#125;place();//------------------------------大桃花 五、闭包计数器闭包来维护一个别人污染不到的变量 做计数器 123456789var fn = (function()&#123; var cnt = 0; return function()&#123; return ++cnt; &#125; &#125;)();alert(fn());//------------------1alert(fn());//------------------2alert(fn());//------------------3 这里放一个经典的案例就也不搬过来了。https://blog.csdn.net/Tacks/article/details/78704922 Stack Heap一开始了解的stack栈就是上进上出 先入后出这样子，也不想搬运别人博客了就放一个链接https://www.jianshu.com/p/90808ed34b86 heap堆之前了解并不多来搬运一下博客链接吧。https://blog.csdn.net/qian3223/article/details/82424757 Types of JavaScript variables​ var关键字是JavaScript创造开始时的一部分，然而let和const关键字的在ES6版本中更新的产物。 变量易变性（variables mutability）​ 如果我们按照变量区分他们，const则与剩余的两个有很大区别。所有以const声明的变量都是不可改变的。那么以剩下两个关键字声明的变量都可以反复改变很多次的值。 12345678910111213141516const firstConst = \"samurai\";assert(firstConst === \"samurai\",\"firstConst is a samruai\");try&#123; firstConst = \"ninja\"; fail(\"Shouldn't be here\");&#125;catch(e)&#123; pass(\"An exception has occurred\");&#125;assert(firstConst === \"samurai\",\"firstCount is still a samuerai\");const secondConst = &#123;&#125;;secondConst.weapon = \"wakizashi\";assert(secondConst.weapon === \"wakizashi\",\"We can add new properties\");const thirdConst = [];assert(thirdConst.length === 0, \"No items in our array\");thirdConst.push(\"Yoshi\");assert(thirdConst.length === 1, \"The array has changed\"); ​ 首先，我们声明且初始化了firstConst变量为samurai，我们继续给他赋一个全新的值ninja，因为firstConst是一个常量，所以我们ninja赋值失败。所以，JavaScript的引擎会丢出一个exception事件，我们用到fail和pass方法（这两者和assert类似）来测试exception事件是否发生了。如果exception发生了，catch语句会被激活，然后pass语句也就被执行了。反之，fail语句就会被执行。 ​ 再而，我们声明一个空对象secondConst和空数组thirdCosnt。我们已经知道了不能改变常量的值，但是我们可以给它增添属性。 变量声明关键字和词法作用域​ 不同关键字声明有不同的作用域，这一部分比较简单，总的来说，就是var无论在哪儿声明都是以最近的函数作用域或者全局作用域，而const和let可以为块作用域。 123456function()&#123; var local = ''; for(var i = 0;i &lt; 10;i++); assert(i == 10,\"i is ten\");&#125;assert(typeof i === \"undefined\",\"We cannot see function variables outside of a function\"); 在词法作用域中的寄存（状态提升）​ 在JavaScript中，代码的执行分为两个阶段。第一阶段为JavaScript引擎会把所有声明变量和函数声明在当前的词法环境内提前。第二阶段为执行阶段，由函数调用执行或者赋值时开始。其中，var function 只是对变量声明，没有赋值操作。","categories":[],"tags":[]},{"title":"Sass","slug":"Sass","date":"2020-04-02T05:26:15.024Z","updated":"2020-04-02T06:25:38.162Z","comments":true,"path":"2020/04/02/Sass/","link":"","permalink":"http://yoursite.com/2020/04/02/Sass/","excerpt":"","text":"Sass学习​ 因为在Taro项目中有用到Sass，但是当时并没有学习所以就分开来写。 一、安装因为Taro项目初始化的时候会自行安装，只要选择Sass就行了。所以这里给出官方链接。https://sass.bootcss.com/install 二、变量变量是存储信息并在将来重复利用的一种方式，在整个样式表中都可访问。 你可以在变量中存储颜色、字体 或任何 CSS 值，并在将来重复利用。Sass 使用 $ 符号 作为变量的标志。 1234567$font-stack: Helvetica, sans-serif;$primary-color: #333;body &#123; font: 100% $font-stack; color: $primary-color;&#125; 1234body &#123; font: 100% Helvetica, sans-serif; color: #333;&#125; 三、嵌套​ 在编写 HTML 时，它有一个清晰的嵌套和可视化层次结构。 而 CSS 则没有。 ​ Sass 允许嵌套 CSS 选择器，嵌套方式 与 HTML 的视觉层次结构相同。请注意，过度嵌套的规则 将导致过度限定的 CSS，这些 CSS 可能很难维护，并且 通常被认为是不好的做法。 ​ 理解了这一点，下面就来看一个典型的网站导航的样式 示例： 123456789101112131415nav &#123; ul &#123; margin: 0; padding: 0; list-style: none; &#125; li &#123; display: inline-block; &#125; a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125;&#125; 12345678910111213nav ul &#123; margin: 0; padding: 0; list-style: none;&#125;nav li &#123; display: inline-block;&#125;nav a &#123; display: block; padding: 6px 12px; text-decoration: none;&#125; 四、片段创建部分Sass文件，其中包含一些CSS片段 ，可以将其包含在其他Sass文件中。这是模块化CSS并帮助使事情易于维护的好方法。部分文件是一个Sass文件，名称前带有一个下划线。可以将其命名为_partial.scss。下划线让Sass知道该文件只是部分文件，不应将其生成为CSS文件。Sass局部函数与@use 规则一起使用。 五、模块不必将所有Sass都写在一个文件中。您可以根据需要将其拆分@use。该规则将另一个Sass文件作为模块加载，这意味着您可以在Sass文件中使用基于文件名的命名空间引用其变量，mixins和函数。使用文件还将在编译输出中包含它生成的CSS！ 12345678// _base.scss$font-stack: Helvetica, sans-serif;$primary-color: #333;body &#123; font: 100% $font-stack; color: $primary-color;&#125; 1234567// styles.scss@use 'base';.inverse &#123; background-color: base.$primary-color; color: white;&#125; 123456789body &#123; font: 100% Helvetica, sans-serif; color: #333;&#125;.inverse &#123; background-color: #333; color: white;&#125; 六、混合​ CSS中的某些内容编写起来有些繁琐，尤其是使用CSS3 和存在的许多供应商前缀时。使用mixin，您可以创建要在整个站点中重复使用的CSS声明组 。您甚至可以传入值以使混入更加灵活。mixin的一个很好的用法是用于供应商前缀。这是的示例 transform。 123456@mixin transform($property) &#123; -webkit-transform: $property; -ms-transform: $property; transform: $property;&#125;.box &#123; @include transform(rotate(30deg)); &#125; 12345.box &#123; -webkit-transform: rotate(30deg); -ms-transform: rotate(30deg); transform: rotate(30deg);&#125; 要创建一个mixin，请使用@mixin指令并为其命名。我们将其命名为mixin transform。我们还在$property括号内使用了变量 ，因此我们可以传递任何所需的变换。创建混入之后，您可以将其用作CSS 声明@include，以混入的名称开头。 七、扩展继承​ 这是Sass最有用的功能之一。使用@extend使您可以将一组CSS属性从一个选择器共享到另一个选择器。它有助于使Sass保持非常干燥。在我们的示例中，我们将使用扩展，占位符类一起使用的另一个功能，为错误，警告和成功创建一系列简单的消息传递。占位符类是一种特殊的类，仅在扩展时才打印，并且可以帮助保持编译后的CSS整洁。 12345678910111213141516171819202122232425262728293031/* This CSS will print because %message-shared is extended. */%message-shared &#123; border: 1px solid #ccc; padding: 10px; color: #333;&#125;// This CSS won't print because %equal-heights is never extended.%equal-heights &#123; display: flex; flex-wrap: wrap;&#125;.message &#123; @extend %message-shared;&#125;.success &#123; @extend %message-shared; border-color: green;&#125;.error &#123; @extend %message-shared; border-color: red;&#125;.warning &#123; @extend %message-shared; border-color: yellow;&#125; 123456789101112131415161718/* This CSS will print because %message-shared is extended. */.message, .success, .error, .warning &#123; border: 1px solid #ccc; padding: 10px; color: #333;&#125;.success &#123; border-color: green;&#125;.error &#123; border-color: red;&#125;.warning &#123; border-color: yellow;&#125; ​ 上面的代码的作用是告诉.message，.success，.error，和.warning做人一样%message-shared。这意味着任何地方%message-shared显示来，.message，.success，.error，和 .warning也会这样做的。魔术发生在生成的CSS中，其中每个类将获得与相同的CSS属性%message-shared。这有助于您避免在HTML 元素上编写多个类名。 ​ 除了Sass中的占位符类之外，您还可以扩展最简单的CSS选择器，但是使用占位符是确保不扩展嵌套在样式中其他位置的类的最简单方法，这会导致CSS中意外的选择器 。 ​ 请注意，不会生成CSS in %equal-heights，因为%equal-heights它不会被扩展。 八、操作符​ 在 CSS 中经常需要做数学计算。Sass 支持一些标准的 数学运算符，例如 +、-、*、/ 和 %。在下面的例子中，我们 将做一些简单的数学运算来计算出 aside &amp; article 的宽度。 12345678910111213.container &#123; width: 100%;&#125;article[role=\"main\"] &#123; float: left; width: 600px / 960px * 100%;&#125;aside[role=\"complementary\"] &#123; float: right; width: 300px / 960px * 100%;&#125;","categories":[],"tags":[]},{"title":"孤独星球--Taro框架总结","slug":"孤独星球--Taro框架总结","date":"2020-04-01T15:30:56.708Z","updated":"2020-04-01T17:02:39.079Z","comments":true,"path":"2020/04/01/孤独星球--Taro框架总结/","link":"","permalink":"http://yoursite.com/2020/04/01/%E5%AD%A4%E7%8B%AC%E6%98%9F%E7%90%83--Taro%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/","excerpt":"","text":"孤独星球–Taro框架总结​ 大一下学期用Taro框架写了QQ的小程序–孤独星球，项目链接在这里。https://github.com/The-Planet-of-Loneline/project ​ 项目分为白天和黑夜两个部分，白天是同组的刘安完成的，技术含量也比较高；黑夜和登录部分就是由我完成的。接下来就说一下Taro里面的一些细节。 一、项目结构​ 因为一开始没有去参照学姐学长做的客栈的框架，所以这个项目的框架比较乱，一些组件的页面的位置也存放的不正确。希望以后的项目能够把公共组件和私有组件分开，组件和页面分开以形成更明晰的结构。以下是参照木犀客栈的结构： 123456789101112131415--src --assets //存放图片 --png --svg --components //存放组件 --common //公用组件 --index //私有组件 --pages //页面 --index --index.jsx --service //Fech API --Fech.jsx --app.jsx //配置 --app.scss //样式 --index.html //接口 一般来说一个项目的结构就如上所示了。 二、Taro内置组件​ 刚刚开始写静态页面的时候使用错了组件，还是用的HTML的标签&lt;div&gt; &lt;span&gt;等。要注意以下代码的含义： 12import Taro, &#123; Component &#125; from '@tarojs/taro'import &#123; View, Text,Image &#125; from '@tarojs/components' ​ Taro里面有内置的组件使用，&lt;View&gt; &lt;Text&gt;等类似于HTML中的标签使用。要注意的是，HTML中使用的class选择器，class关键字要改变成classname，因为关键字的保留class类。 这里的import也是webpack的方法吧，引入你需要的组件例如黑夜的头部和底部： 12import Head from '../component/Head'import Footer from '../component/Footer' 一定要from正确的路径&#39;../&#39;是返回上一级目录，也可以返回多次。 三、Taro中的输入框​ Taro中的输入框也是Taro当中的内置组件也分为input和textarea，但是要大写&lt;Input /&gt; &lt;Textarea /&gt;，这里顺便提一下Taro里面所有组件开头都要大写。 ​ 输入框输入值的时候value要空，且还有监听事件函数onInput，onChange也可以。但是比较坑的事，onInput函数对于Input和Textarea不同。当时产品组给我提的要求是控制行数限制，这里也要说一下Textarea的特性，有换行的监听函数。但是由于onInput对于Textarea的value的改变不能显示于Textarea，而可以显示于Input。最后也是需求改成了字数限制。 12345678910&lt;Textarea className='write' value=&#123;Value&#125; onInput=&#123;this.handleInputChange.bind(this)&#125; onFocus=&#123;this.handleInput.bind(this)&#125;onBlur=&#123;this.handleback.bind(this)&#125; showConfirmBar=&#123;false&#125;maxlength=&#123;75&#125;autoFocus=&#123;true&#125;&gt;&lt;/Textarea&gt; ​ 组件的写法可以这样换行以更醒目的看见，太长不方便查看。但是一些View好像就不行。 四、API​ 写整个项目前最重要的就是沟通，和产品沟通和后端沟通。没有沟通好的后果就是白天好像重新写页面的结构。还好因为黑夜也不难，所以没有做好沟通也影响不大。其中我觉得比较重要的是分页这个部分。因为要考虑到页面的实际需求来看分页的形式和需不需要分页。参考swaggerUI是一个很重要的东西，一定要反复比对。 123456789101112131415onReachBottom()&#123; if (this.state.history.length % 5 == 0) &#123; this.setState(&#123; page: this.state.page + 1 &#125;, () =&gt; &#123; Fetch(`secret/history?page=$&#123;this.state.page&#125;`, &#123;&#125;, 'GET').then(res =&gt; &#123; this.setState(&#123; history: this.state.history.concat(res.history) &#125;) &#125;) &#125;) &#125;&#125; ​ 这里是一个后端的分页方法，需要的事我每一次请求时发送一个页面数字给后端，他再返回给我对应数字的内容。这种分页方法个人感觉比较适合网页，而不适合小程序去写。所以我加了限定条件只有显示内容为5个时候才会进行下一次的请求。 ​ API的路径一定要对，我举例困扰我很久的删除功能。 1234567891011121314handleDelete()&#123; Fetch(`secret/delete/:secret_id/?secretId=$&#123;this.props.Debunkid&#125;`, &#123;&#125;, 'DELETE').then(res =&gt; &#123; Taro.showToast(&#123; title: '删除成功', icon: 'none' &#125;) this.props.onCloseDelete() Taro.reLaunch(&#123; url:`/pages/Mine/Mine` &#125;) &#125;) &#125; ​ 这里因为我少了一个/导致我应该不能与后端连接，但是开发者工具可以我也就没有想太多。牢记！！ 五、QQ授权和分享​ QQ授权和分享是要过审核必须写的一个API，我们也是事后才写的。 1&lt;Button open-type='getUserInfo' className='login' onClick=&#123;this.power&#125;&gt;登录&lt;/Button&gt; 12345678910power () &#123; Taro.getSetting(&#123; success: (res) =&gt; &#123; this.setState(&#123; powered:res.authSetting['scope.userInfo']&#125;) if (res.authSetting['scope.userInfo']) &#123; this.onHandleLogin() &#125; &#125; &#125;) &#125; 123Taro.showShareMenu(&#123; showShareItems: ['qq', 'qzone', 'wechatFriends', 'wechatMoment'] &#125;) 第一二个代码块是处理授权的部分，第三个是分享。","categories":[],"tags":[]},{"title":"浏览器输入URL后发生了什么","slug":"浏览器输入URL后发生了什么","date":"2019-11-20T07:15:20.193Z","updated":"2019-12-08T01:13:08.716Z","comments":true,"path":"2019/11/20/浏览器输入URL后发生了什么/","link":"","permalink":"http://yoursite.com/2019/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/","excerpt":"","text":"当我们在浏览器的网址栏输入网址并回车后，一个网页页面就呈现在我们面前。我们有没有思考过浏览器时如何将一个内容丰富的页面给“变”出来的呢？ 基本步骤 浏览器的地址栏输入URL并按下回车。 浏览器查找当前URL是否存在缓存，并比较缓存是否过期。 DNS解析URL对应的IP。 根据IP建立TCP（三次握手）。 HTTP发出请求。 服务器处理请求，浏览器接受HTTP请求。 渲染页面，构建DOM树。 关闭TCP连接（四次挥手）。 URLURL的格式 protocol://hostname[:port]/path/[;parameters] [?query]#fragment protocal,协议头，比如http，https等 host，主机域名或IP地址 port，端口号一般为默认指所以隐藏起来 path，目录路径 query，查询参数 fragment，#后hash值，一般用来定位到某个位置 缓存浏览器会对你输入的网址进行判断，有缓存或无。有缓存则直接加载，无则向服务器发出请求。 DNS域名解析​ 我们知道在地址栏输入的域名并不是最后资源所在的真实位置，域名只是与IP地址的一个映射。网络服务器的IP地址那么多，我们不可能去记一串串的数字，因此域名就产生了，域名解析的过程实际是将域名还原为IP地址的过程。 首先浏览器先检查本地hosts文件是否有这个网址映射关系，如果有就调用这个IP地址映射，完成域名解析。 如果没找到则会查找本地DNS解析器缓存，如果查找到则返回。如果还是没有找到则会查找本地DNS服务器，如果查找到则返回。 ​ TCP链接拿到服务器IP地址则进行三次握手的连接。 客户端发送一个带有SYN标志的数据包给服务端，服务端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息，最后客户端再回传一个带ACK标志的数据包，代表握手结束，连接成功。 发送HTTP请求 与服务器建立了连接后，就可以向服务器发起请求了。这里我们先看下请求报文的结构（如下图）： 请求报文在浏览器中查看报文首部（以google浏览器为例）： ​ 请求行包括请求方法、URI、HTTP版本。首部字段传递重要信息，包括请求首部字段、通用首部字段和实体首部字段。我们可以从报文中看到发出的请求的具体信息。 请求报文的简要分析 服务器处理请求​ 服务器端收到请求后的由web服务器（准确说应该是http服务器）处理请求，诸如Apache、Ngnix、IIS等。web服务器解析用户请求，知道了需要调度哪些资源文件，再通过相应的这些资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过web服务器返回给浏览器客户端。 返回响应结果在HTTP里，有请求就会有响应，哪怕是错误信息。这里我们同样看下响应报文的组成结构： 响应报文 在响应结果中都会有个一个HTTP状态码，比如我们熟知的200、301、404、500等。通过这个状态码我们可以知道服务器端的处理是否正常，并能了解具体的错误。 状态码由3位数字和原因短语组成。根据首位数字，状态码可以分为五类： 1xx：指示信息–表示请求已接收，继续处理。 2xx：成功–表示请求已被成功接收、理解、接受。 3xx：重定向–要完成请求必须进行更进一步的操作。 4xx：客户端错误–请求有语法错误或请求无法实现。 5xx：服务器端错误–服务器未能实现合法的请求。 页面渲染前面有提到http交互，那么接下来就是浏览器获取到html，然后解析，渲染 解析HTML，构建DOM树 解析CSS，生成CSS规则树 合并DOM树和CSS规则，生成render树 布局render树（Layout/reflow），负责各元素尺寸、位置的计算 绘制render树（paint），绘制页面像素信息 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上 如下图： DOM tree CSSOM tree render tree 在浏览器还没接收到完整的 HTML 文件时，它就开始渲染页面了，在遇到外部链入的脚本标签或样式标签或图片时，会再次发送 HTTP 请求重复上述的步骤。在收到 CSS 文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完立刻显示在相应位置。在这一过程中可能会触发页面的重绘或重排。这里就涉及了两个重要概念：Reflow和Repaint。 Reflow，也称作Layout，中文叫回流，一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树，这个过程称为Reflow。 Repaint，中文重绘，意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就OK了，这个过程称为Repaint。 所以说Reflow的成本比Repaint的成本高得多的多。DOM树里的每个结点都会有reflow方法，一个结点的reflow很有可能导致子结点，甚至父点以及同级结点的reflow。 关闭TCP连接或继续保持连接通过四次挥手关闭连接(FIN ACK, ACK, FIN ACK, ACK)。 第一次挥手是浏览器发完数据后，发送FIN请求断开连接。 第二次挥手是服务器发送ACK表示同意，如果在这一次服务器也发送FIN请求断开连接似乎也没有不妥，但考虑到服务器可能还有数据要发送，所以服务器发送FIN应该放在第三次挥手中。 这样浏览器需要返回ACK表示同意，也就是第四次挥手","categories":[],"tags":[]},{"title":"学而页面总结","slug":"学而页面总结","date":"2019-11-06T06:30:16.775Z","updated":"2019-11-08T13:36:09.217Z","comments":true,"path":"2019/11/06/学而页面总结/","link":"","permalink":"http://yoursite.com/2019/11/06/%E5%AD%A6%E8%80%8C%E9%A1%B5%E9%9D%A2%E6%80%BB%E7%BB%93/","excerpt":"","text":"关于HTML和CSS的总结在这两周时间，我写了静态的学而网页并进行了一些修改。在学姐学长的帮助和指导之下，我对网页的一些整体布局有所了解，以下为一些自己在写学而时犯下的错误。HEADER PART1.布局方式不要混用（其实适用于很多地方），flex inline-block 和float最好不要混合使用。 2.尽量减少div的使用。学会思考span和div的使用情况。span作为行内元素，可以用来标记一些行内特殊的元素；div作为块元素，更好的区分出每一个区域。有时候会用很多个div，变成inline-block的样子是因为在行内中出现了不同的功能区。 3.消除间隙。由于行内元素都是有间隙的所以一般需要消除间隙，例如图片与搜索框之间。 4.搜索框的写法，一般是用一个大的div把input和图片包裹起来，设置div的border的颜色来展示边框。 5.实现:hover之后，要确保前后元素的大小一致，这样才美观。 MIDDLE PART1.整体布局，用一个div来使多个中间部分水平居中。 2.在整个页面中最好只采取一种布局方式。 3.position：sticky可以适用于更多的场合，也更符合如今的审美需求。 4.input的样式用CSS来改变 FOOTER PART1.注意字符间距 2.body的margin为0或者padding为0；","categories":[],"tags":[]},{"title":"自适应居中","slug":"自适应居中","date":"2019-11-02T08:35:02.165Z","updated":"2019-11-08T07:51:09.465Z","comments":true,"path":"2019/11/02/自适应居中/","link":"","permalink":"http://yoursite.com/2019/11/02/%E8%87%AA%E9%80%82%E5%BA%94%E5%B1%85%E4%B8%AD/","excerpt":"","text":"关于网页布局中的水平垂直居中一、首先来分享最简单的flex布局中如何居中12345.father&#123; display: flex; justify-content: center;/*水平居中*/ align-items: center;/*垂直居中*/&#125; ​ 这里father指的是夫元素的盒子，对父元素进行设置display: flex;其中的子元素就会变成项目，父元素本身就成为了flex容器。利用flex的一些特性就可以进行居中的布局。 ​ 关于更详细的flex布局，这里有一个链接：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool 二、”display:inline-block”中如何实现居中123456.father&#123; text-align: center;/*水平居中*/&#125;.son&#123; display:inline-block;&#125; ​ 当block变成inline-block时，多个div在一个父元素的容器中，margin: 0 auto；就不再有作用。目前我找到的方法只有在父元素中设置text-align: center;使这些div居中。百度中这么解释到，“我们的行内元素就相当于一行之内的文字了”，我也只能这么理解了。对于div中的文字，我们只能再使用text-align: start；之类的属性来使文字排版更理想化。 1234567891011121314.father&#123; width:auto; height:200px;&#125;.father:after&#123; display:inline-block; height:100%; font-size:0; content: \"\";&#125;.son&#123; display:inline-block; vertical-align: middle;/*垂直居中*/&#125; ​ 这一串css代码是用来inline-block当中的垂直居中问题，可以用于head当中，因为大多时候head定宽，用一个伪元素设置其高度为100%时，将父元素撑开，子元素就垂直居中啦！也适用于多行文字！ 当然如果head之中只有一行文字，在父元素中设置height与line-height相等时，也可以垂直居中，只是会出现一些小问题。比如只是文字居中而div没有居中。（如果div高和head高不相等）三、“display：block”一个block的居中123.son&#123; margin: 0 auto;&#125; ​ 这一串代码十分简洁，十分容易记住，但是一定要找到使用场合。在一个父元素只有一个子元素时，此代码可以时该元素自适应的居中，比较常用于head套用，page整体布局中。 1234.father&#123; height:100px; line-height:100px;&#125; ​ 不多说了，注意只能用于单行文字。会使子元素高度变大。 四、“display: table”的居中1234567.father&#123; display:table;&#125;.son&#123; display:table-cell; vertical-align: middle;&#125; ​ 这种方法适用性不强，因为大多数display属性为block,inlin-block或者flex。再次使用display时可能会改变一些属性。 五、定位123456789101112131415.father&#123; width: 500px; height: 300px; position: relative;&#125;.son&#123; width: 100px; height: 100px; position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto;&#125; ​ 该方法用于son宽高已知！ 1234567891011.father&#123; width: 500px; height: 300px; position: relative;&#125;.son&#123; position: absolute; left: 50%; top: 50%; transform: translateX(-50%) translateY(-50%);&#125; ​ 该方法用于son宽高未知！ 总的来说自适应居中的方法就这些了，如果想看到更多的居中方式可以点击这里访问李雪莲学姐做的总结！！ https://lilixuelian.github.io/2019/05/22/center/","categories":[],"tags":[]}]}