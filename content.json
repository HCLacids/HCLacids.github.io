{"meta":{"title":"HCL's Blog","subtitle":"Recording the study progress","description":"Fighting!","author":"HCLacids","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Closure","slug":"Closure","date":"2020-06-02T08:54:20.269Z","updated":"2020-06-02T14:35:26.474Z","comments":true,"path":"2020/06/02/Closure/","link":"","permalink":"http://yoursite.com/2020/06/02/Closure/","excerpt":"","text":"一、概念1A closure is the combination of a function and the lexical environment within which that function was declared. 二、Lexical Environment（词法环境）​ 这个链接详细介绍了什么是词法环境。 三、区分的两个概念​ 一开始看闭包这个部分的时候一直没有搞懂为什么不能在外部变量访问内部变量的问题，其实是我把两个概念给搞混了。 ​ 为什么不能访问内部变量这个问题很简单，就是局部变量的生存周期与函数的调用时一样，一旦函数调用完毕，这些局部变量就不在存在了。 1234let outter = 1;function ()&#123; let inner = 2;&#125; ​ 而我一开始困惑了很久，就是为什么a.b，这样的就可以访问呢？ 那我搞混的两个概念就是局部变量和对象的属性或者方法。 ​ 局部变量就是上面所说的，那么对象的属性或方法来举例子： 123let a = new Object();//a是一个对象a.b = 2;alert(a.b);","categories":[],"tags":[]},{"title":"Sass","slug":"Sass","date":"2020-04-02T05:26:15.024Z","updated":"2020-04-02T06:25:38.162Z","comments":true,"path":"2020/04/02/Sass/","link":"","permalink":"http://yoursite.com/2020/04/02/Sass/","excerpt":"","text":"Sass学习​ 因为在Taro项目中有用到Sass，但是当时并没有学习所以就分开来写。 一、安装因为Taro项目初始化的时候会自行安装，只要选择Sass就行了。所以这里给出官方链接。https://sass.bootcss.com/install 二、变量变量是存储信息并在将来重复利用的一种方式，在整个样式表中都可访问。 你可以在变量中存储颜色、字体 或任何 CSS 值，并在将来重复利用。Sass 使用 $ 符号 作为变量的标志。 1234567$font-stack: Helvetica, sans-serif;$primary-color: #333;body &#123; font: 100% $font-stack; color: $primary-color;&#125; 1234body &#123; font: 100% Helvetica, sans-serif; color: #333;&#125; 三、嵌套​ 在编写 HTML 时，它有一个清晰的嵌套和可视化层次结构。 而 CSS 则没有。 ​ Sass 允许嵌套 CSS 选择器，嵌套方式 与 HTML 的视觉层次结构相同。请注意，过度嵌套的规则 将导致过度限定的 CSS，这些 CSS 可能很难维护，并且 通常被认为是不好的做法。 ​ 理解了这一点，下面就来看一个典型的网站导航的样式 示例： 123456789101112131415nav &#123; ul &#123; margin: 0; padding: 0; list-style: none; &#125; li &#123; display: inline-block; &#125; a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125;&#125; 12345678910111213nav ul &#123; margin: 0; padding: 0; list-style: none;&#125;nav li &#123; display: inline-block;&#125;nav a &#123; display: block; padding: 6px 12px; text-decoration: none;&#125; 四、片段创建部分Sass文件，其中包含一些CSS片段 ，可以将其包含在其他Sass文件中。这是模块化CSS并帮助使事情易于维护的好方法。部分文件是一个Sass文件，名称前带有一个下划线。可以将其命名为_partial.scss。下划线让Sass知道该文件只是部分文件，不应将其生成为CSS文件。Sass局部函数与@use 规则一起使用。 五、模块不必将所有Sass都写在一个文件中。您可以根据需要将其拆分@use。该规则将另一个Sass文件作为模块加载，这意味着您可以在Sass文件中使用基于文件名的命名空间引用其变量，mixins和函数。使用文件还将在编译输出中包含它生成的CSS！ 12345678// _base.scss$font-stack: Helvetica, sans-serif;$primary-color: #333;body &#123; font: 100% $font-stack; color: $primary-color;&#125; 1234567// styles.scss@use 'base';.inverse &#123; background-color: base.$primary-color; color: white;&#125; 123456789body &#123; font: 100% Helvetica, sans-serif; color: #333;&#125;.inverse &#123; background-color: #333; color: white;&#125; 六、混合​ CSS中的某些内容编写起来有些繁琐，尤其是使用CSS3 和存在的许多供应商前缀时。使用mixin，您可以创建要在整个站点中重复使用的CSS声明组 。您甚至可以传入值以使混入更加灵活。mixin的一个很好的用法是用于供应商前缀。这是的示例 transform。 123456@mixin transform($property) &#123; -webkit-transform: $property; -ms-transform: $property; transform: $property;&#125;.box &#123; @include transform(rotate(30deg)); &#125; 12345.box &#123; -webkit-transform: rotate(30deg); -ms-transform: rotate(30deg); transform: rotate(30deg);&#125; 要创建一个mixin，请使用@mixin指令并为其命名。我们将其命名为mixin transform。我们还在$property括号内使用了变量 ，因此我们可以传递任何所需的变换。创建混入之后，您可以将其用作CSS 声明@include，以混入的名称开头。 七、扩展继承​ 这是Sass最有用的功能之一。使用@extend使您可以将一组CSS属性从一个选择器共享到另一个选择器。它有助于使Sass保持非常干燥。在我们的示例中，我们将使用扩展，占位符类一起使用的另一个功能，为错误，警告和成功创建一系列简单的消息传递。占位符类是一种特殊的类，仅在扩展时才打印，并且可以帮助保持编译后的CSS整洁。 12345678910111213141516171819202122232425262728293031/* This CSS will print because %message-shared is extended. */%message-shared &#123; border: 1px solid #ccc; padding: 10px; color: #333;&#125;// This CSS won't print because %equal-heights is never extended.%equal-heights &#123; display: flex; flex-wrap: wrap;&#125;.message &#123; @extend %message-shared;&#125;.success &#123; @extend %message-shared; border-color: green;&#125;.error &#123; @extend %message-shared; border-color: red;&#125;.warning &#123; @extend %message-shared; border-color: yellow;&#125; 123456789101112131415161718/* This CSS will print because %message-shared is extended. */.message, .success, .error, .warning &#123; border: 1px solid #ccc; padding: 10px; color: #333;&#125;.success &#123; border-color: green;&#125;.error &#123; border-color: red;&#125;.warning &#123; border-color: yellow;&#125; ​ 上面的代码的作用是告诉.message，.success，.error，和.warning做人一样%message-shared。这意味着任何地方%message-shared显示来，.message，.success，.error，和 .warning也会这样做的。魔术发生在生成的CSS中，其中每个类将获得与相同的CSS属性%message-shared。这有助于您避免在HTML 元素上编写多个类名。 ​ 除了Sass中的占位符类之外，您还可以扩展最简单的CSS选择器，但是使用占位符是确保不扩展嵌套在样式中其他位置的类的最简单方法，这会导致CSS中意外的选择器 。 ​ 请注意，不会生成CSS in %equal-heights，因为%equal-heights它不会被扩展。 八、操作符​ 在 CSS 中经常需要做数学计算。Sass 支持一些标准的 数学运算符，例如 +、-、*、/ 和 %。在下面的例子中，我们 将做一些简单的数学运算来计算出 aside &amp; article 的宽度。 12345678910111213.container &#123; width: 100%;&#125;article[role=\"main\"] &#123; float: left; width: 600px / 960px * 100%;&#125;aside[role=\"complementary\"] &#123; float: right; width: 300px / 960px * 100%;&#125;","categories":[],"tags":[]},{"title":"孤独星球--Taro框架总结","slug":"孤独星球--Taro框架总结","date":"2020-04-01T15:30:56.708Z","updated":"2020-04-01T17:02:39.079Z","comments":true,"path":"2020/04/01/孤独星球--Taro框架总结/","link":"","permalink":"http://yoursite.com/2020/04/01/%E5%AD%A4%E7%8B%AC%E6%98%9F%E7%90%83--Taro%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/","excerpt":"","text":"孤独星球–Taro框架总结​ 大一下学期用Taro框架写了QQ的小程序–孤独星球，项目链接在这里。https://github.com/The-Planet-of-Loneline/project ​ 项目分为白天和黑夜两个部分，白天是同组的刘安完成的，技术含量也比较高；黑夜和登录部分就是由我完成的。接下来就说一下Taro里面的一些细节。 一、项目结构​ 因为一开始没有去参照学姐学长做的客栈的框架，所以这个项目的框架比较乱，一些组件的页面的位置也存放的不正确。希望以后的项目能够把公共组件和私有组件分开，组件和页面分开以形成更明晰的结构。以下是参照木犀客栈的结构： 123456789101112131415--src --assets //存放图片 --png --svg --components //存放组件 --common //公用组件 --index //私有组件 --pages //页面 --index --index.jsx --service //Fech API --Fech.jsx --app.jsx //配置 --app.scss //样式 --index.html //接口 一般来说一个项目的结构就如上所示了。 二、Taro内置组件​ 刚刚开始写静态页面的时候使用错了组件，还是用的HTML的标签&lt;div&gt; &lt;span&gt;等。要注意以下代码的含义： 12import Taro, &#123; Component &#125; from '@tarojs/taro'import &#123; View, Text,Image &#125; from '@tarojs/components' ​ Taro里面有内置的组件使用，&lt;View&gt; &lt;Text&gt;等类似于HTML中的标签使用。要注意的是，HTML中使用的class选择器，class关键字要改变成classname，因为关键字的保留class类。 这里的import也是webpack的方法吧，引入你需要的组件例如黑夜的头部和底部： 12import Head from '../component/Head'import Footer from '../component/Footer' 一定要from正确的路径&#39;../&#39;是返回上一级目录，也可以返回多次。 三、Taro中的输入框​ Taro中的输入框也是Taro当中的内置组件也分为input和textarea，但是要大写&lt;Input /&gt; &lt;Textarea /&gt;，这里顺便提一下Taro里面所有组件开头都要大写。 ​ 输入框输入值的时候value要空，且还有监听事件函数onInput，onChange也可以。但是比较坑的事，onInput函数对于Input和Textarea不同。当时产品组给我提的要求是控制行数限制，这里也要说一下Textarea的特性，有换行的监听函数。但是由于onInput对于Textarea的value的改变不能显示于Textarea，而可以显示于Input。最后也是需求改成了字数限制。 12345678910&lt;Textarea className='write' value=&#123;Value&#125; onInput=&#123;this.handleInputChange.bind(this)&#125; onFocus=&#123;this.handleInput.bind(this)&#125;onBlur=&#123;this.handleback.bind(this)&#125; showConfirmBar=&#123;false&#125;maxlength=&#123;75&#125;autoFocus=&#123;true&#125;&gt;&lt;/Textarea&gt; ​ 组件的写法可以这样换行以更醒目的看见，太长不方便查看。但是一些View好像就不行。 四、API​ 写整个项目前最重要的就是沟通，和产品沟通和后端沟通。没有沟通好的后果就是白天好像重新写页面的结构。还好因为黑夜也不难，所以没有做好沟通也影响不大。其中我觉得比较重要的是分页这个部分。因为要考虑到页面的实际需求来看分页的形式和需不需要分页。参考swaggerUI是一个很重要的东西，一定要反复比对。 123456789101112131415onReachBottom()&#123; if (this.state.history.length % 5 == 0) &#123; this.setState(&#123; page: this.state.page + 1 &#125;, () =&gt; &#123; Fetch(`secret/history?page=$&#123;this.state.page&#125;`, &#123;&#125;, 'GET').then(res =&gt; &#123; this.setState(&#123; history: this.state.history.concat(res.history) &#125;) &#125;) &#125;) &#125;&#125; ​ 这里是一个后端的分页方法，需要的事我每一次请求时发送一个页面数字给后端，他再返回给我对应数字的内容。这种分页方法个人感觉比较适合网页，而不适合小程序去写。所以我加了限定条件只有显示内容为5个时候才会进行下一次的请求。 ​ API的路径一定要对，我举例困扰我很久的删除功能。 1234567891011121314handleDelete()&#123; Fetch(`secret/delete/:secret_id/?secretId=$&#123;this.props.Debunkid&#125;`, &#123;&#125;, 'DELETE').then(res =&gt; &#123; Taro.showToast(&#123; title: '删除成功', icon: 'none' &#125;) this.props.onCloseDelete() Taro.reLaunch(&#123; url:`/pages/Mine/Mine` &#125;) &#125;) &#125; ​ 这里因为我少了一个/导致我应该不能与后端连接，但是开发者工具可以我也就没有想太多。牢记！！ 五、QQ授权和分享​ QQ授权和分享是要过审核必须写的一个API，我们也是事后才写的。 1&lt;Button open-type='getUserInfo' className='login' onClick=&#123;this.power&#125;&gt;登录&lt;/Button&gt; 12345678910power () &#123; Taro.getSetting(&#123; success: (res) =&gt; &#123; this.setState(&#123; powered:res.authSetting['scope.userInfo']&#125;) if (res.authSetting['scope.userInfo']) &#123; this.onHandleLogin() &#125; &#125; &#125;) &#125; 123Taro.showShareMenu(&#123; showShareItems: ['qq', 'qzone', 'wechatFriends', 'wechatMoment'] &#125;) 第一二个代码块是处理授权的部分，第三个是分享。","categories":[],"tags":[]},{"title":"浏览器输入URL后发生了什么","slug":"浏览器输入URL后发生了什么","date":"2019-11-20T07:15:20.193Z","updated":"2019-12-08T01:13:08.716Z","comments":true,"path":"2019/11/20/浏览器输入URL后发生了什么/","link":"","permalink":"http://yoursite.com/2019/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/","excerpt":"","text":"当我们在浏览器的网址栏输入网址并回车后，一个网页页面就呈现在我们面前。我们有没有思考过浏览器时如何将一个内容丰富的页面给“变”出来的呢？ 基本步骤 浏览器的地址栏输入URL并按下回车。 浏览器查找当前URL是否存在缓存，并比较缓存是否过期。 DNS解析URL对应的IP。 根据IP建立TCP（三次握手）。 HTTP发出请求。 服务器处理请求，浏览器接受HTTP请求。 渲染页面，构建DOM树。 关闭TCP连接（四次挥手）。 URLURL的格式 protocol://hostname[:port]/path/[;parameters] [?query]#fragment protocal,协议头，比如http，https等 host，主机域名或IP地址 port，端口号一般为默认指所以隐藏起来 path，目录路径 query，查询参数 fragment，#后hash值，一般用来定位到某个位置 缓存浏览器会对你输入的网址进行判断，有缓存或无。有缓存则直接加载，无则向服务器发出请求。 DNS域名解析​ 我们知道在地址栏输入的域名并不是最后资源所在的真实位置，域名只是与IP地址的一个映射。网络服务器的IP地址那么多，我们不可能去记一串串的数字，因此域名就产生了，域名解析的过程实际是将域名还原为IP地址的过程。 首先浏览器先检查本地hosts文件是否有这个网址映射关系，如果有就调用这个IP地址映射，完成域名解析。 如果没找到则会查找本地DNS解析器缓存，如果查找到则返回。如果还是没有找到则会查找本地DNS服务器，如果查找到则返回。 ​ TCP链接拿到服务器IP地址则进行三次握手的连接。 客户端发送一个带有SYN标志的数据包给服务端，服务端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息，最后客户端再回传一个带ACK标志的数据包，代表握手结束，连接成功。 发送HTTP请求 与服务器建立了连接后，就可以向服务器发起请求了。这里我们先看下请求报文的结构（如下图）： 请求报文在浏览器中查看报文首部（以google浏览器为例）： ​ 请求行包括请求方法、URI、HTTP版本。首部字段传递重要信息，包括请求首部字段、通用首部字段和实体首部字段。我们可以从报文中看到发出的请求的具体信息。 请求报文的简要分析 服务器处理请求​ 服务器端收到请求后的由web服务器（准确说应该是http服务器）处理请求，诸如Apache、Ngnix、IIS等。web服务器解析用户请求，知道了需要调度哪些资源文件，再通过相应的这些资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过web服务器返回给浏览器客户端。 返回响应结果在HTTP里，有请求就会有响应，哪怕是错误信息。这里我们同样看下响应报文的组成结构： 响应报文 在响应结果中都会有个一个HTTP状态码，比如我们熟知的200、301、404、500等。通过这个状态码我们可以知道服务器端的处理是否正常，并能了解具体的错误。 状态码由3位数字和原因短语组成。根据首位数字，状态码可以分为五类： 1xx：指示信息–表示请求已接收，继续处理。 2xx：成功–表示请求已被成功接收、理解、接受。 3xx：重定向–要完成请求必须进行更进一步的操作。 4xx：客户端错误–请求有语法错误或请求无法实现。 5xx：服务器端错误–服务器未能实现合法的请求。 页面渲染前面有提到http交互，那么接下来就是浏览器获取到html，然后解析，渲染 解析HTML，构建DOM树 解析CSS，生成CSS规则树 合并DOM树和CSS规则，生成render树 布局render树（Layout/reflow），负责各元素尺寸、位置的计算 绘制render树（paint），绘制页面像素信息 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上 如下图： DOM tree CSSOM tree render tree 在浏览器还没接收到完整的 HTML 文件时，它就开始渲染页面了，在遇到外部链入的脚本标签或样式标签或图片时，会再次发送 HTTP 请求重复上述的步骤。在收到 CSS 文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完立刻显示在相应位置。在这一过程中可能会触发页面的重绘或重排。这里就涉及了两个重要概念：Reflow和Repaint。 Reflow，也称作Layout，中文叫回流，一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树，这个过程称为Reflow。 Repaint，中文重绘，意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就OK了，这个过程称为Repaint。 所以说Reflow的成本比Repaint的成本高得多的多。DOM树里的每个结点都会有reflow方法，一个结点的reflow很有可能导致子结点，甚至父点以及同级结点的reflow。 关闭TCP连接或继续保持连接通过四次挥手关闭连接(FIN ACK, ACK, FIN ACK, ACK)。 第一次挥手是浏览器发完数据后，发送FIN请求断开连接。 第二次挥手是服务器发送ACK表示同意，如果在这一次服务器也发送FIN请求断开连接似乎也没有不妥，但考虑到服务器可能还有数据要发送，所以服务器发送FIN应该放在第三次挥手中。 这样浏览器需要返回ACK表示同意，也就是第四次挥手","categories":[],"tags":[]},{"title":"学而页面总结","slug":"学而页面总结","date":"2019-11-06T06:30:16.775Z","updated":"2019-11-08T13:36:09.217Z","comments":true,"path":"2019/11/06/学而页面总结/","link":"","permalink":"http://yoursite.com/2019/11/06/%E5%AD%A6%E8%80%8C%E9%A1%B5%E9%9D%A2%E6%80%BB%E7%BB%93/","excerpt":"","text":"关于HTML和CSS的总结在这两周时间，我写了静态的学而网页并进行了一些修改。在学姐学长的帮助和指导之下，我对网页的一些整体布局有所了解，以下为一些自己在写学而时犯下的错误。HEADER PART1.布局方式不要混用（其实适用于很多地方），flex inline-block 和float最好不要混合使用。 2.尽量减少div的使用。学会思考span和div的使用情况。span作为行内元素，可以用来标记一些行内特殊的元素；div作为块元素，更好的区分出每一个区域。有时候会用很多个div，变成inline-block的样子是因为在行内中出现了不同的功能区。 3.消除间隙。由于行内元素都是有间隙的所以一般需要消除间隙，例如图片与搜索框之间。 4.搜索框的写法，一般是用一个大的div把input和图片包裹起来，设置div的border的颜色来展示边框。 5.实现:hover之后，要确保前后元素的大小一致，这样才美观。 MIDDLE PART1.整体布局，用一个div来使多个中间部分水平居中。 2.在整个页面中最好只采取一种布局方式。 3.position：sticky可以适用于更多的场合，也更符合如今的审美需求。 4.input的样式用CSS来改变 FOOTER PART1.注意字符间距 2.body的margin为0或者padding为0；","categories":[],"tags":[]},{"title":"自适应居中","slug":"自适应居中","date":"2019-11-02T08:35:02.165Z","updated":"2019-11-08T07:51:09.465Z","comments":true,"path":"2019/11/02/自适应居中/","link":"","permalink":"http://yoursite.com/2019/11/02/%E8%87%AA%E9%80%82%E5%BA%94%E5%B1%85%E4%B8%AD/","excerpt":"","text":"关于网页布局中的水平垂直居中一、首先来分享最简单的flex布局中如何居中12345.father&#123; display: flex; justify-content: center;/*水平居中*/ align-items: center;/*垂直居中*/&#125; ​ 这里father指的是夫元素的盒子，对父元素进行设置display: flex;其中的子元素就会变成项目，父元素本身就成为了flex容器。利用flex的一些特性就可以进行居中的布局。 ​ 关于更详细的flex布局，这里有一个链接：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool 二、”display:inline-block”中如何实现居中123456.father&#123; text-align: center;/*水平居中*/&#125;.son&#123; display:inline-block;&#125; ​ 当block变成inline-block时，多个div在一个父元素的容器中，margin: 0 auto；就不再有作用。目前我找到的方法只有在父元素中设置text-align: center;使这些div居中。百度中这么解释到，“我们的行内元素就相当于一行之内的文字了”，我也只能这么理解了。对于div中的文字，我们只能再使用text-align: start；之类的属性来使文字排版更理想化。 1234567891011121314.father&#123; width:auto; height:200px;&#125;.father:after&#123; display:inline-block; height:100%; font-size:0; content: \"\";&#125;.son&#123; display:inline-block; vertical-align: middle;/*垂直居中*/&#125; ​ 这一串css代码是用来inline-block当中的垂直居中问题，可以用于head当中，因为大多时候head定宽，用一个伪元素设置其高度为100%时，将父元素撑开，子元素就垂直居中啦！也适用于多行文字！ 当然如果head之中只有一行文字，在父元素中设置height与line-height相等时，也可以垂直居中，只是会出现一些小问题。比如只是文字居中而div没有居中。（如果div高和head高不相等）三、“display：block”一个block的居中123.son&#123; margin: 0 auto;&#125; ​ 这一串代码十分简洁，十分容易记住，但是一定要找到使用场合。在一个父元素只有一个子元素时，此代码可以时该元素自适应的居中，比较常用于head套用，page整体布局中。 1234.father&#123; height:100px; line-height:100px;&#125; ​ 不多说了，注意只能用于单行文字。会使子元素高度变大。 四、“display: table”的居中1234567.father&#123; display:table;&#125;.son&#123; display:table-cell; vertical-align: middle;&#125; ​ 这种方法适用性不强，因为大多数display属性为block,inlin-block或者flex。再次使用display时可能会改变一些属性。 五、定位123456789101112131415.father&#123; width: 500px; height: 300px; position: relative;&#125;.son&#123; width: 100px; height: 100px; position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto;&#125; ​ 该方法用于son宽高已知！ 1234567891011.father&#123; width: 500px; height: 300px; position: relative;&#125;.son&#123; position: absolute; left: 50%; top: 50%; transform: translateX(-50%) translateY(-50%);&#125; ​ 该方法用于son宽高未知！ 总的来说自适应居中的方法就这些了，如果想看到更多的居中方式可以点击这里访问李雪莲学姐做的总结！！ https://lilixuelian.github.io/2019/05/22/center/","categories":[],"tags":[]}]}