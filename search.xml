<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浏览器输入URL后发生了什么</title>
      <link href="/2019/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
      <url>/2019/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>当我们在浏览器的网址栏输入网址并回车后，一个网页页面就呈现在我们面前。我们有没有思考过浏览器时如何将一个内容丰富的页面给“变”出来的呢？</p><h1 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h1><ol><li>浏览器的地址栏输入URL并按下回车。</li><li>浏览器查找当前URL是否存在缓存，并比较缓存是否过期。</li><li>DNS解析URL对应的IP。</li><li>根据IP建立TCP（三次握手）。</li><li>HTTP发出请求。</li><li>服务器处理请求，浏览器接受HTTP请求。</li><li>渲染页面，构建DOM树。</li><li>关闭TCP连接（四次挥手）。</li></ol><h1 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h1><p>URL的格式</p><p>protocol://hostname[:port]/path/[;parameters] [?query]#fragment</p><ul><li>protocal,协议头，比如http，https等</li><li>host，主机域名或IP地址</li><li>port，端口号一般为默认指所以隐藏起来</li><li>path，目录路径</li><li>query，查询参数</li><li>fragment，#后hash值，一般用来定位到某个位置</li></ul><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>浏览器会对你输入的网址进行判断，有缓存或无。有缓存则直接加载，无则向服务器发出请求。</p><h1 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h1><p>​        我们知道在地址栏输入的域名并不是最后资源所在的真实位置，域名只是与IP地址的一个映射。网络服务器的IP地址那么多，我们不可能去记一串串的数字，因此域名就产生了，<strong>域名解析的过程实际是将域名还原为IP地址的过程</strong>。 首先浏览器先检查本地hosts文件是否有这个网址映射关系，如果有就调用这个IP地址映射，完成域名解析。 如果没找到则会查找本地DNS解析器缓存，如果查找到则返回。如果还是没有找到则会查找本地DNS服务器，如果查找到则返回。</p><p><img src="https://image-static.segmentfault.com/109/829/1098299099-5a1397c093c97" alt="img"> </p><p>​        </p><p><img src="https://image-static.segmentfault.com/160/418/1604181361-5a1397cca5644" alt="img"> </p><h1 id="TCP链接"><a href="#TCP链接" class="headerlink" title="TCP链接"></a>TCP链接</h1><p>拿到服务器IP地址则进行三次握手的连接。 </p><p> <img src="https://image-static.segmentfault.com/336/916/3369169780-5a1397e92a68c" alt="img"> </p><p>客户端发送一个带有SYN标志的数据包给服务端，服务端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息，最后客户端再回传一个带ACK标志的数据包，代表握手结束，连接成功。 </p><h1 id="发送HTTP请求"><a href="#发送HTTP请求" class="headerlink" title="发送HTTP请求"></a>发送HTTP请求</h1><p> `与服务器建立了连接后，就可以向服务器发起请求了。这里我们先看下请求报文的结构（如下图）： <img src="https://image-static.segmentfault.com/194/760/1947600223-5a1397f9f0773" alt="img"> </p><p>请求报文<br>在浏览器中查看报文首部（以google浏览器为例）：<br><img src="https://segmentfault.com/img/bVYTYo?w=366&h=273" alt="图片描述"></p><p>​        请求行包括请求方法、URI、HTTP版本。首部字段传递重要信息，包括请求首部字段、通用首部字段和实体首部字段。我们可以从报文中看到发出的请求的具体信息。</p><p>请求报文的简要分析</p><p><img src="C:%5CUsers%5C%E9%9F%A9%E6%99%A8%E9%BE%99%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191120160027373.png" alt="image-20191120160027373"></p><h1 id="服务器处理请求"><a href="#服务器处理请求" class="headerlink" title="服务器处理请求"></a>服务器处理请求</h1><p>​        服务器端收到请求后的由web服务器（准确说应该是http服务器）处理请求，诸如Apache、Ngnix、IIS等。web服务器解析用户请求，知道了需要调度哪些资源文件，再通过相应的这些资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过web服务器返回给浏览器客户端。</p><p>  <img src="https://image-static.segmentfault.com/159/660/1596606314-5a1259320ba22" alt="img"> </p><h1 id="返回响应结果"><a href="#返回响应结果" class="headerlink" title="返回响应结果"></a>返回响应结果</h1><p>在HTTP里，有请求就会有响应，哪怕是错误信息。这里我们同样看下响应报文的组成结构： </p><p><img src="https://image-static.segmentfault.com/915/283/915283550-5a13982ea260a" alt="img"> </p><p>响应报文</p><p>在响应结果中都会有个一个HTTP状态码，比如我们熟知的200、301、404、500等。通过这个状态码我们可以知道服务器端的处理是否正常，并能了解具体的错误。</p><p>状态码由3位数字和原因短语组成。根据首位数字，状态码可以分为五类：</p><ul><li>1xx：指示信息–表示请求已接收，继续处理。</li><li>2xx：成功–表示请求已被成功接收、理解、接受。</li><li>3xx：重定向–要完成请求必须进行更进一步的操作。</li><li>4xx：客户端错误–请求有语法错误或请求无法实现。</li><li>5xx：服务器端错误–服务器未能实现合法的请求。</li></ul><h1 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h1><p>前面有提到http交互，那么接下来就是浏览器获取到html，然后解析，渲染</p><ol><li><p>解析HTML，构建DOM树</p></li><li><p>解析CSS，生成CSS规则树</p></li><li><p>合并DOM树和CSS规则，生成render树</p></li><li><p>布局render树（Layout/reflow），负责各元素尺寸、位置的计算</p></li><li><p>绘制render树（paint），绘制页面像素信息</p></li><li><p>浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上<br> 如下图：</p></li></ol><p>  <img src="https://upload-images.jianshu.io/upload_images/6007177-342d73de2a8bdc2e.png" alt="img">  </p><p> DOM tree <img src="https://upload-images.jianshu.io/upload_images/6007177-8ec45fe7dd4d5b00.png" alt="img"> </p><p>CSSOM tree </p><p> <img src="https://upload-images.jianshu.io/upload_images/6007177-889050efeb3c811d.png" alt="img"> </p><p>render tree</p><ul><li>在浏览器还没接收到完整的 HTML 文件时，它就开始渲染页面了，在遇到外部链入的脚本标签或样式标签或图片时，会再次发送 HTTP 请求重复上述的步骤。在收到 CSS 文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完立刻显示在相应位置。在这一过程中可能会触发页面的重绘或重排。这里就涉及了两个重要概念：Reflow和Repaint。</li><li>Reflow，也称作Layout，中文叫回流，一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树，这个过程称为Reflow。</li><li>Repaint，中文重绘，意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就OK了，这个过程称为Repaint。</li><li>所以说Reflow的成本比Repaint的成本高得多的多。DOM树里的每个结点都会有reflow方法，一个结点的reflow很有可能导致子结点，甚至父点以及同级结点的reflow。</li></ul><h1 id="关闭TCP连接或继续保持连接"><a href="#关闭TCP连接或继续保持连接" class="headerlink" title="关闭TCP连接或继续保持连接"></a>关闭TCP连接或继续保持连接</h1><p>通过四次挥手关闭连接(FIN ACK, ACK, FIN ACK, ACK)。</p><p> <img src="https://image-static.segmentfault.com/419/355/4193550114-5a125931047be" alt="img"> </p><ul><li>第一次挥手是浏览器发完数据后，发送FIN请求断开连接。</li><li>第二次挥手是服务器发送ACK表示同意，如果在这一次服务器也发送FIN请求断开连接似乎也没有不妥，但考虑到服务器可能还有数据要发送，所以服务器发送FIN应该放在第三次挥手中。</li><li>这样浏览器需要返回ACK表示同意，也就是第四次挥手</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学而页面总结</title>
      <link href="/2019/11/06/%E5%AD%A6%E8%80%8C%E9%A1%B5%E9%9D%A2%E6%80%BB%E7%BB%93/"/>
      <url>/2019/11/06/%E5%AD%A6%E8%80%8C%E9%A1%B5%E9%9D%A2%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="关于HTML和CSS的总结"><a href="#关于HTML和CSS的总结" class="headerlink" title="关于HTML和CSS的总结"></a>关于HTML和CSS的总结</h1><h6 id="在这两周时间，我写了静态的学而网页并进行了一些修改。在学姐学长的帮助和指导之下，我对网页的一些整体布局有所了解，以下为一些自己在写学而时犯下的错误。"><a href="#在这两周时间，我写了静态的学而网页并进行了一些修改。在学姐学长的帮助和指导之下，我对网页的一些整体布局有所了解，以下为一些自己在写学而时犯下的错误。" class="headerlink" title="在这两周时间，我写了静态的学而网页并进行了一些修改。在学姐学长的帮助和指导之下，我对网页的一些整体布局有所了解，以下为一些自己在写学而时犯下的错误。"></a>在这两周时间，我写了静态的学而网页并进行了一些修改。在学姐学长的帮助和指导之下，我对网页的一些整体布局有所了解，以下为一些自己在写学而时犯下的错误。</h6><h4 id="HEADER-PART"><a href="#HEADER-PART" class="headerlink" title="HEADER PART"></a>HEADER PART</h4><p>1.布局方式不要混用（其实适用于很多地方），<code>flex</code> <code>inline-block</code> 和<code>float</code>最好不要混合使用。</p><p>2.尽量减少div的使用。学会思考<code>span</code>和<code>div</code>的使用情况。<code>span</code>作为行内元素，可以用来标记一些行内特殊的元素；<code>div</code>作为块元素，更好的区分出每一个区域。有时候会用很多个<code>div</code>，变成<code>inline-block</code>的样子是因为在行内中出现了不同的功能区。</p><p>3.消除间隙。由于行内元素都是有间隙的所以一般需要消除间隙，例如图片与搜索框之间。</p><p>4.搜索框的写法，一般是用一个大的<code>div</code>把<code>input</code>和图片包裹起来，设置<code>div</code>的<code>border</code>的颜色来展示边框。</p><p>5.实现<code>:hover</code>之后，要确保前后元素的大小一致，这样才美观。</p><h4 id="MIDDLE-PART"><a href="#MIDDLE-PART" class="headerlink" title="MIDDLE PART"></a>MIDDLE PART</h4><p>1.整体布局，用一个<code>div</code>来使多个中间部分水平居中。</p><p>2.在整个页面中最好只采取一种布局方式。</p><p>3.<code>position：sticky</code>可以适用于更多的场合，也更符合如今的审美需求。</p><p>4.<code>input</code>的样式用CSS来改变</p><h4 id="FOOTER-PART"><a href="#FOOTER-PART" class="headerlink" title="FOOTER PART"></a>FOOTER PART</h4><p>1.注意字符间距</p><p>2.<code>body</code>的<code>margin</code>为0或者<code>padding</code>为0；</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>自适应居中</title>
      <link href="/2019/11/02/%E8%87%AA%E9%80%82%E5%BA%94%E5%B1%85%E4%B8%AD/"/>
      <url>/2019/11/02/%E8%87%AA%E9%80%82%E5%BA%94%E5%B1%85%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="关于网页布局中的水平垂直居中"><a href="#关于网页布局中的水平垂直居中" class="headerlink" title="关于网页布局中的水平垂直居中"></a>关于网页布局中的水平垂直居中</h1><h3 id="一、首先来分享最简单的flex布局中如何居中"><a href="#一、首先来分享最简单的flex布局中如何居中" class="headerlink" title="一、首先来分享最简单的flex布局中如何居中"></a>一、首先来分享最简单的flex布局中如何居中</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;<span class="comment">/*水平居中*/</span></span><br><span class="line">    <span class="attribute">align-items</span>: center;<span class="comment">/*垂直居中*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这里father指的是夫元素的盒子，对父元素进行设置<code>display: flex;</code>其中的子元素就会变成项目，父元素本身就成为了flex容器。利用flex的一些特性就可以进行居中的布局。</p><p>​        关于更详细的flex布局，这里有一个链接：<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool</a></p><h3 id="二、”display-inline-block”中如何实现居中"><a href="#二、”display-inline-block”中如何实现居中" class="headerlink" title="二、”display:inline-block”中如何实现居中"></a>二、”display:inline-block”中如何实现居中</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;<span class="comment">/*水平居中*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        当block变成inline-block时，多个div在一个父元素的容器中，<code>margin: 0 auto；</code>就不再有作用。目前我找到的方法只有在父元素中设置<code>text-align: center;</code>使这些div居中。百度中这么解释到，“我们的行内元素就相当于一行之内的文字了”，我也只能这么理解了。对于div中的文字，我们只能再使用<code>text-align: start；</code>之类的属性来使文字排版更理想化。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:auto;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.father</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;<span class="comment">/*垂直居中*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这一串css代码是用来inline-block当中的垂直居中问题，可以用于head当中，因为大多时候head定宽，用一个伪元素设置其高度为100%时，将父元素撑开，子元素就垂直居中啦！也适用于多行文字！</p><h6 id="当然如果head之中只有一行文字，在父元素中设置height与line-height相等时，也可以垂直居中，只是会出现一些小问题。比如只是文字居中而div没有居中。（如果div高和head高不相等）"><a href="#当然如果head之中只有一行文字，在父元素中设置height与line-height相等时，也可以垂直居中，只是会出现一些小问题。比如只是文字居中而div没有居中。（如果div高和head高不相等）" class="headerlink" title="当然如果head之中只有一行文字，在父元素中设置height与line-height相等时，也可以垂直居中，只是会出现一些小问题。比如只是文字居中而div没有居中。（如果div高和head高不相等）"></a>当然如果head之中只有一行文字，在父元素中设置height与line-height相等时，也可以垂直居中，只是会出现一些小问题。比如只是文字居中而div没有居中。（如果div高和head高不相等）</h6><h3 id="三、“display：block”一个block的居中"><a href="#三、“display：block”一个block的居中" class="headerlink" title="三、“display：block”一个block的居中"></a>三、“display：block”一个block的居中</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这一串代码十分简洁，十分容易记住，但是一定要找到使用场合。在一个父元素只有一个子元素时，此代码可以时该元素自适应的居中，比较常用于head套用，page整体布局中。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>:<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        不多说了，注意只能用于单行文字。会使子元素高度变大。</p><h3 id="四、“display-table”的居中"><a href="#四、“display-table”的居中" class="headerlink" title="四、“display: table”的居中"></a>四、“display: table”的居中</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:table-cell;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这种方法适用性不强，因为大多数display属性为block,inlin-block或者flex。再次使用display时可能会改变一些属性。</p><h3 id="五、定位"><a href="#五、定位" class="headerlink" title="五、定位"></a>五、定位</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        该方法用于son宽高已知！</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-50%) <span class="built_in">translateY</span>(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        该方法用于son宽高未知！</p><h6 id="总的来说自适应居中的方法就这些了，如果想看到更多的居中方式可以点击这里访问李雪莲学姐做的总结！！"><a href="#总的来说自适应居中的方法就这些了，如果想看到更多的居中方式可以点击这里访问李雪莲学姐做的总结！！" class="headerlink" title="总的来说自适应居中的方法就这些了，如果想看到更多的居中方式可以点击这里访问李雪莲学姐做的总结！！"></a>总的来说自适应居中的方法就这些了，如果想看到更多的居中方式可以点击这里访问李雪莲学姐做的总结！！</h6><p> <a href="https://lilixuelian.github.io/2019/05/22/center/" target="_blank" rel="noopener">https://lilixuelian.github.io/2019/05/22/center/</a> </p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
