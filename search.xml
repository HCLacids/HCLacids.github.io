<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端部署--Docker CI 七牛云</title>
      <link href="/2021/03/02/%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2--Docker%20CI%20%E4%B8%83%E7%89%9B%E4%BA%91/"/>
      <url>/2021/03/02/%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2--Docker%20CI%20%E4%B8%83%E7%89%9B%E4%BA%91/</url>
      
        <content type="html"><![CDATA[<p>​        这一次的年终项目最后完成之后要进行部署到服务器。又考虑到团队服务器的负担问题，我们需要把静态资源上传到七牛云上。最后生成镜像Image给后端部署就完成了。</p><hr><p>​        什么是部署？</p><p>​        在了解部署之前，我们要先知道基本的计网的一些知识。我们通过浏览器打开网页时，客户端（Client），这里也是浏览器（Browser），通过向我们输入的URL找到远方的服务器请求到一些文件，HMTL、CSS、JS、PNG等。而HTML文件当中引入的Script标签会再和CSS、JS、PNG文件渲染成我们所看到的页面。DOMTree和CSSOM结合。由于我们自己服务器带宽的原因，下载速度会很慢。所以我们需要将上诉服务器请求到的静态文件上传到cdn，将生成的镜像给后端部署。整个前端部署就结束了。</p><p>​        所谓部署，就是让开发出的产品能够在某一环境中运行起来。</p><hr><p>​        Docker</p><p>​        为什么需要Docker？<a href="https://zhuanlan.zhihu.com/p/54512286" target="_blank" rel="noopener">知乎</a></p><p>​        Docker本质上就是一个容器，它可以将代码放在一个里面，隔绝外部，形成一个封闭的环境。我们部署的某一环境可以是Docker容器所形成的一种。<a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">阮一峰</a></p><p>​         了解了Docker的基础知识和Dockerflie的写法，我们再看看在前端项目里面如何编写Dockerfile。<a href="https://segmentfault.com/a/1190000022144895" target="_blank" rel="noopener">segmentfault</a></p><p>​        Nignix</p><p>​        不多讲<a href="http://gitea.muxixyz.com/root/huashidaxigua-h5" target="_blank" rel="noopener">Gitea仓库</a></p><p>​        自动化部署</p><p>​         自动部署就是在你提交代码之后，就能在服务器触发代码打包和运行，再也不用进行手动打包代码、提交代码这种重复又没有意义的工作，极大地解放了劳动力。</p><p>​        在上上一篇文章的后记中，说实现自动化部署要结合jenkins使用。而我们使用的是Drone CI 自动部署的方法。<a href="https://www.drone.io/" target="_blank" rel="noopener">Drone</a></p><p>​        </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React Redux</title>
      <link href="/2020/10/30/React%20Redux/"/>
      <url>/2020/10/30/React%20Redux/</url>
      
        <content type="html"><![CDATA[<h1 id="Connect"><a href="#Connect" class="headerlink" title="Connect()"></a><code>Connect()</code></h1><p><code>Connect()</code>是连接<code>React</code>和<code>Redux store</code>的函数。</p><p>它可以从<code>Store</code>当中拿出一些碎片的数据，传递给和它相连的组件。函数还可以发送一些<code>action</code>给<code>Store</code>。</p><p>它不会修改传递给它的组件类。而是返回一个新的，已连接的组件类，该类包含传入的组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">mapStateToProps?, mapDispatchToProps?, mergeProps?, options?</span>)</span></span><br></pre></td></tr></table></figure><p><code>mapStateToProps</code>和<code>mapDispatchToProps</code>分别处理的是<code>Redux Store</code>的<code>state</code>数据和<code>dispatch</code>方法。</p><p>函数返回的<code>mapStateToProps</code>和<code>mapDispatchToProps</code>分别指向组件内部的<code>stateProps</code>和<code>dispatchProps</code>。</p><h2 id="connect-参数"><a href="#connect-参数" class="headerlink" title="connect() 参数"></a><code>connect()</code> 参数</h2><p><code>connect</code> 可以接受四个不同的参数, 全部都是可选的：</p><ol><li><code>mapStateToProps?: Function</code></li><li><code>mapDispatchToProps?: Function | Object</code></li><li><code>mergeProps?: Function</code></li><li><code>options?: Object</code></li></ol><h1 id="Connect-Extracting-Data-with-mapStateToProps"><a href="#Connect-Extracting-Data-with-mapStateToProps" class="headerlink" title="Connect: Extracting Data with mapStateToProps"></a>Connect: Extracting Data with <code>mapStateToProps</code></h1><p>作为第一个传入<code>connect</code>的参数，<code>mapStateToProps</code>从<code>Store</code>选择一部分数据，传给需要的组件。</p><ul><li>当<code>store</code>的<code>state</code>数据变化的时候会调用改函数。</li><li>它接受一整个<code>store state</code>，返回一个对象包含组件需要的数据。</li></ul><h2 id="定义-mapStateToProps"><a href="#定义-mapStateToProps" class="headerlink" title="定义 mapStateToProps"></a>定义 <code>mapStateToProps</code></h2><p><code>mapStateToProps</code>应该被定义为一个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state, ownProps?</span>)</span></span><br></pre></td></tr></table></figure><p>它应该接受一个名为<code>state</code>的第一个参数，可以选择一个称为<code>ownProps</code>的第二个参数，并返回一个包含连接组件所需数据的普通对象。</p><p>此函数应作为<code>connect</code>的第一个参数传递，并将在每次<code>Redux</code>存储状态更改时调用。如果您不想订阅存储，请传递<code>null</code>或undefined来代替<code>mapStateToProps</code>进行连接。</p><p>不管<code>mapstatetops</code>函数是使用<code>function</code>关键字<code>（function mapState（state）{}）</code>还是作为箭头函数<code>（constmapstate=（state）=&gt;{}</code>编写的，它的工作方式都是一样的。</p><h3 id="Arguments"><a href="#Arguments" class="headerlink" title="Arguments"></a>Arguments</h3><ol><li><strong><code>state</code></strong></li><li><strong><code>ownProps</code> (可选的)</strong></li></ol><h4 id="state"><a href="#state" class="headerlink" title="state"></a><code>state</code></h4><p><code>mapStateToProps</code>函数的第一个参数是整个<code>Redux</code>存储状态（调用存储.<code>getState()</code>). 因此，第一个论点传统上被称为<code>state</code>。（虽然您可以给参数指定任何名称，但将其称为store是不正确的-它是“state value”，而不是“store instance”。）</p><p>至少state作为参数是应该被传入到mapStateToProps函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; todos &#125; = state</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">todoList</span>: todos.allIds &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps)(TodoList)</span><br></pre></td></tr></table></figure><h4 id="ownProps-optional"><a href="#ownProps-optional" class="headerlink" title="ownProps (optional)"></a><code>ownProps</code> (optional)</h4><p>如果组件需要从自己的属性中获取数据来从存储中检索数据，则可以使用第二个参数ownProps定义函数。此参数将包含给connect生成的包装器组件的所有属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state, ownProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; visibilityFilter &#125; = state</span><br><span class="line">  <span class="keyword">const</span> &#123; id &#125; = ownProps</span><br><span class="line">  <span class="keyword">const</span> todo = getTodoById(state, id)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// component receives additionally:</span></span><br><span class="line">  <span class="keyword">return</span> &#123; todo, visibilityFilter &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Later, in your application, a parent component renders:</span></span><br><span class="line">;<span class="xml"><span class="tag">&lt;<span class="name">ConnectedTodo</span> <span class="attr">id</span>=<span class="string">&#123;123&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">// and your component receives props.id, props.todo, and props.visibilityFilter</span></span><br></pre></td></tr></table></figure><h3 id="Return"><a href="#Return" class="headerlink" title="Return"></a>Return</h3><p>mapToProps函数应返回一个包含组件所需数据的纯对象：</p><ul><li>Each field in the object will become a prop for your actual component</li><li>The values in the fields will be used to determine if your component needs to re-render</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    a: <span class="number">42</span>,</span><br><span class="line">    todos: state.todos,</span><br><span class="line">    filter: state.visibilityFilter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// component will receive: props.a, props.todos, and props.filter</span></span><br></pre></td></tr></table></figure><h2 id="Usage-Guidelines"><a href="#Usage-Guidelines" class="headerlink" title="Usage Guidelines"></a>Usage Guidelines</h2><ol><li><h3 id="Let-mapStateToProps-Reshape-the-Data-from-the-Store"><a href="#Let-mapStateToProps-Reshape-the-Data-from-the-Store" class="headerlink" title="Let mapStateToProps Reshape the Data from the Store"></a>Let <code>mapStateToProps</code> Reshape the Data from the Store</h3></li><li><h3 id="Use-Selector-Functions-to-Extract-and-Transform-Data"><a href="#Use-Selector-Functions-to-Extract-and-Transform-Data" class="headerlink" title="Use Selector Functions to Extract and Transform Data"></a>Use Selector Functions to Extract and Transform Data</h3></li><li><h3 id="mapStateToProps-Functions-Should-Be-Fast"><a href="#mapStateToProps-Functions-Should-Be-Fast" class="headerlink" title="mapStateToProps Functions Should Be Fast"></a><code>mapStateToProps</code> Functions Should Be Fast</h3></li><li><h3 id="mapStateToProps-Functions-Should-Be-Pure-and-Synchronous"><a href="#mapStateToProps-Functions-Should-Be-Pure-and-Synchronous" class="headerlink" title="mapStateToProps Functions Should Be Pure and Synchronous"></a><code>mapStateToProps</code> Functions Should Be Pure and Synchronous</h3></li></ol><h1 id="Connect-Dispatching-Actions-with-mapDispatchToProps"><a href="#Connect-Dispatching-Actions-with-mapDispatchToProps" class="headerlink" title="Connect: Dispatching Actions with mapDispatchToProps"></a>Connect: Dispatching Actions with <code>mapDispatchToProps</code></h1><p>作为传递给connect的第二个参数，mapDispatchToProps用于将操作分派到存储区。</p><p><code>dispatch</code>是Redux Store之中唯一的函数。我们只有调用<code>store.dispatch</code>去发送一个<code>action</code>。</p><p>使用React Redux，您的组件永远不会直接访问存储区—connect会为您执行此操作。React Redux为您提供了两种让组件分派操作的方法：</p><ul><li>By default, a connected component receives <code>props.dispatch</code> and can dispatch actions itself.</li><li><code>connect</code> can accept an argument called <code>mapDispatchToProps</code>, which lets you create functions that dispatch when called, and pass those functions as props to your component.</li></ul><h2 id="Approaches-for-Dispatching"><a href="#Approaches-for-Dispatching" class="headerlink" title="Approaches for Dispatching"></a>Approaches for Dispatching</h2><h3 id="Default-dispatch-as-a-Prop"><a href="#Default-dispatch-as-a-Prop" class="headerlink" title="Default: dispatch as a Prop"></a>Default: <code>dispatch</code> as a Prop</h3><p>如果不指定connect（）的第二个参数，则默认情况下，组件将接收dispatch。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">connect()(MyComponent)</span><br><span class="line"><span class="comment">// which is equivalent with</span></span><br><span class="line">connect(</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="literal">null</span></span><br><span class="line">)(MyComponent)</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">connect(mapStateToProps <span class="comment">/** no second argument */</span>)(MyComponent)</span><br></pre></td></tr></table></figure><p>以这种方式连接组件后，组件将接收道具调度. 您可以使用它将操作分派到存储。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123; count, dispatch &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">'DECREMENT'</span> &#125;)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;span&gt;&#123;count&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: 'INCREMENT' &#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">'RESET'</span> &#125;)&#125;&gt;reset&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Providing-A-mapDispatchToProps-Parameter"><a href="#Providing-A-mapDispatchToProps-Parameter" class="headerlink" title="Providing A mapDispatchToProps Parameter"></a>Providing A <code>mapDispatchToProps</code> Parameter</h3><p>提供mapDispatchToProps允许您指定哪一种的<code>action</code>需要被分派。它允许您提供<code>action dispatch</code>作为传参。因此，与其调用函数<code>props.dispatch(()=&gt;increment())</code>，可以调用直接调用<code>prop.increment()</code>。你可能想这么做有几个原因。</p><h4 id="More-Declarative"><a href="#More-Declarative" class="headerlink" title="More Declarative"></a>More Declarative</h4><p>首先，将<code>dispatch</code>逻辑封装到函数中使实现更具声明性。<code>dispatch</code>一个动作并让Redux存储处理数据流是如何实现行为的，而不是它做什么。</p><p>一个很好的例子是在单击按钮时<code>dispatch</code>操作。直接连接按钮在概念上可能没有意义，按钮引用<code>dispatch</code>也没有意义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// button needs to be aware of "dispatch"</span></span><br><span class="line">&lt;button onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">"SOMETHING"</span> &#125;)&#125; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// button unaware of "dispatch",</span></span><br><span class="line">&lt;button onClick=&#123;doSomething&#125; /&gt;</span><br></pre></td></tr></table></figure><p>一旦您用<code>dispatch</code>动作的函数包装了所有<code>action</code>创建者，组件就不需要分派了。因此，如果您定义自己的<code>mapDispatchToProps</code>，则连接的组件将不再接收<code>dispatch</code>。</p><h4 id="Pass-Down-Action-Dispatching-Logic-to-Unconnected-Child-Components"><a href="#Pass-Down-Action-Dispatching-Logic-to-Unconnected-Child-Components" class="headerlink" title="Pass Down Action Dispatching Logic to ( Unconnected ) Child Components"></a>Pass Down Action Dispatching Logic to ( Unconnected ) Child Components</h4><p>此外，您还可以将操作分派函数传递给子（可能是未连接的）组件。这允许更多的组件分派动作，同时让它们“不知道”Redux。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pass down toggleTodo to child component</span></span><br><span class="line"><span class="comment">// making Todo able to dispatch the toggleTodo action</span></span><br><span class="line"><span class="keyword">const</span> TodoList = <span class="function">(<span class="params">&#123; todos, toggleTodo &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;todos.map(<span class="function"><span class="params">todo</span> =&gt;</span> (</span><br><span class="line">      &lt;Todo todo=&#123;todo&#125; onClick=&#123;toggleTodo&#125; /&gt;</span><br><span class="line">    ))&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><p>这就是<code>React Redux</code>的<code>connect</code>所做的——它封装了与<code>Redux store</code>对话的逻辑，让您不用担心它。这是你应该在你的实现中充分利用的。</p><h2 id="Two-Forms-of-mapDispatchToProps"><a href="#Two-Forms-of-mapDispatchToProps" class="headerlink" title="Two Forms of mapDispatchToProps"></a>Two Forms of <code>mapDispatchToProps</code></h2><p>mapDispatchToProps参数可以有两种形式。虽然函数形式允许更多的定制，但对象形式易于使用。</p><ul><li><strong>Function form</strong>: Allows more customization, gains access to <code>dispatch</code> and optionally <code>ownProps</code></li><li><strong>Object shorthand form</strong>: More declarative and easier to use</li></ul><h2 id="Defining-mapDispatchToProps-As-A-Function"><a href="#Defining-mapDispatchToProps-As-A-Function" class="headerlink" title="Defining mapDispatchToProps As A Function"></a>Defining <code>mapDispatchToProps</code> As A Function</h2><p>将<code>mapDispatchToProps</code>定义为一个函数，可以在自定义组件接收的函数以及它们如何分派操作方面提供最大的灵活性。你可以获得调度和拥有权。您可以利用这个机会编写自定义函数，以供连接的组件调用。</p><h3 id="Arguments-1"><a href="#Arguments-1" class="headerlink" title="Arguments"></a>Arguments</h3><ol><li><strong><code>dispatch</code></strong></li><li><strong><code>ownProps</code> (optional)</strong></li></ol><p><strong><code>dispatch</code></strong></p><p>将调用<code>mapDispatchToProps</code>函数，并将<code>dispatch</code>作为第一个参数。通常，通过返回在其内部调用<code>dispatch()</code>的新函数，并直接传入纯操作对象或传入操作创建者的结果来使用此方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// dispatching plain actions</span></span><br><span class="line">    increment: <span class="function"><span class="params">()</span> =&gt;</span> dispatch(&#123; <span class="attr">type</span>: <span class="string">'INCREMENT'</span> &#125;),</span><br><span class="line">    decrement: <span class="function"><span class="params">()</span> =&gt;</span> dispatch(&#123; <span class="attr">type</span>: <span class="string">'DECREMENT'</span> &#125;),</span><br><span class="line">    reset: <span class="function"><span class="params">()</span> =&gt;</span> dispatch(&#123; <span class="attr">type</span>: <span class="string">'RESET'</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您还可能希望将参数转发给<code>action creator</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// explicitly forwarding arguments</span></span><br><span class="line">    onClick: <span class="function"><span class="params">event</span> =&gt;</span> dispatch(trackClick(event)), <span class="comment">//trackClick() is an anction creator</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// implicitly forwarding arguments</span></span><br><span class="line">    onReceiveImpressions: <span class="function">(<span class="params">...impressions</span>) =&gt;</span></span><br><span class="line">      dispatch(trackImpressions(impressions)) <span class="comment">//trackImpressions() is also an anction creator</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>ownProps</code> ( optional )</strong></p><p>如果您的<code>mapDispatchToProps</code>函数被声明为接受两个参数，那么它将被调用，第一个参数是dispatch，传递给连接组件的属性作为第二个参数，并且在连接的组件接收到新的属性时将重新调用它。</p><p>这意味着，在组件重新呈现时，您可以在组件的属性发生更改时进行重新绑定，而不是在组件重新呈现时将新的属性重新绑定到<code>action dispatchers</code>。</p><p><strong>Binds on component mount</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.props.toggleTodo(this.props.todoId)&#125; /&gt;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">const mapDispatchToProps = dispatch =&gt; &#123;</span></span><br><span class="line"><span class="xml">  return &#123;</span></span><br><span class="line"><span class="xml">    toggleTodo: todoId =&gt; dispatch(toggleTodo(todoId))</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>Binds on <code>props</code> change</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.props.toggleTodo()&#125; /&gt;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">const mapDispatchToProps = (dispatch, ownProps) =&gt; &#123;</span></span><br><span class="line"><span class="xml">  return &#123;</span></span><br><span class="line"><span class="xml">    toggleTodo: () =&gt; dispatch(toggleTodo(ownProps.todoId))</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Return-1"><a href="#Return-1" class="headerlink" title="Return"></a>Return</h3><p><code>mapDispatchToProps</code>函数应返回一个纯对象：</p><ul><li>Each field in the object will become a separate prop for your own component, and the value should normally be a function that dispatches an action when called.</li><li>If you use action creators ( as oppose to plain object actions ) inside <code>dispatch</code>, it is a convention to simply name the field key the same name as the action creator:</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> increment = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">type</span>: <span class="string">'INCREMENT'</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> decrement = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">type</span>: <span class="string">'DECREMENT'</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> reset = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">type</span>: <span class="string">'RESET'</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// dispatching actions returned by action creators</span></span><br><span class="line">    increment: <span class="function"><span class="params">()</span> =&gt;</span> dispatch(increment()),</span><br><span class="line">    decrement: <span class="function"><span class="params">()</span> =&gt;</span> dispatch(decrement()),</span><br><span class="line">    reset: <span class="function"><span class="params">()</span> =&gt;</span> dispatch(reset())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mapDispatchToProps</code>函数的返回将作为道具合并到连接的组件中。你可以直接调用他们，让他们<code>dispatch action</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123; count, increment, decrement, reset &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;decrement&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;span&gt;&#123;count&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;increment&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;reset&#125;&gt;reset&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Defining-the-mapDispatchToProps-Function-with-bindActionCreators"><a href="#Defining-the-mapDispatchToProps-Function-with-bindActionCreators" class="headerlink" title="Defining the mapDispatchToProps Function with bindActionCreators"></a>Defining the <code>mapDispatchToProps</code> Function with <code>bindActionCreators</code></h3><p>手动的将这些函数包装起来是可笑的，所以Redux提供了一个函数去简化。</p><p><code>bindActionCreators</code> accepts two parameters:</p><ol><li>A <strong><code>function</code></strong> (an action creator) or an <strong><code>object</code></strong> (each field an action creator)</li><li><code>dispatch</code></li></ol><p><code>bindActionCreators</code>生成的包装器函数将自动转发它们的所有参数，因此您不需要手动执行此操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> increment = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">type</span>: <span class="string">'INCREMENT'</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> decrement = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">type</span>: <span class="string">'DECREMENT'</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> reset = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">type</span>: <span class="string">'RESET'</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// binding an action creator</span></span><br><span class="line"><span class="comment">// returns (...args) =&gt; dispatch(increment(...args))</span></span><br><span class="line"><span class="keyword">const</span> boundIncrement = bindActionCreators(increment, dispatch)</span><br><span class="line"></span><br><span class="line"><span class="comment">// binding an object full of action creators</span></span><br><span class="line"><span class="keyword">const</span> boundActionCreators = bindActionCreators(</span><br><span class="line">  &#123; increment, decrement, reset &#125;,</span><br><span class="line">  dispatch</span><br><span class="line">)</span><br><span class="line"><span class="comment">// returns</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   increment: (...args) =&gt; dispatch(increment(...args)),</span></span><br><span class="line"><span class="comment">//   decrement: (...args) =&gt; dispatch(decrement(...args)),</span></span><br><span class="line"><span class="comment">//   reset: (...args) =&gt; dispatch(reset(...args)),</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>To use <code>bindActionCreators</code> in our <code>mapDispatchToProps</code> function:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> bindActionCreators(&#123; increment, decrement, reset &#125;, dispatch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// component receives props.increment, props.decrement, props.reset</span></span><br><span class="line">connect(</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(Counter)</span><br></pre></td></tr></table></figure><h3 id="Manually-Injecting-dispatch"><a href="#Manually-Injecting-dispatch" class="headerlink" title="Manually Injecting dispatch"></a>Manually Injecting <code>dispatch</code></h3><p>如果提供了<code>mapDispatchToProps</code>参数，组件将不再接收默认分派。您可以通过手动将其添加到<code>mapDispatchToProps</code>的返回中来恢复它，尽管大多数情况下您不需要这样做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    dispatch,</span><br><span class="line">    ...bindActionCreators(&#123; increment, decrement, reset &#125;, dispatch)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Defining-mapDispatchToProps-As-An-Object"><a href="#Defining-mapDispatchToProps-As-An-Object" class="headerlink" title="Defining mapDispatchToProps As An Object"></a>Defining <code>mapDispatchToProps</code> As An Object</h2><p>您已经看到，在React组件中调度Redux动作的设置过程非常相似：定义一个动作创建者，将其包装在另一个类似于的函数中<code>(…args) =&gt; dispatch(actionCreator(…args))</code>，并将该包装函数作为prop传递给您的组件。</p><p>因为这很普遍，所以<code>connect</code>支持参数的“对象简写”形式<code>mapDispatchToProps</code>：如果传递的对象中包含操作创建者而不是函数，<code>connect</code>则将<code>bindActionCreators</code>在内部自动调用您。</p><p><strong>我们建议始终使用的“对象简写”形式<code>mapDispatchToProps</code>，除非您有特定的原因自定义调度行为。</strong></p><p>注意：</p><ul><li><code>mapDispatchToProps</code>假定对象的每个字段都是动作创建者</li><li>您的组件将不再<code>dispatch</code>作为道具接收</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React Redux does this for you automatically:</span></span><br><span class="line">dispatch =&gt; bindActionCreators(mapDispatchToProps, dispatch)</span><br></pre></td></tr></table></figure><p>Therefore, our <code>mapDispatchToProps</code> can simply be:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = &#123;</span><br><span class="line">  increment,</span><br><span class="line">  decrement,</span><br><span class="line">  reset</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Since the actual name of the variable is up to you, you might want to give it a name like <code>actionCreators</code>, or even define the object inline in the call to <code>connect</code>:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;increment, decrement, reset&#125; <span class="keyword">from</span> <span class="string">"./counterActions"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actionCreators = &#123;</span><br><span class="line">  increment,</span><br><span class="line">  decrement,</span><br><span class="line">  reset</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapState, actionCreators)(Counter);</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(</span><br><span class="line">  mapState,</span><br><span class="line">  &#123; increment, decrement, reset &#125;</span><br><span class="line">)(Counter);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redux</title>
      <link href="/2020/09/16/Redux/"/>
      <url>/2020/09/16/Redux/</url>
      
        <content type="html"><![CDATA[<h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><h2 id="什么时候需要-Redux"><a href="#什么时候需要-Redux" class="headerlink" title="什么时候需要 Redux"></a>什么时候需要 Redux</h2><p>首先明确一点，Redux 是一个有用的架构，但不是非用不可。事实上，大多数情况，你可以不用它，只用 React 就够了。</p><p>简单说，如果你的UI层非常简单，没有很多互动，Redux 就是不必要的，用了反而增加复杂性。Redux 的适用场景：多交互、多数据源。</p><p>从组件角度看，如果你的应用有以下场景，可以考虑使用 Redux。</p><ul><li>某个组件的状态，需要共享</li><li>某个状态需要在任何地方都可以拿到</li><li>一个组件需要改变全局状态</li><li>一个组件需要改变另一个组件的状态</li></ul><h2 id="基本概念和-API"><a href="#基本概念和-API" class="headerlink" title="基本概念和 API"></a>基本概念和 API</h2><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>Store 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。</p><p>Redux 提供<code>createStore</code>这个函数，用来生成 Store。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(fn);</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>createStore</code>函数接受另一个函数作为参数，返回新生成的 Store 对象。</p><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p><code>Store</code>对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。</p><p>当前时刻的 State，可以通过<code>store.getState()</code>拿到。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(fn);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = store.getState();</span><br></pre></td></tr></table></figure></blockquote><p>Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。</p><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>State 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。</p><p>Action 是一个对象。其中的<code>type</code>属性是必须的，表示 Action 的名称。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> action = &#123;</span><br><span class="line">  type: <span class="string">'ADD_TODO'</span>,</span><br><span class="line">  payload: <span class="string">'Learn Redux'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，Action 的名称是<code>ADD_TODO</code>，它携带的信息是字符串<code>Learn Redux</code>。</p><p>可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。</p><h3 id="Action-Creator"><a href="#Action-Creator" class="headerlink" title="Action Creator"></a>Action Creator</h3><p>View 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ADD_TODO = <span class="string">'添加 TODO'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: ADD_TODO,</span><br><span class="line">    text</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> action = addTodo(<span class="string">'Learn Redux'</span>);</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>addTodo</code>函数就是一个 Action Creator。</p><h3 id="store-dispatch"><a href="#store-dispatch" class="headerlink" title="store.dispatch()"></a>store.dispatch()</h3><p><code>store.dispatch()</code>是 View 发出 Action 的唯一方法。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(fn);</span><br><span class="line"></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="string">'ADD_TODO'</span>,</span><br><span class="line">  payload: <span class="string">'Learn Redux'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>store.dispatch</code>接受一个 Action 对象作为参数，将它发送出去。</p><p>结合 Action Creator，这段代码可以改写如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(addTodo(<span class="string">'Learn Redux'</span>));</span><br></pre></td></tr></table></figure></blockquote><h2 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h2><p>Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。</p><p>Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = <span class="function"><span class="keyword">function</span> (<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> new_state;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>整个应用的初始状态，可以作为 State 的默认值。下面是一个实际的例子。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultState = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = defaultState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ADD'</span>:</span><br><span class="line">      <span class="keyword">return</span> state + action.payload;</span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = reducer(<span class="number">1</span>, &#123;</span><br><span class="line">  type: <span class="string">'ADD'</span>,</span><br><span class="line">  payload: <span class="number">2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>reducer</code>函数收到名为<code>ADD</code>的 Action 以后，就返回一个新的 State，作为加法的计算结果。其他运算的逻辑（比如减法），也可以根据 Action 的不同来实现。</p><p>实际应用中，Reducer 函数不用像上面这样手动调用，<code>store.dispatch</code>方法会触发 Reducer 的自动执行。为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入<code>createStore</code>方法。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>createStore</code>接受 Reducer 作为参数，生成一个新的 Store。以后每当<code>store.dispatch</code>发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State。</p><p>为什么这个函数叫做 Reducer 呢？因为它可以作为数组的<code>reduce</code>方法的参数。请看下面的例子，一系列 Action 对象按照顺序作为一个数组。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> actions = [</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">'ADD'</span>, <span class="attr">payload</span>: <span class="number">0</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">'ADD'</span>, <span class="attr">payload</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">'ADD'</span>, <span class="attr">payload</span>: <span class="number">2</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> total = actions.reduce(reducer, <span class="number">0</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，数组<code>actions</code>表示依次有三个 Action，分别是加<code>0</code>、加<code>1</code>和加<code>2</code>。数组的<code>reduce</code>方法接受 Reducer 函数作为参数，就可以直接得到最终的状态<code>3</code>。</p><h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>什么是纯函数？<a href="https://www.jianshu.com/p/a5a6d4399d69" target="_blank" rel="noopener">https://www.jianshu.com/p/a5a6d4399d69</a> </p><p>由于 Reducer 是纯函数，就可以保证同样的State，必定得到同样的 View。但也正因为这一点，Reducer 函数里面不能改变 State，必须返回一个全新的对象，请参考下面的写法。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// State 是一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123; thingToChange &#125;);</span><br><span class="line">  <span class="comment">// 或者</span></span><br><span class="line">  <span class="keyword">return</span> &#123; ...state, ...newState &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// State 是一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...state, newItem];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>最好把 State 对象设成只读。你没法改变它，要得到新的 State，唯一办法就是生成一个新对象。这样的好处是，任何时候，与某个 View 对应的 State 总是一个不变的对象。</p><h3 id="store-subscribe"><a href="#store-subscribe" class="headerlink" title="store.subscribe()"></a>store.subscribe()</h3><p>Store 允许使用<code>store.subscribe</code>方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line"></span><br><span class="line">store.subscribe(listener);</span><br></pre></td></tr></table></figure></blockquote><p>显然，只要把 View 的更新函数（对于 React 项目，就是组件的<code>render</code>方法或<code>setState</code>方法）放入<code>listen</code>，就会实现 View 的自动渲染。</p><p><code>store.subscribe</code>方法返回一个函数，调用这个函数就可以解除监听。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unsubscribe = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(store.getState())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">unsubscribe();</span><br></pre></td></tr></table></figure></blockquote><h2 id="Store-的实现"><a href="#Store-的实现" class="headerlink" title="Store 的实现"></a>Store 的实现</h2><p>上一节介绍了 Redux 涉及的基本概念，可以发现 Store 提供了三个方法。</p><blockquote><ul><li>store.getState()</li><li>store.dispatch()</li><li>store.subscribe()</li></ul></blockquote><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">let</span> &#123; subscribe, dispatch, getState &#125; = createStore(reducer);</span><br></pre></td></tr></table></figure></blockquote><p><code>createStore</code>方法还可以接受第二个参数，表示 State 的最初状态。这通常是服务器给出的。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> store = createStore(todoApp, <span class="built_in">window</span>.STATE_FROM_SERVER)</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>window.STATE_FROM_SERVER</code>就是整个应用的状态初始值。注意，如果提供了这个参数，它会覆盖 Reducer 函数的默认初始值。</p><p>下面是<code>createStore</code>方法的一个简单实现，可以了解一下 Store 是怎么生成的。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createStore = <span class="function">(<span class="params">reducer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> state;</span><br><span class="line">  <span class="keyword">let</span> listeners = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> state;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">    state = reducer(state, action);</span><br><span class="line">    listeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener());</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> subscribe = <span class="function">(<span class="params">listener</span>) =&gt;</span> &#123;</span><br><span class="line">    listeners.push(listener);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      listeners = listeners.filter(<span class="function"><span class="params">l</span> =&gt;</span> l !== listener);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  dispatch(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; getState, dispatch, subscribe &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><h2 id="Reducer-的拆分"><a href="#Reducer-的拆分" class="headerlink" title="Reducer 的拆分"></a>Reducer 的拆分</h2><p>Reducer 函数负责生成 State。由于整个应用只有一个 State 对象，包含所有数据，对于大型应用来说，这个 State 必然十分庞大，导致 Reducer 函数也十分庞大。</p><p>请看下面的例子。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> chatReducer = <span class="function">(<span class="params">state = defaultState, action = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; type, payload &#125; = action;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ADD_CHAT:</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">        chatLog: state.chatLog.concat(payload)</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="keyword">case</span> CHANGE_STATUS:</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">        statusMessage: payload</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="keyword">case</span> CHANGE_USERNAME:</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">        userName: payload</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，三种 Action 分别改变 State 的三个属性。</p><blockquote><ul><li>ADD_CHAT：<code>chatLog</code>属性</li><li>CHANGE_STATUS：<code>statusMessage</code>属性</li><li>CHANGE_USERNAME：<code>userName</code>属性</li></ul></blockquote><p>这三个属性之间没有联系，这提示我们可以把 Reducer 函数拆分。不同的函数负责处理不同属性，最终把它们合并成一个大的 Reducer 即可。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> chatReducer = <span class="function">(<span class="params">state = defaultState, action = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    chatLog: chatLog(state.chatLog, action),</span><br><span class="line">    statusMessage: statusMessage(state.statusMessage, action),</span><br><span class="line">    userName: userName(state.userName, action)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，Reducer 函数被拆成了三个小函数，每一个负责生成对应的属性。</p><p>这样一拆，Reducer 就易读易写多了。而且，这种拆分与 React 应用的结构相吻合：一个 React 根组件由很多子组件构成。这就是说，子组件与子 Reducer 完全可以对应。</p><p>Redux 提供了一个<code>combineReducers</code>方法，用于 Reducer 的拆分。你只要定义各个子 Reducer 函数，然后用这个方法，将它们合成一个大的 Reducer。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chatReducer = combineReducers(&#123;</span><br><span class="line">  chatLog,</span><br><span class="line">  statusMessage,</span><br><span class="line">  userName</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> todoApp;</span><br></pre></td></tr></table></figure></blockquote><p>上面的代码通过<code>combineReducers</code>方法将三个子 Reducer 合并成一个大的函数。</p><p>这种写法有一个前提，就是 State 的属性名必须与子 Reducer 同名。如果不同名，就要采用下面的写法。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</span><br><span class="line">  a: doSomethingWithA,</span><br><span class="line">  b: processB,</span><br><span class="line">  c: c</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    a: doSomethingWithA(state.a, action),</span><br><span class="line">    b: processB(state.b, action),</span><br><span class="line">    c: c(state.c, action)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>总之，<code>combineReducers()</code>做的就是产生一个整体的 Reducer 函数。该函数根据 State 的 key 去执行相应的子 Reducer，并将返回结果合并成一个大的 State 对象。</p><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><p>下面我们来看一个最简单的实例。</p><blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter = <span class="function">(<span class="params">&#123; value &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;h1&gt;&#123;value&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const render = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  ReactDOM.render(</span></span><br><span class="line"><span class="regexp">    &lt;Counter value=&#123;store.getState()&#125;/</span>&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">store.subscribe(render);</span><br><span class="line">render</span><br></pre></td></tr></table></figure></blockquote><p>上面是一个简单的计数器，唯一的作用就是把参数<code>value</code>的值，显示在网页上。Store 的监听函数设置为<code>render</code>，每次 State 的变化都会导致网页重新渲染。</p><p>下面加入一点变化，为<code>Counter</code>添加递增和递减的 Action。</p><blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter = <span class="function">(<span class="params">&#123; value, onIncrement, onDecrement &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &lt;h1&gt;&#123;value&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">  &lt;button onClick=&#123;onIncrement&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">  &lt;button onClick=&#123;onDecrement&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const reducer = (state = 0, action) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  switch (action.type) &#123;</span></span><br><span class="line"><span class="regexp">    case 'INCREMENT': return state + 1;</span></span><br><span class="line"><span class="regexp">    case 'DECREMENT': return state - 1;</span></span><br><span class="line"><span class="regexp">    default: return state;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const store = createStore(reducer);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const render = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  ReactDOM.render(</span></span><br><span class="line"><span class="regexp">    &lt;Counter</span></span><br><span class="line"><span class="regexp">      value=&#123;store.getState()&#125;</span></span><br><span class="line"><span class="regexp">      onIncrement=&#123;() =&gt; store.dispatch(&#123;type: 'INCREMENT'&#125;)&#125;</span></span><br><span class="line"><span class="regexp">      onDecrement=&#123;() =&gt; store.dispatch(&#123;type: 'DECREMENT'&#125;)&#125;</span></span><br><span class="line"><span class="regexp">    /</span>&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">render();</span><br><span class="line">store.subscribe(render);</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React Hook</title>
      <link href="/2020/09/15/React%20Hook/"/>
      <url>/2020/09/15/React%20Hook/</url>
      
        <content type="html"><![CDATA[<h1 id="React-Hook"><a href="#React-Hook" class="headerlink" title="React Hook"></a>React Hook</h1><h2 id="📌-State-Hook"><a href="#📌-State-Hook" class="headerlink" title="📌 State Hook"></a>📌 State Hook</h2><p>“Hook是react 16.8的新增特性。它可以让你在不编写class的情况下使用state。”这是React官网</p><p>对Hook最直接的解释。不使用class而是普通的函数去封装组件或者页面。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 声明一个新的叫做 “count” 的 state 变量</span></span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click me</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这里我们引入并解构出useState方法来声明一个Hook当中的state变量。 <code>const [count, setCount] = useState(0);</code>这一个语句中useState的唯一参数为声明的state的初始值，例如这里的count为一个数字，并且初始值为0。setCount则像setState方法一样去改变state的值。</p><p><strong><code>useState</code> 方法的返回值是什么？</strong> 返回值为：当前 state 以及更新 state 的函数。这就是我们写 <code>const [count, setCount] = useState()</code> 的原因。这与 class 里面 <code>this.state.count</code> 和 <code>this.setState</code> 类似，唯一区别就是你需要成对的获取它们。</p><p>下面展示同一个class封装的组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            count: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    click() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;count&#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      count: count + <span class="number">1</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;<span class="keyword">this</span>.state.count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;this.click.bind(this)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click me</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  ); </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>大体来说两者可以完成同一个功能就是记下按钮被点击的次数。我们可以明显观察到hook的使用变量的改变和显示都比class要简单很多。</p><h4 id="声明多个state变量"><a href="#声明多个state变量" class="headerlink" title="声明多个state变量"></a>声明多个state变量</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExampleWithManyStates</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 声明多个 state 变量！</span></span><br><span class="line">  <span class="keyword">const</span> [age, setAge] = useState(<span class="number">42</span>);</span><br><span class="line">  <span class="keyword">const</span> [fruit, setFruit] = useState(<span class="string">'banana'</span>);</span><br><span class="line">  <span class="keyword">const</span> [todos, setTodos] = useState([&#123; <span class="attr">text</span>: <span class="string">'Learn Hooks'</span> &#125;]);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="那么，什么是-Hook"><a href="#那么，什么是-Hook" class="headerlink" title="那么，什么是 Hook?"></a>那么，什么是 Hook?</h4><p>Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。Hook 不能在 class 组件中使用 —— 这使得你不使用 class 也能使用 React。</p><p>React 内置了一些像 <code>useState</code> 这样的 Hook。你也可以创建你自己的 Hook 来复用不同组件之间的状态逻辑。我们会先介绍这些内置的 Hook。</p><h2 id="⚡️-Effect-Hook"><a href="#⚡️-Effect-Hook" class="headerlink" title="⚡️ Effect Hook"></a>⚡️ Effect Hook</h2><p>你之前可能已经在 React 组件中执行过数据获取、订阅或者手动修改过 DOM。我们统一把这些操作称为“副作用”，或者简称为“作用”。</p><p><strong><code>useEffect</code> 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 具有相同的用途，只不过被合并成了一个 API。</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 相当于 componentDidMount 和 componentDidUpdate:</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用浏览器的 API 更新页面标题</span></span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click me</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            count: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">         <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span> times`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidUpdate()&#123;</span><br><span class="line">         <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span> times`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    click() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;count&#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      count: count + <span class="number">1</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;<span class="keyword">this</span>.state.count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;this.click.bind(this)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click me</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  ); </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>当你调用 <code>useEffect</code> 时，就是在告诉 React 在完成对 DOM 的更改后运行你的“副作用”函数。由于副作用函数是在组件内声明的，所以它们可以访问到组件的 props 和 state。默认情况下，React 会在每次渲染后调用副作用函数 —— <strong>包括</strong>第一次渲染的时候。(useEffect会在每一次页面渲染时调用。)</p><p>副作用函数还可以通过返回一个函数来指定如何“清除”副作用。例如，在下面的组件中使用副作用函数来订阅好友的在线状态，并通过取消订阅来进行清除操作：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>) </span>&#123;</span><br><span class="line">    setIsOnline(status.isOnline);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isOnline === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Loading...'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isOnline ? <span class="string">'Online'</span> : <span class="string">'Offline'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，React 会在组件销毁时取消对 <code>ChatAPI</code> 的订阅，然后在后续渲染时重新执行副作用函数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">componentDidMount()&#123;</span><br><span class="line">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">&#125;</span><br><span class="line">componentWillUnmount()&#123;</span><br><span class="line">    ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">&#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><h3 id="通过跳过-Effect-进行性能优化"><a href="#通过跳过-Effect-进行性能优化" class="headerlink" title="通过跳过 Effect 进行性能优化"></a>通过跳过 Effect 进行性能优化</h3><p>在某些情况下，每次渲染后都执行清理或者执行 effect 可能会导致性能问题。在 class 组件中，我们可以通过在 <code>componentDidUpdate</code> 中添加对 <code>prevProps</code> 或 <code>prevState</code> 的比较逻辑解决：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line">  <span class="keyword">if</span> (prevState.count !== <span class="keyword">this</span>.state.count) &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span> times`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是很常见的需求，所以它被内置到了 <code>useEffect</code> 的 Hook API 中。如果某些特定值在两次重渲染之间没有发生变化，你可以通知 React <strong>跳过</strong>对 effect 的调用，只要传递数组作为 <code>useEffect</code> 的第二个可选参数即可：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">&#125;, [count]); <span class="comment">// 仅在 count 更改时更新</span></span><br></pre></td></tr></table></figure><p>上面这个示例中，我们传入 <code>[count]</code> 作为第二个参数。这个参数是什么作用呢？如果 <code>count</code> 的值是 <code>5</code>，而且我们的组件重渲染的时候 <code>count</code> 还是等于 <code>5</code>，React 将对前一次渲染的 <code>[5]</code> 和后一次渲染的 <code>[5]</code> 进行比较。因为数组中的所有元素都是相等的(<code>5 === 5</code>)，React 会跳过这个 effect，这就实现了性能的优化。</p><p>当渲染时，如果 <code>count</code> 的值更新成了 <code>6</code>，React 将会把前一次渲染时的数组 <code>[5]</code> 和这次渲染的数组 <code>[6]</code> 中的元素进行对比。这次因为 <code>5 !== 6</code>，React 就会再次调用 effect。如果数组中有多个元素，即使只有一个元素发生变化，React 也会执行 effect。</p><p>对于有清除操作的 effect 同样适用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>) </span>&#123;</span><br><span class="line">    setIsOnline(status.isOnline);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, [props.friend.id]); <span class="comment">// 仅在 props.friend.id 发生变化时，重新订阅</span></span><br></pre></td></tr></table></figure><p>未来版本，可能会在构建时自动添加第二个参数。</p><h2 id="✌️-Hook-使用规则"><a href="#✌️-Hook-使用规则" class="headerlink" title="✌️ Hook 使用规则"></a>✌️ Hook 使用规则</h2><p>Hook 就是 JavaScript 函数，但是使用它们会有两个额外的规则：</p><ul><li><p>只能在<strong>函数最外层</strong>调用 Hook。不要在循环、条件判断或者子函数中调用。</p></li><li><p>只能在 <strong>React 的函数组件</strong>中调用 Hook。不要在其他 JavaScript 函数中调用。（还有一个地方可以调用 Hook —— 就是自定义的 Hook 中，我们稍后会学习到。）</p></li><li><p>React 的函数组件是这样的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Example = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 你可以在这使用 Hook</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>或是这样：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 你可以在这使用 Hook</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>你之前可能把它们叫做“无状态组件”。但现在我们为它们引入了使用 React state 的能力，所以我们更喜欢叫它”函数组件”。</p><p>Hook 在 class 内部是<strong>不</strong>起作用的。但你可以使用它们来取代 class 。</p></li></ul><h2 id="💡-自定义-Hook"><a href="#💡-自定义-Hook" class="headerlink" title="💡 自定义 Hook"></a>💡 自定义 Hook</h2><p>前面，我们介绍了一个叫 <code>FriendStatus</code> 的组件，它通过调用 <code>useState</code> 和 <code>useEffect</code> 的 Hook 来订阅一个好友的在线状态。假设我们想在另一个组件里重用这个订阅逻辑。</p><p>首先，我们把这个逻辑抽取到一个叫做 <code>useFriendStatus</code> 的自定义 Hook 里：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFriendStatus</span>(<span class="params">friendID</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>) </span>&#123;</span><br><span class="line">    setIsOnline(status.isOnline);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isOnline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它将 <code>friendID</code> 作为参数，并返回该好友是否在线：</p><p>现在我们可以在两个组件中使用它：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isOnline = useFriendStatus(props.friend.id);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isOnline === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Loading...'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isOnline ? <span class="string">'Online'</span> : <span class="string">'Offline'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendListItem</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isOnline = useFriendStatus(props.friend.id);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;li style=&#123;&#123; <span class="attr">color</span>: isOnline ? <span class="string">'green'</span> : <span class="string">'black'</span> &#125;&#125;&gt;</span><br><span class="line">      &#123;props.friend.name&#125;</span><br><span class="line">    &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>每个组件间的 state 是完全独立的。Hook 是一种复用<em>状态逻辑</em>的方式，它不复用 state 本身。事实上 Hook 的每次<em>调用</em>都有一个完全独立的 state —— 因此你可以在单个组件中多次调用同一个自定义 Hook。</p><p>自定义 Hook 更像是一种约定而不是功能。如果函数的名字以 “<code>use</code>” 开头并调用其他 Hook，我们就说这是一个自定义 Hook。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JS Chapter 7</title>
      <link href="/2020/06/30/JS%20Chapter%207/"/>
      <url>/2020/06/30/JS%20Chapter%207/</url>
      
        <content type="html"><![CDATA[<h2 id="Object-orientation-with-prototypes"><a href="#Object-orientation-with-prototypes" class="headerlink" title="Object orientation with prototypes"></a>Object orientation with prototypes</h2><p>虽然在之后avascript或者其一些框架的使用中，原型和原型链的概念很少被提到。但是原型作为JavaScript的基本的重要概念之一，也是需要被我们掌握的。</p><h3 id="原型的概念"><a href="#原型的概念" class="headerlink" title="原型的概念"></a>原型的概念</h3><p>书上给出的概念 A prototype is an object to which the search for a particular property can be delegated to.</p><p>首先最简单的缩句理解prototype就是一个对象，对象有一些特殊的属性。</p><h3 id="Understanding-protototypes"><a href="#Understanding-protototypes" class="headerlink" title="Understanding protototypes"></a>Understanding protototypes</h3><p>我们可以先创造一个对象，对象里面包含一些字面对象得标记</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">prop1: <span class="number">1</span>,</span><br><span class="line">prop2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">prop3: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以进行一些修改删除操作,也可以添加一个完全新的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">obj.prop1 = <span class="number">1</span>;</span><br><span class="line">obj.prop1 = [];</span><br><span class="line"><span class="keyword">delete</span> obj.prop2;</span><br><span class="line">obj.prop4 = <span class="string">"Hello"</span>;</span><br></pre></td></tr></table></figure><p>最后object的内容是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">prop1:[],</span><br><span class="line">prop3:&#123;&#125;,</span><br><span class="line">prop4:<span class="string">"Hello"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当在开发软件时，我们会希望减少代码的冗余量，尽可能的去重复利用一些代码，其中我们可以利用Javascript中继承的特性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> yoshi = &#123;<span class="attr">skulk</span>: <span class="literal">true</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> hattori = &#123;<span class="attr">sneak</span>: <span class="literal">true</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> kuma = &#123;<span class="attr">creep</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">assert(<span class="string">"skulk"</span> <span class="keyword">in</span> yoshi, <span class="string">"Yoshi can skulk"</span>);</span><br><span class="line">assert(!(<span class="string">"sneak"</span> <span class="keyword">in</span> yoshi), <span class="string">"Yoshi cannot sneak"</span>);</span><br><span class="line">assert(!(<span class="string">"creep"</span> <span class="keyword">in</span> yoshi), <span class="string">"Yoshi cannot creep"</span>);</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(yoshi, hattori);<span class="comment">//把hattori设为yoshi的原型</span></span><br><span class="line">assert(<span class="string">"sneak"</span> <span class="keyword">in</span> yoshi, <span class="string">"Yoshi can now sneak"</span>);</span><br><span class="line">assert(!(<span class="string">"creep"</span> <span class="keyword">in</span> hattori), <span class="string">"Hattori cannot creep"</span>);</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(hattori, kuma);<span class="comment">//把kuma设为hattori的原型</span></span><br><span class="line">assert(<span class="string">"creep"</span> <span class="keyword">in</span> yoshi, <span class="string">"Hattori can now creep"</span>);</span><br><span class="line">assert(<span class="string">"creep"</span> <span class="keyword">in</span> hattori, <span class="string">"Yoshi can also creep"</span>);</span><br></pre></td></tr></table></figure><p>画一下这个一条原型链。[[prototype]]</p><h3 id="Object-construction-and-prototypes"><a href="#Object-construction-and-prototypes" class="headerlink" title="Object construction and prototypes"></a>Object construction and prototypes</h3><p>我们首先使用JavaScript当中的new关键字来完成原型链的构成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ninja</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">Ninja.prototype.swingSword = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ninja1 = Ninja();</span><br><span class="line">assert(ninja1 === <span class="literal">undefined</span>,<span class="string">"No instance of Ninja created."</span>);</span><br><span class="line"><span class="keyword">const</span> ninja2 = <span class="keyword">new</span> Ninja();</span><br><span class="line">assert(ninja2 &amp;&amp; ninja2.swingSword &amp;&amp; ninja2.swingSword(),<span class="string">"Instance exists and method is callable."</span>);</span><br></pre></td></tr></table></figure><p>Ninja这个函数对象当中我们创建了一个函数在他的原型当中，这个原型对象当中有constructor指向他自己（Ninja）和一个swingSword函数。当我们使用new关键字时，其实一共有四个步骤：</p><ol><li>new了之后，在内存中申请一块空闲的空间，存储创建的新的对象。</li><li>在函数最顶端有一个理论上的空对象即this：把this设置为当前的对象。</li><li>执行构造函数把this对象中的数据填满：设置对象的属性和方法的值。</li><li>最后一步有一个隐式的return this; 把this这个对象返回。</li></ol><h4 id="instance-properties"><a href="#instance-properties" class="headerlink" title="instance properties"></a>instance properties</h4><p>这里我们用this参数来完成Ninja函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ninja</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.swung = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">this</span>.swingSword = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> !<span class="keyword">this</span>.swung;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">Ninja.prototype.swingSword = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.swung;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> ninja = <span class="keyword">new</span> Ninja();</span><br><span class="line">assert(ninja.swingSword(), <span class="string">"Called the instance method, not the prototype method."</span>);</span><br></pre></td></tr></table></figure><p>上面提到的new关键字的实际四个步骤，这里的ninja其实就是指向ninja本身的this对象。ninja本身会有swung和swingSword属性，和他存在一个原型指向ninja的原型。ninja原型之中也会有一个swingSword方法，但是我们在调用swingSword方法可以看到返回的值为true而不是false本身，因为当我们调用swingSword时，ninja会在其本身去寻找有没有这个swingSword方法，当swingSword不存在时，才再开始在其原型中寻找函数。比如，我们会在一些数组对象Array或者字符串对象String使用一些方法时，sort，map等，我们并没有直接在这些对象之中定义，而是他们继承了Array和String的原型，而去他的原型当中寻找这些方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ninja.prototype = &#123;</span><br><span class="line">pierce: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行到该句时，Ninja的原型会指向新的这个对象包含pierce函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ninja</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> ninja = <span class="keyword">new</span> Ninja();</span><br><span class="line">assert(<span class="keyword">typeof</span> ninja === <span class="string">"object"</span>, <span class="string">"The type of the instance is object."</span>);</span><br><span class="line">assert(ninja <span class="keyword">instanceof</span> Ninja, <span class="string">"instanceof identifies the constructor."</span>);</span><br><span class="line">assert(ninja.constructor === Ninja, <span class="string">"The ninja object was created by the  Ninja function"</span>);</span><br></pre></td></tr></table></figure><p>从这几行代码可以得出ninja是一个的对象，也是Ninja得一个实例，而ninja的原型里面的constructor指向的Ninja</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ninja</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> ninja = <span class="keyword">new</span> Ninja();</span><br><span class="line"><span class="keyword">const</span> ninja2 = <span class="keyword">new</span> ninja.constructor();</span><br><span class="line">assert(ninja2 <span class="keyword">instanceof</span> Ninja, <span class="string">"It's a Ninja!"</span>);</span><br><span class="line">assert(ninja !== ninja2,<span class="string">"But not the same Ninja"</span>);</span><br></pre></td></tr></table></figure><p>我们通过ninja.constructor来构建一个新的对象，而ninja2也是一个Ninja的实例。</p><h3 id="Achieving-inheritance"><a href="#Achieving-inheritance" class="headerlink" title="Achieving inheritance"></a>Achieving inheritance</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Person.prototype.dance = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ninja</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Ninja.prototype = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">const</span> ninja = <span class="keyword">new</span> Ninja();</span><br><span class="line">assert(ninja <span class="keyword">instanceof</span> Ninja, <span class="string">"ninja receives functionality from the Ninja prototype"</span>);</span><br><span class="line">assert(ninja <span class="keyword">instanceof</span> Person, <span class="string">"...and the Person prototype"</span>);</span><br><span class="line">assert(ninja <span class="keyword">instanceof</span> <span class="built_in">Object</span>, <span class="string">"...and the Object prototype"</span>);</span><br><span class="line">assert(<span class="keyword">typeof</span> ninja.dance === <span class="string">"function"</span>,<span class="string">"..and can dance!"</span>)</span><br></pre></td></tr></table></figure><p>这里是一个原型链的继承，ninja是Ninja的实例也是Person的实例也是一个对象实例。</p><h3 id="Using-JavaScript-“classes”-in-ES6"><a href="#Using-JavaScript-“classes”-in-ES6" class="headerlink" title="Using JavaScript “classes” in ES6"></a>Using JavaScript “classes” in ES6</h3><p>我们实际在开发过程中，我们会经常使用ES6中的新特性classes。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ninja</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        walk()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">swingSword()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ninja.prototype.swingSword = ()&#123; return true&#125;;</span></span><br><span class="line"><span class="keyword">static</span> dance()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ninja = <span class="keyword">new</span> Ninja(<span class="string">"Yoshi"</span>);</span><br><span class="line">assert(ninja.swingSword(),<span class="string">"and he can swing a sword"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(name)&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">dance()&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ninja</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name,weapon)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.weapon = weapon;</span><br><span class="line">    &#125;</span><br><span class="line">    wieldWeapon()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JS Chapter 6</title>
      <link href="/2020/06/10/JS%20Chapter%206/"/>
      <url>/2020/06/10/JS%20Chapter%206/</url>
      
        <content type="html"><![CDATA[<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>先看三段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ninjas = syncGetJSON(<span class="string">"ninjas.json"</span>);</span><br><span class="line">    <span class="keyword">var</span> missions = syncGetJSON(ninjas[<span class="number">0</span>].missionsUrl);</span><br><span class="line">    <span class="keyword">var</span> missionDetails = syncGetJSON(mission[<span class="number">0</span>].detailsUrl);</span><br><span class="line">    <span class="comment">//Study the mission description</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="comment">//Oh no, we weren't able to get the mission details</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"ninjas.json"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,ninjas</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Error fetching list of ninjas"</span>,err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    getJSON(ninjas[<span class="number">0</span>].missionsUrl,<span class="function"><span class="keyword">function</span>(<span class="params">err,missions</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Error locating ninja missions"</span>,err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        getJSON(mission[<span class="number">0</span>].detailsUrl,<span class="function"><span class="keyword">function</span>(<span class="params">err,missionDetails</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Error locating mission details"</span>,err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="comment">//Study the intel plan</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ninjas = syncGetJSON(<span class="string">"ninjas.json"</span>);</span><br><span class="line">    <span class="keyword">var</span> missions = syncGetJSON(ninjas[<span class="number">0</span>].missionsUrl);</span><br><span class="line">    <span class="keyword">var</span> missionDetails = syncGetJSON(mission[<span class="number">0</span>].detailsUrl);</span><br><span class="line">    <span class="comment">//Study the mission description</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="comment">//Oh no, we weren't able to get the mission details</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第一段代码问题：从服务器获得数据是一个长期运行的操作，因为<code>JavaScript</code>是依赖单线程模式，我们会锁住我们的<code>UI</code>直到这整个代码运行结束。这导致了无法反应的应用和使用户失望。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">WeaponGenerator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">yield</span> <span class="string">"Katana"</span>;</span><br><span class="line"><span class="keyword">yield</span> <span class="string">"Wakizashi"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> weaponsIterator = WeaponGenerator();</span><br><span class="line"><span class="keyword">const</span> result1 = weaponsIterator.next();</span><br><span class="line">assert(<span class="keyword">typeof</span> result1 === <span class="string">"object"</span> &amp;&amp; result1.value === <span class="string">"katana"</span> &amp;&amp; !result1.done,<span class="string">"Katana recevied!"</span>);</span><br><span class="line"><span class="keyword">const</span> result2 = weaponsIterator.next();</span><br><span class="line">assert(<span class="keyword">typeof</span> result2 === <span class="string">"object"</span> &amp;&amp; result2.value === <span class="string">"wakizashi"</span> &amp;&amp; !result2.done,<span class="string">"wakizashi recevied!"</span>);</span><br><span class="line"><span class="keyword">const</span> result3 = weaponsIterator.next();</span><br><span class="line">assert(<span class="keyword">typeof</span> result3 === <span class="string">"object"</span> &amp;&amp; result3.value === <span class="literal">undefined</span> &amp;&amp; result3.done,<span class="string">"There are no more results!"</span>);</span><br></pre></td></tr></table></figure><p><code>WeaponGenerator</code>是构造器，<code>weaponsIterator.next()</code>会返回一个对象，如果传入值则<code>yield</code>被替换为改值，对象有两个属性<code>value</code>和<code>done</code>，当第三次返回对象时<code>done</code>的值为<code>true</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">WarriorGenerator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">yield</span> <span class="string">"Katana"</span>;</span><br><span class="line"><span class="keyword">yield</span>* NinjaGenerator();</span><br><span class="line"><span class="keyword">yield</span> <span class="string">"Wakizashi"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">NinjaGenerator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"Hattori"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"Yoshi"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> warrior <span class="keyword">of</span> WarriorGenerator())&#123;</span><br><span class="line">    assert(warrior !== <span class="literal">null</span>, warrior);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似于链表的结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">NinjaGenerator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">"Hattori"</span>;</span><br><span class="line">        fail(<span class="string">"The expected exception didn't occur"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        assert(e === <span class="string">"Catch this!"</span>,<span class="string">"Aha! We caught an exception"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ninjaIterator = NinjaGenrator();</span><br><span class="line"><span class="keyword">const</span> result1 = ninjaIterator().next();</span><br><span class="line">assert(result1.value === <span class="string">"Hattori"</span>, <span class="string">"We got Hattori"</span>);</span><br><span class="line">ninjaIterator.throw(<span class="string">"Catch this!"</span>);</span><br></pre></td></tr></table></figure><p>这里是说有throw这个方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">NinjaGenerator</span>(<span class="params">action</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> imposter = <span class="keyword">yield</span> (<span class="string">"Hattori"</span> + action);</span><br><span class="line">    assert(imposter === <span class="string">"Hanzo"</span>,<span class="string">"The generator has been infiltrated"</span>);</span><br><span class="line">    <span class="keyword">yield</span> (<span class="string">"Yoshi ("</span> + imposter + <span class="string">") "</span> + action);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ninjaIterator = NinjaGenerator(<span class="string">"skulk"</span>);</span><br><span class="line"><span class="keyword">const</span> result1 = ninjaIterator.next();</span><br><span class="line">assert(result1.value === <span class="string">"Hattori skulk"</span>, <span class="string">"Hattori is skulking"</span>);</span><br><span class="line"><span class="keyword">const</span> result2 = ninjaIterator.next(<span class="string">"Hanzo"</span>);</span><br><span class="line">assert(result2.value === <span class="string">"Yoshi (Hanzo) skulk"</span>, <span class="string">"We have an imposter!"</span>);</span><br></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>来搬一个别人的博客<a href="https://www.jianshu.com/p/1b63a13c2701" target="_blank" rel="noopener">https://www.jianshu.com/p/1b63a13c2701</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JS Chapter 5</title>
      <link href="/2020/06/02/JS%20Chapter%205/"/>
      <url>/2020/06/02/JS%20Chapter%205/</url>
      
        <content type="html"><![CDATA[<h2 id="Closure"><a href="#Closure" class="headerlink" title="Closure"></a>Closure</h2><h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><h6 id="A-closure-is-the-combination-of-a-function-and-the-lexical-environment-within-which-that-function-was-declared"><a href="#A-closure-is-the-combination-of-a-function-and-the-lexical-environment-within-which-that-function-was-declared" class="headerlink" title="A closure is the combination of a function and the lexical environment within which that function was declared."></a>A closure is the combination of a function and the lexical environment within which that function was declared.</h6><h3 id="二、Lexical-Environment（词法环境）"><a href="#二、Lexical-Environment（词法环境）" class="headerlink" title="二、Lexical Environment（词法环境）"></a>二、Lexical Environment（词法环境）</h3><p>​        这个链接详细介绍了什么是词法环境。<a href="https://segmentfault.com/a/1190000015172796" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015172796</a> </p><h3 id="三、区分的两个概念"><a href="#三、区分的两个概念" class="headerlink" title="三、区分的两个概念"></a>三、区分的两个概念</h3><p>​        一开始看闭包这个部分的时候一直没有搞懂为什么不能在外部变量访问内部变量的问题，其实是我把两个概念给搞混了。</p><p>​        为什么不能访问内部变量这个问题很简单，就是局部变量的生存周期与函数的调用时一样，一旦函数调用完毕，这些局部变量就不在存在了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> outter = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> inner = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        而我一开始困惑了很久，就是为什么<code>a.b</code>，这样的就可以访问呢？ 那我搞混的两个概念就是<strong>局部变量</strong>和<strong>对象的属性或者方法</strong>。</p><p>​        局部变量就是上面所说的，那么对象的属性或方法来举例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Object</span>();<span class="comment">//a是一个对象</span></span><br><span class="line">a.b = <span class="number">2</span>;</span><br><span class="line">alert(a.b);</span><br></pre></td></tr></table></figure><h3 id="四、小桃花穿越故事"><a href="#四、小桃花穿越故事" class="headerlink" title="四、小桃花穿越故事"></a>四、小桃花穿越故事</h3><p>先举一个简单的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">t1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">t2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           alert(age);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> t2;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">var</span> tmp = t1();</span><br><span class="line">tmp();<span class="comment">//----------------------------20</span></span><br></pre></td></tr></table></figure><p>​        大部分的语言，t1被调用执行，则申请内存，并把其局部变量age, push入栈,t1函数执行完毕，内部的局部变量，随着函数的退出而销毁.因此age = 20 的局部变量已经消失了;<br>​        但是在js中，age = 20 这个变量，却被t2捕捉，即使t1执行完毕，通过t2仍然可以访问t2依然可以访问该变量。这也是实现上面的访问局部变量。</p><p>​        再来看一下，这个情形的过程，引入js闭包的知识点。<br>​        在js中，t1执行过程中又生成了t2，而作用域上来说，t2能访问到age = 20，于是age = 20 不会消失，而是与返回的t1函数形成了一个环境包，这个包是t2的<strong>(把其周围的变量环境形成了封闭的环境包 共同返回)</strong>，即使t1执行完毕，通过t2仍然可以访问t1依然可以访问该变量，这就是闭包!!!<br><strong>小桃花穿越</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">closure</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sister = <span class="string">'大桃花'</span>;</span><br><span class="line">    <span class="keyword">var</span> me = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(sister);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> me;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">place</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sister = <span class="string">'清朝大福晋'</span>;</span><br><span class="line">    <span class="keyword">var</span> girl = closure();</span><br><span class="line">    girl();</span><br><span class="line">&#125;</span><br><span class="line">place();<span class="comment">//------------------------------大桃花</span></span><br></pre></td></tr></table></figure><h3 id="五、闭包计数器"><a href="#五、闭包计数器" class="headerlink" title="五、闭包计数器"></a>五、闭包计数器</h3><p>闭包来维护一个别人污染不到的变量 做计数器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;)();</span><br><span class="line">alert(fn());<span class="comment">//------------------1</span></span><br><span class="line">alert(fn());<span class="comment">//------------------2</span></span><br><span class="line">alert(fn());<span class="comment">//------------------3</span></span><br></pre></td></tr></table></figure><p>这里放一个经典的案例就也不搬过来了。<a href="https://blog.csdn.net/Tacks/article/details/78704922" target="_blank" rel="noopener">https://blog.csdn.net/Tacks/article/details/78704922</a></p><h2 id="Stack-Heap"><a href="#Stack-Heap" class="headerlink" title="Stack Heap"></a>Stack Heap</h2><p>一开始了解的stack栈就是<strong>上进上出 先入后出</strong>这样子，也不想搬运别人博客了就放一个链接<a href="https://www.jianshu.com/p/90808ed34b86" target="_blank" rel="noopener">https://www.jianshu.com/p/90808ed34b86</a></p><p>heap堆之前了解并不多来搬运一下博客链接吧。<a href="https://blog.csdn.net/qian3223/article/details/82424757" target="_blank" rel="noopener">https://blog.csdn.net/qian3223/article/details/82424757</a></p><h2 id="Types-of-JavaScript-variables"><a href="#Types-of-JavaScript-variables" class="headerlink" title="Types of JavaScript variables"></a>Types of JavaScript variables</h2><p>​    <code>var</code>关键字是JavaScript创造开始时的一部分，然而<code>let</code>和<code>const</code>关键字的在ES6版本中更新的产物。</p><h3 id="变量易变性（variables-mutability）"><a href="#变量易变性（variables-mutability）" class="headerlink" title="变量易变性（variables mutability）"></a>变量易变性（variables mutability）</h3><p>​    如果我们按照变量区分他们，<code>const</code>则与剩余的两个有很大区别。所有以<code>const</code>声明的变量都是不可改变的。那么以剩下两个关键字声明的变量都可以反复改变很多次的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstConst = <span class="string">"samurai"</span>;</span><br><span class="line">assert(firstConst === <span class="string">"samurai"</span>,<span class="string">"firstConst is a samruai"</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">firstConst = <span class="string">"ninja"</span>;</span><br><span class="line">    fail(<span class="string">"Shouldn't be here"</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    pass(<span class="string">"An exception has occurred"</span>);</span><br><span class="line">&#125;</span><br><span class="line">assert(firstConst === <span class="string">"samurai"</span>,<span class="string">"firstCount is still a samuerai"</span>);</span><br><span class="line"><span class="keyword">const</span> secondConst = &#123;&#125;;</span><br><span class="line">secondConst.weapon = <span class="string">"wakizashi"</span>;</span><br><span class="line">assert(secondConst.weapon === <span class="string">"wakizashi"</span>,<span class="string">"We can add new properties"</span>);</span><br><span class="line"><span class="keyword">const</span> thirdConst = [];</span><br><span class="line">assert(thirdConst.length === <span class="number">0</span>, <span class="string">"No items in our array"</span>);</span><br><span class="line">thirdConst.push(<span class="string">"Yoshi"</span>);</span><br><span class="line">assert(thirdConst.length === <span class="number">1</span>, <span class="string">"The array has changed"</span>);</span><br></pre></td></tr></table></figure><p>​        首先，我们声明且初始化了<code>firstConst</code>变量为<code>samurai</code>，我们继续给他赋一个全新的值<code>ninja</code>，因为<code>firstConst</code>是一个常量，所以我们<code>ninja</code>赋值失败。所以，<code>JavaScript</code>的引擎会丢出一个<code>exception</code>事件，我们用到<code>fail</code>和<code>pass</code>方法（这两者和<code>assert</code>类似）来测试<code>exception</code>事件是否发生了。如果<code>exception</code>发生了，<code>catch</code>语句会被激活，然后<code>pass</code>语句也就被执行了。反之，<code>fail</code>语句就会被执行。</p><p>​        再而，我们声明一个空对象<code>secondConst</code>和空数组<code>thirdCosnt</code>。我们已经知道了不能改变常量的值，但是我们可以给它增添属性。</p><h3 id="变量声明关键字和词法作用域"><a href="#变量声明关键字和词法作用域" class="headerlink" title="变量声明关键字和词法作用域"></a>变量声明关键字和词法作用域</h3><p>​        不同关键字声明有不同的作用域，这一部分比较简单，总的来说，就是<code>var</code>无论在哪儿声明都是以最近的函数作用域或者全局作用域，而<code>const</code>和<code>let</code>可以为块作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> local = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++);</span><br><span class="line">    assert(i == <span class="number">10</span>,<span class="string">"i is ten"</span>);</span><br><span class="line">&#125;</span><br><span class="line">assert(<span class="keyword">typeof</span> i === <span class="string">"undefined"</span>,<span class="string">"We cannot see function variables outside of a function"</span>);</span><br></pre></td></tr></table></figure><h3 id="在词法作用域中的寄存（状态提升）"><a href="#在词法作用域中的寄存（状态提升）" class="headerlink" title="在词法作用域中的寄存（状态提升）"></a>在词法作用域中的寄存（状态提升）</h3><p>​        在<code>JavaScript</code>中，代码的执行分为两个阶段。第一阶段为<code>JavaScript</code>引擎会把所有声明变量和函数声明在当前的词法环境内提前。第二阶段为执行阶段，由函数调用执行或者赋值时开始。其中，<code>var</code> <code>function</code> 只是对变量声明，没有赋值操作。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Sass</title>
      <link href="/2020/04/02/Sass/"/>
      <url>/2020/04/02/Sass/</url>
      
        <content type="html"><![CDATA[<h1 id="Sass学习"><a href="#Sass学习" class="headerlink" title="Sass学习"></a>Sass学习</h1><p>​        因为在Taro项目中有用到Sass，但是当时并没有学习所以就分开来写。</p><h3 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h3><p>因为Taro项目初始化的时候会自行安装，只要选择Sass就行了。所以这里给出官方链接。<a href="https://sass.bootcss.com/install" target="_blank" rel="noopener">https://sass.bootcss.com/install</a></p><h3 id="二、变量"><a href="#二、变量" class="headerlink" title="二、变量"></a>二、变量</h3><p>变量是存储信息并在将来重复利用的一种方式，在整个样式表中都可访问。 你可以在变量中存储颜色、字体 或任何 CSS 值，并在将来重复利用。Sass 使用 <code>$</code> 符号 作为变量的标志。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$font-stack</span>:    Helvetica, sans-serif;</span><br><span class="line"><span class="variable">$primary-color</span>: <span class="number">#333</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font</span>: <span class="number">100%</span> <span class="variable">$font-stack</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$primary-color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font</span>: <span class="number">100%</span> Helvetica, sans-serif;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、嵌套"><a href="#三、嵌套" class="headerlink" title="三、嵌套"></a>三、嵌套</h3><p>​        在编写 HTML 时，它有一个清晰的嵌套和可视化层次结构。 而 CSS 则没有。</p><p>​        Sass 允许嵌套 CSS 选择器，嵌套方式 与 HTML 的视觉层次结构相同。请注意，过度嵌套的规则 将导致过度限定的 CSS，这些 CSS 可能很难维护，并且 通常被认为是不好的做法。</p><p>​        理解了这一点，下面就来看一个典型的网站导航的样式 示例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">li</span> &#123; <span class="attribute">display</span>: inline-block; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、片段"><a href="#四、片段" class="headerlink" title="四、片段"></a>四、片段</h3><p>创建部分Sass文件，其中包含一些CSS片段 ，可以将其包含在其他Sass文件中。这是模块化CSS并帮助使事情易于维护的好方法。部分文件是一个Sass文件，名称前带有一个下划线。可以将其命名为<code>_partial.scss</code>。下划线让Sass知道该文件只是部分文件，不应将其生成为CSS文件。Sass局部函数与<code>@use</code> 规则一起使用。</p><h3 id="五、模块"><a href="#五、模块" class="headerlink" title="五、模块"></a>五、模块</h3><p>不必将所有Sass都写在一个文件中。您可以根据需要将其拆分<code>@use</code>。该规则将另一个Sass文件作为<em>模块</em>加载，这意味着您可以在Sass文件中使用基于文件名的命名空间引用其变量，<a href="https://sass-lang.com/guide#topic-6" target="_blank" rel="noopener">mixins</a>和<a href="https://sass-lang.com/documentation/at-rules/function" target="_blank" rel="noopener">函数</a>。使用文件还将在编译输出中包含它生成的CSS！</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _base.scss</span></span><br><span class="line"><span class="variable">$font-stack</span>:    Helvetica, sans-serif;</span><br><span class="line"><span class="variable">$primary-color</span>: <span class="number">#333</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font</span>: <span class="number">100%</span> <span class="variable">$font-stack</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$primary-color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// styles.scss</span></span><br><span class="line">@use <span class="string">'base'</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inverse</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: base.<span class="variable">$primary-color</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font</span>: <span class="number">100%</span> Helvetica, sans-serif;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inverse</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#333</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、混合"><a href="#六、混合" class="headerlink" title="六、混合"></a>六、混合</h3><p>​        CSS中的某些内容编写起来有些繁琐，尤其是使用CSS3 和存在的许多供应商前缀时。使用mixin，您可以创建要在整个站点中重复使用的CSS声明组 。您甚至可以传入值以使混入更加灵活。mixin的一个很好的用法是用于供应商前缀。这是的示例 <code>transform</code>。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> transform(<span class="variable">$property</span>) &#123;</span><br><span class="line">  -webkit-<span class="attribute">transform</span>: <span class="variable">$property</span>;</span><br><span class="line">  -ms-<span class="attribute">transform</span>: <span class="variable">$property</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="variable">$property</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123; @<span class="keyword">include</span> transform(rotate(<span class="number">30deg</span>)); &#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">rotate</span>(30deg);</span><br><span class="line">  <span class="attribute">-ms-transform</span>: <span class="built_in">rotate</span>(30deg);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(30deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要创建一个mixin，请使用<code>@mixin</code>指令并为其命名。我们将其命名为mixin <code>transform</code>。我们还在<code>$property</code>括号内使用了变量 ，因此我们可以传递任何所需的变换。创建混入之后，您可以将其用作CSS 声明<code>@include</code>，以混入的名称开头。</p><h3 id="七、扩展继承"><a href="#七、扩展继承" class="headerlink" title="七、扩展继承"></a>七、扩展继承</h3><p>​        这是Sass最有用的功能之一。使用<code>@extend</code>使您可以将一组CSS属性从一个选择器共享到另一个选择器。它有助于使Sass保持非常干燥。在我们的示例中，我们将使用扩展，占位符类一起使用的另一个功能，为错误，警告和成功创建一系列简单的消息传递。占位符类是一种特殊的类，仅在扩展时才打印，并且可以帮助保持编译后的CSS整洁。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This CSS will print because %message-shared is extended. */</span></span><br><span class="line">%message-shared &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This CSS won't print because %equal-heights is never extended.</span></span><br><span class="line">%equal-heights &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.message</span> &#123;</span><br><span class="line">  @<span class="keyword">extend</span> %message-shared;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.success</span> &#123;</span><br><span class="line">  @<span class="keyword">extend</span> %message-shared;</span><br><span class="line">  <span class="attribute">border-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">  @<span class="keyword">extend</span> %message-shared;</span><br><span class="line">  <span class="attribute">border-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.warning</span> &#123;</span><br><span class="line">  @<span class="keyword">extend</span> %message-shared;</span><br><span class="line">  <span class="attribute">border-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This CSS will print because %message-shared is extended. */</span></span><br><span class="line"><span class="selector-class">.message</span>, <span class="selector-class">.success</span>, <span class="selector-class">.error</span>, <span class="selector-class">.warning</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.success</span> &#123;</span><br><span class="line">  <span class="attribute">border-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">  <span class="attribute">border-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.warning</span> &#123;</span><br><span class="line">  <span class="attribute">border-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        上面的代码的作用是告诉<code>.message</code>，<code>.success</code>，<code>.error</code>，和<code>.warning</code>做人一样<code>%message-shared</code>。这意味着任何地方<code>%message-shared</code>显示来，<code>.message</code>，<code>.success</code>，<code>.error</code>，和 <code>.warning</code>也会这样做的。魔术发生在生成的CSS中，其中每个类将获得与相同的CSS属性<code>%message-shared</code>。这有助于您避免在HTML 元素上编写多个类名。</p><p>​        除了Sass中的占位符类之外，您还可以扩展最简单的CSS选择器，但是使用占位符是确保不扩展嵌套在样式中其他位置的类的最简单方法，这会导致CSS中意外的选择器 。</p><p>​        请注意，不会生成CSS in <code>%equal-heights</code>，因为<code>%equal-heights</code>它不会被扩展。</p><h3 id="八、操作符"><a href="#八、操作符" class="headerlink" title="八、操作符"></a>八、操作符</h3><p>​        在 CSS 中经常需要做数学计算。Sass 支持一些标准的 数学运算符，例如 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 和 <code>%</code>。在下面的例子中，我们 将做一些简单的数学运算来计算出 <code>aside</code> &amp; <code>article</code> 的宽度。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span><span class="selector-attr">[role="main"]</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span> / <span class="number">960px</span> * <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">aside</span><span class="selector-attr">[role="complementary"]</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span> / <span class="number">960px</span> * <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>孤独星球--Taro框架总结</title>
      <link href="/2020/04/01/%E5%AD%A4%E7%8B%AC%E6%98%9F%E7%90%83--Taro%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/"/>
      <url>/2020/04/01/%E5%AD%A4%E7%8B%AC%E6%98%9F%E7%90%83--Taro%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="孤独星球–Taro框架总结"><a href="#孤独星球–Taro框架总结" class="headerlink" title="孤独星球–Taro框架总结"></a>孤独星球–Taro框架总结</h1><p>​        大一下学期用Taro框架写了QQ的小程序–孤独星球，项目链接在这里。<a href="https://github.com/The-Planet-of-Loneline/project" target="_blank" rel="noopener">https://github.com/The-Planet-of-Loneline/project</a></p><p>​        项目分为白天和黑夜两个部分，白天是同组的刘安完成的，技术含量也比较高；黑夜和登录部分就是由我完成的。接下来就说一下Taro里面的一些细节。</p><h3 id="一、项目结构"><a href="#一、项目结构" class="headerlink" title="一、项目结构"></a>一、项目结构</h3><p>​        因为一开始没有去参照学姐学长做的客栈的框架，所以这个项目的框架比较乱，一些组件的页面的位置也存放的不正确。希望以后的项目能够把公共组件和私有组件分开，组件和页面分开以形成更明晰的结构。以下是参照木犀客栈的结构：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">--src</span></span><br><span class="line"><span class="params">--assets</span>     <span class="string">//</span>存放图片</span><br><span class="line"><span class="params">--png</span></span><br><span class="line"><span class="params">--svg</span></span><br><span class="line"><span class="params">--components</span> <span class="string">//</span>存放组件</span><br><span class="line"><span class="params">--common</span> <span class="string">//</span>公用组件</span><br><span class="line"><span class="params">--index</span>  <span class="string">//</span>私有组件</span><br><span class="line"><span class="params">--pages</span>      <span class="string">//</span>页面</span><br><span class="line"><span class="params">--index</span></span><br><span class="line"><span class="params">--index</span>.jsx</span><br><span class="line"><span class="params">--service</span><span class="string">//Fech</span> API</span><br><span class="line"><span class="params">--Fech</span>.jsx</span><br><span class="line"><span class="params">--app</span>.jsx <span class="string">//</span>配置</span><br><span class="line"><span class="params">--app</span>.scss <span class="string">//</span>样式</span><br><span class="line"><span class="params">--index</span>.html <span class="string">//</span>接口</span><br></pre></td></tr></table></figure><p>一般来说一个项目的结构就如上所示了。</p><h3 id="二、Taro内置组件"><a href="#二、Taro内置组件" class="headerlink" title="二、Taro内置组件"></a>二、Taro内置组件</h3><p>​        刚刚开始写静态页面的时候使用错了组件，还是用的HTML的标签<code>&lt;div&gt; &lt;span&gt;</code>等。要注意以下代码的含义：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Taro, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@tarojs/taro'</span></span><br><span class="line"><span class="keyword">import</span> &#123; View, Text,Image &#125; <span class="keyword">from</span> <span class="string">'@tarojs/components'</span></span><br></pre></td></tr></table></figure><p>​        Taro里面有内置的组件使用，<code>&lt;View&gt; &lt;Text&gt;</code>等类似于HTML中的标签使用。要注意的是，HTML中使用的class选择器，class关键字要改变成classname，因为关键字的保留class类。</p><p>这里的import也是webpack的方法吧，引入你需要的组件例如黑夜的头部和底部：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Head <span class="keyword">from</span> <span class="string">'../component/Head'</span></span><br><span class="line"><span class="keyword">import</span> Footer <span class="keyword">from</span> <span class="string">'../component/Footer'</span></span><br></pre></td></tr></table></figure><p>一定要from正确的路径<code>&#39;../&#39;</code>是返回上一级目录，也可以返回多次。</p><h3 id="三、Taro中的输入框"><a href="#三、Taro中的输入框" class="headerlink" title="三、Taro中的输入框"></a>三、Taro中的输入框</h3><p>​        Taro中的输入框也是Taro当中的内置组件也分为<code>input</code>和<code>textarea</code>，但是要大写<code>&lt;Input /&gt; &lt;Textarea /&gt;</code>，这里顺便提一下Taro里面所有组件开头都要大写。</p><p>​        输入框输入值的时候<code>value</code>要空，且还有监听事件函数<code>onInput</code>，<code>onChange</code>也可以。但是比较坑的事，<code>onInput</code>函数对于<code>Input</code>和<code>Textarea</code>不同。当时产品组给我提的要求是控制行数限制，这里也要说一下<code>Textarea</code>的特性，有换行的监听函数。但是由于<code>onInput</code>对于<code>Textarea</code>的<code>value</code>的改变不能显示于<code>Textarea</code>，而可以显示于<code>Input</code>。最后也是需求改成了字数限制。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;Textarea </span><br><span class="line">className=<span class="string">'write'</span> </span><br><span class="line">value=&#123;Value&#125; </span><br><span class="line">onInput=&#123;<span class="keyword">this</span>.handleInputChange.bind(<span class="keyword">this</span>)&#125; </span><br><span class="line">onFocus=&#123;<span class="keyword">this</span>.handleInput.bind(<span class="keyword">this</span>)&#125;</span><br><span class="line">onBlur=&#123;<span class="keyword">this</span>.handleback.bind(<span class="keyword">this</span>)&#125; </span><br><span class="line">showConfirmBar=&#123;<span class="literal">false</span>&#125;</span><br><span class="line">maxlength=&#123;<span class="number">75</span>&#125;</span><br><span class="line">autoFocus=&#123;<span class="literal">true</span>&#125;</span><br><span class="line">&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Textarea</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>​        组件的写法可以这样换行以更醒目的看见，太长不方便查看。但是一些<code>View</code>好像就不行。</p><h3 id="四、API"><a href="#四、API" class="headerlink" title="四、API"></a>四、API</h3><p>​        写整个项目前最重要的就是沟通，和产品沟通和后端沟通。没有沟通好的后果就是白天好像重新写页面的结构。还好因为黑夜也不难，所以没有做好沟通也影响不大。其中我觉得比较重要的是分页这个部分。因为要考虑到页面的实际需求来看分页的形式和需不需要分页。参考<code>swaggerUI</code>是一个很重要的东西，一定要反复比对。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">onReachBottom()&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.history.length % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            page: <span class="keyword">this</span>.state.page + <span class="number">1</span></span><br><span class="line">        &#125;, () =&gt; &#123;</span><br><span class="line">            Fetch(<span class="string">`secret/history?page=<span class="subst">$&#123;<span class="keyword">this</span>.state.page&#125;</span>`</span>,</span><br><span class="line">                &#123;&#125;,</span><br><span class="line">                <span class="string">'GET'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                        history: <span class="keyword">this</span>.state.history.concat(res.history)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这里是一个后端的分页方法，需要的事我每一次请求时发送一个页面数字给后端，他再返回给我对应数字的内容。这种分页方法个人感觉比较适合网页，而不适合小程序去写。所以我加了限定条件只有显示内容为5个时候才会进行下一次的请求。</p><p>​        API的路径一定要对，我举例困扰我很久的删除功能。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">handleDelete()&#123;</span><br><span class="line">        Fetch(<span class="string">`secret/delete/:secret_id/?secretId=<span class="subst">$&#123;<span class="keyword">this</span>.props.Debunkid&#125;</span>`</span>,</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">        <span class="string">'DELETE'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123; </span><br><span class="line">        Taro.showToast(&#123;</span><br><span class="line">            title: <span class="string">'删除成功'</span>,</span><br><span class="line">            icon: <span class="string">'none'</span></span><br><span class="line">        &#125;)</span><br><span class="line">            <span class="keyword">this</span>.props.onCloseDelete() </span><br><span class="line">            Taro.reLaunch(&#123;</span><br><span class="line">                url:<span class="string">`/pages/Mine/Mine`</span></span><br><span class="line">            &#125;) </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​        这里因为我少了一个<code>/</code>导致我应该不能与后端连接，但是开发者工具可以我也就没有想太多。牢记！！</p><h3 id="五、QQ授权和分享"><a href="#五、QQ授权和分享" class="headerlink" title="五、QQ授权和分享"></a>五、QQ授权和分享</h3><p>​        QQ授权和分享是要过审核必须写的一个API，我们也是事后才写的。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button open-type=<span class="string">'getUserInfo'</span> className=<span class="string">'login'</span> onClick=&#123;<span class="keyword">this</span>.power&#125;&gt;登录&lt;<span class="regexp">/Button&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">power () &#123;</span><br><span class="line">        Taro.getSetting(&#123;</span><br><span class="line">            success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">this</span>.setState(&#123; <span class="attr">powered</span>:res.authSetting[<span class="string">'scope.userInfo'</span>]&#125;)</span><br><span class="line">              <span class="keyword">if</span> (res.authSetting[<span class="string">'scope.userInfo'</span>]) &#123;</span><br><span class="line">                  <span class="keyword">this</span>.onHandleLogin()</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Taro.showShareMenu(&#123;</span><br><span class="line">       showShareItems: [<span class="string">'qq'</span>, <span class="string">'qzone'</span>, <span class="string">'wechatFriends'</span>, <span class="string">'wechatMoment'</span>]</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><p>第一二个代码块是处理授权的部分，第三个是分享。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浏览器输入URL后发生了什么</title>
      <link href="/2019/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
      <url>/2019/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>当我们在浏览器的网址栏输入网址并回车后，一个网页页面就呈现在我们面前。我们有没有思考过浏览器时如何将一个内容丰富的页面给“变”出来的呢？</p><h1 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h1><ol><li>浏览器的地址栏输入URL并按下回车。</li><li>浏览器查找当前URL是否存在缓存，并比较缓存是否过期。</li><li>DNS解析URL对应的IP。</li><li>根据IP建立TCP（三次握手）。</li><li>HTTP发出请求。</li><li>服务器处理请求，浏览器接受HTTP请求。</li><li>渲染页面，构建DOM树。</li><li>关闭TCP连接（四次挥手）。</li></ol><h1 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h1><p>URL的格式</p><p>protocol://hostname[:port]/path/[;parameters] [?query]#fragment</p><ul><li>protocal,协议头，比如http，https等</li><li>host，主机域名或IP地址</li><li>port，端口号一般为默认指所以隐藏起来</li><li>path，目录路径</li><li>query，查询参数</li><li>fragment，#后hash值，一般用来定位到某个位置</li></ul><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>浏览器会对你输入的网址进行判断，有缓存或无。有缓存则直接加载，无则向服务器发出请求。</p><h1 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h1><p>​    我们知道在地址栏输入的域名并不是最后资源所在的真实位置，域名只是与IP地址的一个映射。网络服务器的IP地址那么多，我们不可能去记一串串的数字，因此域名就产生了，<strong>域名解析的过程实际是将域名还原为IP地址的过程</strong>。 首先浏览器先检查本地hosts文件是否有这个网址映射关系，如果有就调用这个IP地址映射，完成域名解析。 如果没找到则会查找本地DNS解析器缓存，如果查找到则返回。如果还是没有找到则会查找本地DNS服务器，如果查找到则返回。</p><p><img src="https://image-static.segmentfault.com/109/829/1098299099-5a1397c093c97" alt="img"> </p><p>​        </p><p><img src="https://image-static.segmentfault.com/160/418/1604181361-5a1397cca5644" alt="img"> </p><h1 id="TCP链接"><a href="#TCP链接" class="headerlink" title="TCP链接"></a>TCP链接</h1><p>拿到服务器IP地址则进行三次握手的连接。 </p><p> <img src="https://image-static.segmentfault.com/336/916/3369169780-5a1397e92a68c" alt="img"> </p><p>客户端发送一个带有SYN标志的数据包给服务端，服务端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息，最后客户端再回传一个带ACK标志的数据包，代表握手结束，连接成功。 </p><h1 id="发送HTTP请求"><a href="#发送HTTP请求" class="headerlink" title="发送HTTP请求"></a>发送HTTP请求</h1><p> 与服务器建立了连接后，就可以向服务器发起请求了。这里我们先看下请求报文的结构（如下图）：<br> <img src="https://image-static.segmentfault.com/194/760/1947600223-5a1397f9f0773" alt="img"> </p><p>请求报文<br>在浏览器中查看报文首部（以google浏览器为例）：<br><img src="https://segmentfault.com/img/bVYTYo?w=366&h=273" alt="图片描述"></p><p>​        请求行包括请求方法、URI、HTTP版本。首部字段传递重要信息，包括请求首部字段、通用首部字段和实体首部字段。我们可以从报文中看到发出的请求的具体信息。</p><p>请求报文的简要分析</p><p><img src="C:%5CUsers%5C%E9%9F%A9%E6%99%A8%E9%BE%99%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191120160027373.png" alt="image-20191120160027373"></p><h1 id="服务器处理请求"><a href="#服务器处理请求" class="headerlink" title="服务器处理请求"></a>服务器处理请求</h1><p>​    服务器端收到请求后的由web服务器（准确说应该是http服务器）处理请求，诸如Apache、Ngnix、IIS等。web服务器解析用户请求，知道了需要调度哪些资源文件，再通过相应的这些资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过web服务器返回给浏览器客户端。</p><p>  <img src="https://image-static.segmentfault.com/159/660/1596606314-5a1259320ba22" alt="img"> </p><h1 id="返回响应结果"><a href="#返回响应结果" class="headerlink" title="返回响应结果"></a>返回响应结果</h1><p>在HTTP里，有请求就会有响应，哪怕是错误信息。这里我们同样看下响应报文的组成结构： </p><p><img src="https://image-static.segmentfault.com/915/283/915283550-5a13982ea260a" alt="img"> </p><p>响应报文</p><p>在响应结果中都会有个一个HTTP状态码，比如我们熟知的200、301、404、500等。通过这个状态码我们可以知道服务器端的处理是否正常，并能了解具体的错误。</p><p>状态码由3位数字和原因短语组成。根据首位数字，状态码可以分为五类：</p><ul><li>1xx：指示信息–表示请求已接收，继续处理。</li><li>2xx：成功–表示请求已被成功接收、理解、接受。</li><li>3xx：重定向–要完成请求必须进行更进一步的操作。</li><li>4xx：客户端错误–请求有语法错误或请求无法实现。</li><li>5xx：服务器端错误–服务器未能实现合法的请求。</li></ul><h1 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h1><p>前面有提到http交互，那么接下来就是浏览器获取到html，然后解析，渲染</p><ol><li><p>解析HTML，构建DOM树</p></li><li><p>解析CSS，生成CSS规则树</p></li><li><p>合并DOM树和CSS规则，生成render树</p></li><li><p>布局render树（Layout/reflow），负责各元素尺寸、位置的计算</p></li><li><p>绘制render树（paint），绘制页面像素信息</p></li><li><p>浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上<br> 如下图：</p></li></ol><p>  <img src="https://upload-images.jianshu.io/upload_images/6007177-342d73de2a8bdc2e.png" alt="img">  </p><p> DOM tree <img src="https://upload-images.jianshu.io/upload_images/6007177-8ec45fe7dd4d5b00.png" alt="img"> </p><p>CSSOM tree </p><p> <img src="https://upload-images.jianshu.io/upload_images/6007177-889050efeb3c811d.png" alt="img"> </p><p>render tree</p><ul><li>在浏览器还没接收到完整的 HTML 文件时，它就开始渲染页面了，在遇到外部链入的脚本标签或样式标签或图片时，会再次发送 HTTP 请求重复上述的步骤。在收到 CSS 文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完立刻显示在相应位置。在这一过程中可能会触发页面的重绘或重排。这里就涉及了两个重要概念：Reflow和Repaint。</li><li>Reflow，也称作Layout，中文叫回流，一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树，这个过程称为Reflow。</li><li>Repaint，中文重绘，意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就OK了，这个过程称为Repaint。</li><li>所以说Reflow的成本比Repaint的成本高得多的多。DOM树里的每个结点都会有reflow方法，一个结点的reflow很有可能导致子结点，甚至父点以及同级结点的reflow。</li></ul><h1 id="关闭TCP连接或继续保持连接"><a href="#关闭TCP连接或继续保持连接" class="headerlink" title="关闭TCP连接或继续保持连接"></a>关闭TCP连接或继续保持连接</h1><p>通过四次挥手关闭连接(FIN ACK, ACK, FIN ACK, ACK)。</p><p> <img src="https://image-static.segmentfault.com/419/355/4193550114-5a125931047be" alt="img"> </p><ul><li>第一次挥手是浏览器发完数据后，发送FIN请求断开连接。</li><li>第二次挥手是服务器发送ACK表示同意，如果在这一次服务器也发送FIN请求断开连接似乎也没有不妥，但考虑到服务器可能还有数据要发送，所以服务器发送FIN应该放在第三次挥手中。</li><li>这样浏览器需要返回ACK表示同意，也就是第四次挥手</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学而页面总结</title>
      <link href="/2019/11/06/%E5%AD%A6%E8%80%8C%E9%A1%B5%E9%9D%A2%E6%80%BB%E7%BB%93/"/>
      <url>/2019/11/06/%E5%AD%A6%E8%80%8C%E9%A1%B5%E9%9D%A2%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="关于HTML和CSS的总结"><a href="#关于HTML和CSS的总结" class="headerlink" title="关于HTML和CSS的总结"></a>关于HTML和CSS的总结</h1><h6 id="在这两周时间，我写了静态的学而网页并进行了一些修改。在学姐学长的帮助和指导之下，我对网页的一些整体布局有所了解，以下为一些自己在写学而时犯下的错误。"><a href="#在这两周时间，我写了静态的学而网页并进行了一些修改。在学姐学长的帮助和指导之下，我对网页的一些整体布局有所了解，以下为一些自己在写学而时犯下的错误。" class="headerlink" title="在这两周时间，我写了静态的学而网页并进行了一些修改。在学姐学长的帮助和指导之下，我对网页的一些整体布局有所了解，以下为一些自己在写学而时犯下的错误。"></a>在这两周时间，我写了静态的学而网页并进行了一些修改。在学姐学长的帮助和指导之下，我对网页的一些整体布局有所了解，以下为一些自己在写学而时犯下的错误。</h6><h4 id="HEADER-PART"><a href="#HEADER-PART" class="headerlink" title="HEADER PART"></a>HEADER PART</h4><p>1.布局方式不要混用（其实适用于很多地方），<code>flex</code> <code>inline-block</code> 和<code>float</code>最好不要混合使用。</p><p>2.尽量减少div的使用。学会思考<code>span</code>和<code>div</code>的使用情况。<code>span</code>作为行内元素，可以用来标记一些行内特殊的元素；<code>div</code>作为块元素，更好的区分出每一个区域。有时候会用很多个<code>div</code>，变成<code>inline-block</code>的样子是因为在行内中出现了不同的功能区。</p><p>3.消除间隙。由于行内元素都是有间隙的所以一般需要消除间隙，例如图片与搜索框之间。</p><p>4.搜索框的写法，一般是用一个大的<code>div</code>把<code>input</code>和图片包裹起来，设置<code>div</code>的<code>border</code>的颜色来展示边框。</p><p>5.实现<code>:hover</code>之后，要确保前后元素的大小一致，这样才美观。</p><h4 id="MIDDLE-PART"><a href="#MIDDLE-PART" class="headerlink" title="MIDDLE PART"></a>MIDDLE PART</h4><p>1.整体布局，用一个<code>div</code>来使多个中间部分水平居中。</p><p>2.在整个页面中最好只采取一种布局方式。</p><p>3.<code>position：sticky</code>可以适用于更多的场合，也更符合如今的审美需求。</p><p>4.<code>input</code>的样式用CSS来改变</p><h4 id="FOOTER-PART"><a href="#FOOTER-PART" class="headerlink" title="FOOTER PART"></a>FOOTER PART</h4><p>1.注意字符间距</p><p>2.<code>body</code>的<code>margin</code>为0或者<code>padding</code>为0；</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>自适应居中</title>
      <link href="/2019/11/02/%E8%87%AA%E9%80%82%E5%BA%94%E5%B1%85%E4%B8%AD/"/>
      <url>/2019/11/02/%E8%87%AA%E9%80%82%E5%BA%94%E5%B1%85%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="关于网页布局中的水平垂直居中"><a href="#关于网页布局中的水平垂直居中" class="headerlink" title="关于网页布局中的水平垂直居中"></a>关于网页布局中的水平垂直居中</h1><h3 id="一、首先来分享最简单的flex布局中如何居中"><a href="#一、首先来分享最简单的flex布局中如何居中" class="headerlink" title="一、首先来分享最简单的flex布局中如何居中"></a>一、首先来分享最简单的flex布局中如何居中</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;<span class="comment">/*水平居中*/</span></span><br><span class="line">    <span class="attribute">align-items</span>: center;<span class="comment">/*垂直居中*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这里father指的是夫元素的盒子，对父元素进行设置<code>display: flex;</code>其中的子元素就会变成项目，父元素本身就成为了flex容器。利用flex的一些特性就可以进行居中的布局。</p><p>​        关于更详细的flex布局，这里有一个链接：<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool</a></p><h3 id="二、”display-inline-block”中如何实现居中"><a href="#二、”display-inline-block”中如何实现居中" class="headerlink" title="二、”display:inline-block”中如何实现居中"></a>二、”display:inline-block”中如何实现居中</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;<span class="comment">/*水平居中*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        当block变成inline-block时，多个div在一个父元素的容器中，<code>margin: 0 auto；</code>就不再有作用。目前我找到的方法只有在父元素中设置<code>text-align: center;</code>使这些div居中。百度中这么解释到，“我们的行内元素就相当于一行之内的文字了”，我也只能这么理解了。对于div中的文字，我们只能再使用<code>text-align: start；</code>之类的属性来使文字排版更理想化。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:auto;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.father</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;<span class="comment">/*垂直居中*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这一串css代码是用来inline-block当中的垂直居中问题，可以用于head当中，因为大多时候head定宽，用一个伪元素设置其高度为100%时，将父元素撑开，子元素就垂直居中啦！也适用于多行文字！</p><h6 id="当然如果head之中只有一行文字，在父元素中设置height与line-height相等时，也可以垂直居中，只是会出现一些小问题。比如只是文字居中而div没有居中。（如果div高和head高不相等）"><a href="#当然如果head之中只有一行文字，在父元素中设置height与line-height相等时，也可以垂直居中，只是会出现一些小问题。比如只是文字居中而div没有居中。（如果div高和head高不相等）" class="headerlink" title="当然如果head之中只有一行文字，在父元素中设置height与line-height相等时，也可以垂直居中，只是会出现一些小问题。比如只是文字居中而div没有居中。（如果div高和head高不相等）"></a>当然如果head之中只有一行文字，在父元素中设置height与line-height相等时，也可以垂直居中，只是会出现一些小问题。比如只是文字居中而div没有居中。（如果div高和head高不相等）</h6><h3 id="三、“display：block”一个block的居中"><a href="#三、“display：block”一个block的居中" class="headerlink" title="三、“display：block”一个block的居中"></a>三、“display：block”一个block的居中</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这一串代码十分简洁，十分容易记住，但是一定要找到使用场合。在一个父元素只有一个子元素时，此代码可以时该元素自适应的居中，比较常用于head套用，page整体布局中。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>:<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        不多说了，注意只能用于单行文字。会使子元素高度变大。</p><h3 id="四、“display-table”的居中"><a href="#四、“display-table”的居中" class="headerlink" title="四、“display: table”的居中"></a>四、“display: table”的居中</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:table-cell;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这种方法适用性不强，因为大多数display属性为block,inlin-block或者flex。再次使用display时可能会改变一些属性。</p><h3 id="五、定位"><a href="#五、定位" class="headerlink" title="五、定位"></a>五、定位</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        该方法用于son宽高已知！</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-50%) <span class="built_in">translateY</span>(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        该方法用于son宽高未知！</p><h6 id="总的来说自适应居中的方法就这些了，如果想看到更多的居中方式可以点击这里访问李雪莲学姐做的总结！！"><a href="#总的来说自适应居中的方法就这些了，如果想看到更多的居中方式可以点击这里访问李雪莲学姐做的总结！！" class="headerlink" title="总的来说自适应居中的方法就这些了，如果想看到更多的居中方式可以点击这里访问李雪莲学姐做的总结！！"></a>总的来说自适应居中的方法就这些了，如果想看到更多的居中方式可以点击这里访问李雪莲学姐做的总结！！</h6><p> <a href="https://lilixuelian.github.io/2019/05/22/center/" target="_blank" rel="noopener">https://lilixuelian.github.io/2019/05/22/center/</a> </p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
